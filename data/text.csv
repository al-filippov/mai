,doc,text,type
16,tz_01.docx,"2.2 Техническое задание
2.2.1 Общие сведения
полное наименование системы и ее условное обозначение: Конфигурация «Бухгалтерия предприятия» в среде «1С: Предприятие 8.1»; 
шифр темы: ДП – УлГТУ –  08080165 – 00/00000 – 2010;
наименование предприятий разработчика и заказчика системы, их реквизиты: УМКУП «Городской градостроительный сервис», .Ульяновск, пер.Комсомольский 3, 8-962-633-01-77;
перечень документов, на основании которых создается информационная система: ; 
плановые сроки начала и окончания работ:1 апреля . – 15 июня .;
сведения об источниках и порядке финансирования работ: работа проводится на безвозмездной основе, не финансируется;
порядок оформления и предъявления заказчику результатов работ по созданию системы, ее частей и отдельных средств: по окончанию работ заказчику передается установочный диск со всеми дистрибутивами, необходимыми для функционирования разработанного программного продукта, а так же сопроводительная документация: техническое задание и методические указания пользователю и программисту.

Назначение и цели создания системы
Разработанный программный продукт предназначен для обеспечения полноты автоматизации деятельности бухгалтера организации УМКУП «Городской градостроительный сервис» при использовании конфигурации «Бухгалтерия предприятия» на платформе «1С: Предприятие 8.1» в части расчета заработной платы  и учета деятельности сотрудников организации. Предполагается использование системы на автоматизированном рабочем месте главного бухгалтера организации.
Основными целями создания системы являются:
дополнение существующей информационной системы, которая не предоставляет возможность расчета заработной платы организации, имеющей специфические принципы оплаты труда соответствующим функционалом, который, кроме того, затрагивает автоматизацию процессов, влияющих на процесс формирования сумм заработной платы;
повышение эффективности исполнения автоматизируемых процессов, путем сокращения непроизводительных и дублирующих операций, операций, выполняемых «вручную», оптимизации информационного взаимодействие участников процессов; 
повышение качества принятия управленческих решений за счет оперативности представления, полноты, достоверности и удобства форматов отображения информации;

Характеристика объектов автоматизации
Объектом автоматизации является процесс учета расчетов с работниками по оплате труда в организации, имеющей специфические принципы формирования расчетных сумм, в части расчета этих сумм и сбора данных из документов оперативного учета для проведения расчета.

Требования к системе
Требования к системе в целом
а) Требования к структуре и функционированию системы
Назначение и цели создания системы должны быть реализованы в двух подсистемах конфигурации «Бухгалтерия предприятия» на платформе «1С: Предприятие8.1»:
Система бухгалтерского учета
Система оперативного учета
Подсистема оперативного учета должна содержать механизмы, позволяющие вводить в систему и хранить в ней информацию о текущей деятельности организации. В этой подсистеме должны фиксироваться и систематизироваться данные, необходимые для реализации расчета сумм начислений. 
Подсистема бухгалтерского учета должна содержать в себе механизмы для реализации учета расчетов с сотрудниками организации. Именно эта подсистема должна реализовывать процесс расчета, используя данные, содержащиеся в подсистеме оперативного учета.
б) Требования к персоналу
Для наиболее эффективного функционирования системы помимо пользователя – главного бухгалтера организации, для автоматизации деятельности которого предназначена система, необходимо иметь специалиста технической поддержки данного программного продукта. 
в) Показатели назначения 
Система должна предусматривать возможность масштабирования по производительности и объему обрабатываемой информации без модификации ее программного обеспечения путем модернизации используемого комплекса технических средств. Изменение процессов управления не должно отражаться на правильности функционирования системы.
г) Требования к надежности, эргономике, защите и сохранности информации, защите от внешних воздействий.
Система должна сохранять работоспособность и обеспечивать восстановление своих функций при возникновении следующих внештатных ситуаций:
при сбоях в системе электроснабжения аппаратной части, приводящих к перезагрузке ОС;
при ошибках в работе аппаратных средств (кроме носителей данных и программ) восстановление функции системы возлагается на ОС;
при ошибках, связанных с программным обеспечением (ОС и драйверы устройств), восстановление работоспособности возлагается на ОС
система должна обеспечивать корректную обработку аварийных ситуаций, вызванных неверными действиями пользователей, неверным форматом или недопустимыми значениями входных данных. В указанных случаях система должна выдавать пользователю соответствующие сообщения, после чего возвращаться в рабочее состояние, предшествовавшее неверной (недопустимой) команде или некорректному вводу данных. 
Система должна быть эргономичной. Интерфейс системы должен быть понятным и удобным, не должен быть перегружен графическими элементами и должен обеспечивать быстрое отображение экранных форм. Навигационные элементы должны быть выполнены в удобной для пользователя форме. Средства редактирования информации должны удовлетворять принятым соглашениям в части использования функциональных клавиш, режимов работы, поиска, использования оконной системы. Ввод-вывод данных системы, прием управляющих команд и отображение результатов их исполнения должны выполняться в интерактивном режиме. Интерфейс должен соответствовать современным эргономическим требованиям и обеспечивать удобный доступ к основным функциям и операциям системы.
Интерфейс должен быть рассчитан на преимущественное использование манипулятора типа «мышь», то есть управление системой должно осуществляться с помощью набора экранных меню, кнопок, значков и т. п. элементов. Клавиатурный режим ввода должен используется главным образом при заполнении и/или редактировании текстовых и числовых полей экранных форм.
Все надписи экранных форм, а также сообщения, выдаваемые пользователю (кроме системных сообщений) должны быть на русском языке.
ИС должна обеспечивать защиту от несанкционированного доступа. Компоненты подсистемы защиты от несанкционированного доступа должны обеспечивать:
идентификацию пользователя;
проверку полномочий пользователя при работе с системой;
разграничение доступа пользователей на уровне задач и информационных массивов.

Требования к функциям (по подсистемам)
Подсистема оперативного учета
Подсистема оперативного учета должна осуществлять ввод и хранение оперативных данных системы, данных для формирования аналитических отчетов, документов системы, сформированных в процессе работы.
Все элементы, входящие в состав подсистемы оперативного учета, должны обладать следующей основной функциональностью:
Постоянное хранение данных;
Добавление новых элементов;
Редактирование элементов;
Удаление (удаление элементов возможно лишь в том случае, если другие существующие объекты системы не ссылаются на удаляемый элемент);
Просмотр элементов;
Просмотр списка элементов;
Фильтрация и сортировка списка элементов;
Поиск элементов;
Экспорт и импорт элементов.
Подсистема бухгалтерского учета
Подсистема бухгалтерского учета должна иметь средства для регистрации бухгалтерских операций и формирования на их основе соответствующей итоговой информации, а также подготовки произвольных бухгалтерских отчетов. Подсистема бухгалтерского учета должна вести учет, ориентированный на первичные документы, относящиеся к подсистеме оперативного учета, и иметь функцию расчета сумм начислений заработной платы сотрудникам на основе этих документов.

Требования к видам обеспечения
К видам обеспечения предъявляются следующие требования:
а) математическому: не предъявляются;
б) информационному: уровень хранения данных в системе должен быть построен на основе современных СУБД. Для обеспечения целостности данных должны использоваться встроенные механизмы СУБД. Доступ к данным должен быть предоставлен только авторизованным пользователям с учетом их служебных полномочий, а также с учетом категории запрашиваемой информации. Технические средства, обеспечивающие хранение информации, должны использовать современные технологии, позволяющие обеспечить повышенную надежность хранения данных и оперативную замену оборудования.
в) лингвистическому: система создана на основе языка программирования «1С 8.1»;
г) программному и техническому:
Компьютер конечного пользователя 
операционная систему: MS Windows 98/XP/Vista/Server 2003/2008;
процессор Intel Pentium II 400 МГц и выше (рекомендуется Intel Pentium III 866 МГц);
оперативная память 128 Мбайт и выше (рекомендуется 256 Мбайт);
жесткий диск (при установке используется около 120 Мбайт).
Компьютер, используемый для разработки конфигураций
операционная система: MS Windows 2000/XP/Vista/Server 2003/2008;
процессор Intel Pentium III 866 МГц и выше (рекомендуется Intel Pentium IV/Celeron 1800 МГц);
оперативная память 256 Мбайт и выше (рекомендуется 512 Мбайт);
жесткий диск (при установке используется около 120 Мбайт).
Компьютер сервера 1С:Предприятия 8.1
операционная система: MS Windows 2000/XP/Vista/Server 2003/2008;
процессор Intel Pentium III 866 МГц и выше (рекомендуется Intel Pentium IV/Xeon 2,4 ГГц, для лучшей масштабируемости рекомендуется два и более процессоров);
оперативная память 512 Мбайт и выше (рекомендуется 1024 Мбайт).
Сервер баз данных
Microsoft SQL Server 2000 + Service Pack 2 (рекомендуется Service Pack 3a) или Microsoft SQL Server 2005.
Компьютер сервера баз данных
операционная система: в соответствии с требованиями Microsoft SQL Server;
технические характеристики компьютера должны соответствовать требованиям используемой версии сервера баз данных MS SQL Server.
д) метрологическому: требования не предъявляются;
е) организационному: для эффективного функционирования системы помимо пользователя необходим специалист по технической поддержке. К работе с системой должны допускаться сотрудники, имеющие навыки работы на персональном компьютере, ознакомленные с правилами эксплуатации и прошедшие обучение работе с системой.
ж) методическому: в состав методического обеспечения системы должны входить: инструкция программисту, инструкция пользователю.

Состав и содержание работ по созданию системы
Перечень стадий и этапов работ, а так же сроки их исполнения представлены в Таблице 2.
Таблица 2.
Этапы и сроки исполнения работ
Работы по созданию системы проводились физическим лицом – студенткой группы ИСЭд-51 УлГТУ, Башаровой И.С. Консультантом при разработке являлась Суркова Е.В., доцент кафедры «Информационные системы» УлГТУ, руководитель дипломного проекта.

Порядок контроля и приемки системы
Приемочные испытания должны включать проверку:
полноты и качества реализации необходимых функций;
выполнения каждого требования, относящегося к эргономике;
работы пользователей в диалоговом режиме;
средств и методов восстановления работоспособности системы после отказов;
полноты действий, доступных пользователю, и их достаточность для функционирования системы;
реакции системы на ошибки пользователя;
тестирование на скорость реакции системы на команды пользователя.

Требования к составу и содержанию работ по подготовке объекта автоматизации к вводу системы в действие
Для подготовки объекта автоматизации к вводу системы в действие необходимо при помощи специалиста технической поддержки, осуществляющего обслуживание используемой в организации базовой конфигурации «Бухгалтерия предприятия», выгрузить все информацию, содержащуюся в этой конфигурации, для дальнейшего ее использования в разработанной системе. Загрузка информации в новую конфигурацию должна так же осуществляться специалистом технической поддержки.
Перед началом использования системы пользователю необходимо ознакомится с руководством пользователя, содержащимся в сопроводительной документации разработанной системы и пройти обучение для ознакомления с принципами ее функционирования в течение 1 академического часа (при условии владения пользователя навыками работы в базовой конфигурации «Бухгалтерия предприятия» платформы «1С: Предприятие 8.1»). 

Требования к документированию
Разработке подлежит следующая документация:
Инструкция пользователю;
Инструкция программисту.
",0
19,tz_02.docx,"2.2 Техническое задание
2.2.1 Общие сведения
Полное наименование системы:   «Автоматизированное рабочее место  продавца-консультанта  в салоне  фотоуслуг» в среде «1С: Предприятие 8.1».
Шифр темы: ДП–УлГТУ– 08080165–05/0978–2010.
Наименование предприятия заказчика системы, его реквизиты: ООО «УмКо», г.Ульяновск;
Плановые сроки начала и окончания работ: 1 апреля 2009 года — 15 июня 2009 года;
Сведения об источниках и порядке финансирования работ: данные работы проводятся на безвозмездной основе;
Порядок оформления и предъявления заказчику результатов работ по созданию системы, ее частей и отдельных средств: по окончанию работ заказчику должны быть предъявлены и переданы все необходимые дистрибутивы, набор инструкций и документации.

2.2.2 Назначение и цели создания системы
Разработанная система предназначена для автоматизации работы продавца-консультанта салона фотоуслуг по принятию заказов и выполнению различного рода операций над ними, ведению учета принятых, выполненных и выданных заказов.
Целью создания системы является повышение скорости и качества работы продавца-консультанта, упрощение выполнения им ряда операций, повышение качества обслуживания клиентов за счет актуальности и достоверности хранимой информации по заказам.     

2.2.3 Характеристика объектов автоматизации
Объектом автоматизации является торговый зал салона фотоуслуг, в котором осуществляется продажа фототоваров и реализация услуг.

2.2.3.1 Требования к системе в целом 
Требования к структуре и функционированию системы
Программный продукт должен представлять собой единую систему, без разделения на подсистемы. Система должна функционировать в монопольном режиме.
Требования к персоналу
Для работы с программой пользователи должны обладать навыками работы  на ПЭВМ под управлением операционной системы семейства Windows. Кроме того, пользователи должны обладать знанием предметной области, связанной с оказанием фотоуслуг, а также  иметь представление о работе продавца-консультанта, выполняемых им операциях.    
Требования к надежности
Программный продукт должен отслеживать ошибки в работе программы, возникающие при некорректном вводе информации и других ошибочных действий пользователя, обеспечивать максимально возможное сохранение данных и реагировать специальными сообщениями для оповещения пользователя о его некорректных действиях.
Необходимо использование лицензионной копии программы «1С: Предприятие».
Требования к эргономике и технической эстетике
Разрабатываемая система должна обладать удобным, простым, интуитивно понятным интерфейсом. 
Требования к защите информации от несанкционированного доступа
В системе должна быть реализована аутентификация пользователей. Необходимо реализовать хранение данных пользователей и их паролей. Также необходима регулярная смена паролей.  

2.2.3.2 Требования к функциям
Перечень подлежащих автоматизации задач
Разрабатываемая система должна поддерживать выполнение следующих задач:
ведение учета заказов на всех стадиях их жизненного цикла: прием, выполнение, оплата, выдача;
оформление и регистрация нового заказа;
регистрация полного и частичного выполнения заказа;
регистрация оплаты заказа;
регистрация выдачи заказа;
обмен данными между центральным подразделением и филиалами;
формирование отчетов:
по принятым, но невыполненным заказам;
по выполненным, но невыданным заказам;
по выданным заказам;
по выработке сотрудников;
по оплатам;
по сертификатам.

2.2.3.3 Требования к видам обеспечения
Требования к техническому обеспечению
В состав технических средств должен входить IBM-совместимый персональный компьютер (ПЭВМ), включающий в себя:
процессор – не менее Pentium, 2.0 Hz ;
ОЗУ – не менее 216 Мб;
операционная система – Windows 2000, XP, Vista.
Требования к программному обеспечению
Для функционирования разрабатываемой системы необходимо наличие:
операционной системы MS Windows 98/Me/2000/XP;
1С: Предприятие 8.1.
Требования к лингвистическому обеспечению
При создании программного продукта необходимо использовать язык программирования «1С v8.1».
Требования к методическому обеспечению
Необходимо наличие следующей нормативно-технической документации:
инструкция программисту; 
инструкция пользователю.

2.2.4 Перечень этапов работ и сроки исполнения
Этапы и сроки проведения работ приведены в таблице 1.

Таблица 1
Этапы и сроки выполнения работ

2.2.5 Состав исполнителей работ
Работы по созданию системы проводятся физическим лицом, Гайдуковой Марией Николаевной, студенткой УлГТУ.
При этом консультантом выступает руководитель дипломного проекта Суркова Елена Викторовна.

2.2.6 Требования к составу и содержанию работ по подготовке объекта автоматизации к вводу системы в действие
В рамках подготовки объекта автоматизации к вводу системы  необходимо заполнить следующие справочники  для получения актуальной информации и возможности работы с системой:
справочник Подразделения;
справочник Номенклатура;
справочник Клиенты;
справочник Вид услуги;
справочник Скидка;
справочник Пользователи.
Кроме того, необходимо настроить план обмена «Основной». Для этого нужно заполнить данные текущего узла, а также тех узлов, с которыми он будет производить обмен данными. Необходимо указать узел, который будет считаться Центральным, так как обмен производится в следующих направлениях:
выгрузка данных производится со всех узлов, кроме Центрального;
загрузка данных производится только центральным узлом. 

2.2.7  Требования к документированию
Необходимо наличие следующих документов: 
инструкция пользователю;
инструкция программисту.",0
28,tz_03.docx,"2.2. Техническое задание
Общие сведения:
В данной главе представлены общие сведения о системе:
полное наименование системы и ее условное обозначение:
Web-ориентированная автоматизированная система учета услуг туристической фирмы;
шифр темы или шифр (номер) договора: данный программный продукт разрабатывался в рамках дипломного проектирования, какой-либо договор не заключался; 
наименование предприятий разработчика и заказчика системы, их реквизиты:
предприятие-разработчик: ООО «Волгасофт» (ИНН/КПП 7325082859/73251001, г.Ульяновск, ул.Брестская, 78);
предприятие-заказчик: ООО «Goodline» (ИНН/КПП 6313535100/631301001, г.Самара, МОСКОВСКОЕ ШОССЕ,81а);
перечень документов, на основании которых создается информационная база: спецпредложения туроператора.
плановые сроки начала и окончания работ:
начало работы: 1 марта 2010 года;
окончание работы: 31 мая 2010 года;
сведения об источниках и порядке финансирования работ: данные работы проводятся на безвозмездной основе;
порядок оформления и предъявления заказчику результатов работ по созданию системы, ее частей и отдельных средств: по окончанию работ заказчику должны быть предъявлены и переданы установочный диск со всеми необходимыми дистрибутивами, набор инструкций и документации для полноценного функционирования указанной системы.

Назначение и цели создания системы
вид автоматизируемой деятельности.
Разработанная система предназначена для автоматизации бронирования туров, учета клиентов, ведения базы данных туров.
перечень объектов, на которых предполагается использование системы. 
Данную систему предполагается использовать в  ООО «Goodline».
наименование и требуемые значения технических, технологических, производственно-экономических и др. показателей объекта, которые должны быть достигнуты при внедрении ИС.
 При внедрении ИС должны быть достигнуты следующие цели: 
с технологической точки зрения: должен быть упрощен процесс взаимодействия турагента с клиентами, улучшено качество работы с клиентом;
с производственно-экономической точки зрения: должно быть сокращено время на организацию работы с клиентами и формирование соответствующей отчетности.

Характеристика объектов автоматизации
Объектом автоматизации является ООО «Goodline». Это предприятие специализируется в области предоставления туристических услуг. В фирме существуют разные типы туров: горнолыжные, отдых на море, лечебные и др. Осуществляются поездки по различным направлениям.
В своей работе ООО «Goodline» использует только зарекомендовавшие себя в российских условиях туроператоры, таких как Coral Travel, Pegas Touristic, Ingtour. Профессиональные и доброжелательные сотрудники, оказывают внимание каждому клиенту. Фирма предлагает идеальное соотношение цены и качества. В программы включено максимальное количество оригинальных экскурсий. Большой выбор отелей и апартаментов любой категории по конкурентоспособным ценам. Турфирма предлагает гибкую систему скидок клиентам. Оплата услуг осуществляется в любой удобной для клиента форме – наличный и безналичный расчет
Политика организации нацелена на обслуживание клиентов по популярным направлениям а также принятие заказов на индивидуальные туры.

Требования к системе
Требования к системе в целом
Требования к структуре и функционированию системы
Разработанная система должна состоять из следующих подсистем:
планирование работы с клиентами;
анализ сбытовой деятельности.
Первая подсистема должна предоставить турагенту возможность спланировать своевременное взаимодействие с клиентом с тем, чтобы ни один клиент не оказался «забытым».
Вторая подсистема должна подсчитывать и наглядно представлять экономический результат деятельности, сбыт товаров и услуг.
Требования к персоналу
Число человек, работающих с системой, неограниченно. Оно определяется количеством турагентов в организации. Кроме того, необходим системный администратор.
Системный администратор должен обладать знаниями по настройке веб-сервера, а также выполнять соответствующую настройку и поддержку.
Турагент должен иметь соответственно квалификацию турагента и быть уверенным пользователем интернет и обладать навыками работы с браузерами.
Степень приспособляемости системы
Данная система должна быть гибкой в отношении изменения отчетов, должна обеспечивать настройку их параметров.
Требования к надежности, безопасности, эргономике, транспортабельности, эксплуатации, техническому обслуживанию и ремонту, защите и сохранности информации, защите от внешних воздействий, к патентной чистоте, по стандартизации и унификации.
Система должна быть надежной, т.е. отказоустойчивой к ошибкам пользователя (нарушения правильной последовательности действий).
Она должна быть удобна для работы пользователя. 
	Должна быть предусмотрена возможность обслуживания системы, в том числе и сторонними разработчиками.
	Должна присутствовать авторизация и аутентификация пользователя, возможность тонкой настройки доступа к объектам и функциям системы. 
Программный продукт должен быть патентно чист и иметь возможность законно использоваться в коммерческих целях. Разрабатываемый программный продукт является патентно-чистым. Для функционирования системы необходима покупка либо аренда веб-сервера.

2.2.4.2 Требования к функциям (по подсистемам)
Перечень подлежащих автоматизации задач:
бронирование тура;
голосование;
обратная связь;
хранение базы клиентов;
хранение и обновление базы туров;
удобный интерфейс;
дружественный дизайн;
туристический форум;
передача ссылки;
новости.
Временной регламент реализации каждой функции.
Реализация всех функций должна быть выполнена согласно с этапами и сроками выполнения работ.
Требования к качеству реализации каждой функции, к форме представления выходной информации, характеристики точности, достоверности выдачи результатов.
Перечень и критерии отказов.

2.2.4.3 Требования к видам обеспечения
Система предъявляет следующие требования к видам обеспечения:
а) математическому: пользователь должен быть знаком с методикой проведения горизонтального (временного) анализа, вертикального (структурного) анализа;
б) информационному: Denwer 3 (Apache, PHP, MySQL) – набор дистрибутивов (Apache, PHP, MySQL, Perl и т.д.) и программная оболочка, используемые Web-разработчиками для разработки сайтов на «домашней» (локальной) Windows-машине без необходимости выхода в Интернет. Главная особенность Денвера — удобство при удаленной работе сразу над несколькими независимыми проектами и возможность размещения на Flash-накопителе.;
в) лингвистическому: используется язык программирования «PHP» и Java-script;
г) программному и техническому: 
 1) компьютер конечного пользователя (рекомендуемые параметры): 
операционная система: MS Windows 2000/ XP / Server 2003; 
процессор Intel Pentium III 866 МГц; 
оперативная память 256 Мбайт; 
2) компьютер, используемый для разработки конфигураций: 
операционная система: MS Windows 2000/ XP / Server 2003; 
Intel Pentium IV/Celeron 1800  МГц ; 
оперативная память 512 Мбайт; 
3) сервер ПП: 
операционная система: MS Windows 2000/Server 2003, ОС семейства UNIX; 
процессор Intel Pentium IV/Xeon 2,4 ГГц, рекомендуется два и более процессоров; 
оперативная память 1024 Мбайт; 
4) сервер баз данных: 
технические характеристики компьютера и операционная система должны соответствовать требованиям Microsoft SQL Server 2005, MYSQL Server; 
д) организационному: для функционирования системы необходимы системный администратор и несколько менеджеров;
е) методическому (состав нормативно-технической документации):
инструкция программисту; 
инструкция пользователю.

Состав и содержание работ по созданию системы
Перечень этапов работ и сроки исполнения
Перечень этапов работ и сроки исполнения представлены в таблице 2.1
Таблица 2.1 
Основные этапы работ и сроки их исполнения

Состав исполнителей работ
Работы по созданию системы проводились физическим лицом – Гимадиевой Ч.Р., студенткой УлГТУ, под руководством преподавателя кафедры «Информационные системы» Наместникова Алексея Михайловича.

2.2.6 Требования к программной документации
Техническое задание
Экономическая часть
Инструкция пользователя  ГОСТ 19.505-79 ""РУКОВОДСТВО ОПЕРАТОРА. ТРЕБОВАНИЯ К СОДЕРЖАНИЮ И ОФОРМЛЕНИЮ""
Инструкция программиста ГОСТ 19.503-79 ""РУКОВОДСТВО СИСТЕМНОГО ПРОГРАММИСТА. ТРЕБОВАНИЯ К СОДЕРЖАНИЮ И ОФОРМЛЕНИЮ"" и ГОСТ 19.504-79 ""РУКОВОДСТВО ПРОГРАММИСТА. ТРЕБОВАНИЯ К СОДЕРЖАНИЮ И ОФОРМЛЕНИЮ""
Пояснительная записка",0
35,tz_04.docx,"Техническое задание
2.2.1 Общие сведения
Интернет-магазин ООО «Практика» разработан для осуществления торгоаой деятельности через Интернет. Данный продукт разработала Громакова Елена для ООО «Практика». Плановый срок начала работ — февраль 2010 года, окончание работ — июнь 2010 года. Данный программный родукт выполняется безвозмездно. 

2.2.2 Назначение и цели создания системы
Интернет-магазин ООО «Практика» разрабатывается для 
осуществления оптовой и розничной реализации товаров через Интернет. 
Основными элементами прикладного решения являются:
Оформление заказа;
Оповещение покупателя об успешном совершении заказа;
Оповещение продавца о новом заказе.
Данный интернет-магазин разрабатывается для удобства поупателей, чтобы они могли наглядно ознакомиться с предлагаемой продукцией. А также для удобства менеджеров которые будут обрабатывать эти заказы, т.к. намного проще обработать готовый заказ, чем вначале записать на листок, затем перенести эти данные в базу, после чего согласовать счет. В интернет-магазине покупатель самостоятельно будет формировать свой заказ, где будет видеть цены и итоговую сумму.

2.2.3 Характеристика объектов автоматизации
Интернет-магазин – это магазин, «витрина» которого расположена в интернете и который дает возможность заказывать товар через интернет. 
На сайте магазина представлен подробный каталог товаров с ценами, на основе которого пользователь формирует свой заказ. Заказывая товары в интернет-магазине, покупатель может получать их с курьером, а расплачиваться наличным или безналичным расчетом.
Преимущества которые дает интернет-магазин:
Интернет-магазин работает 24 часа в сутки, 365 дней в году, без перерыва на обед, без выходных и праздничных дней.
Доступ к виртуальной витрине магазина может получить любой покупатель.
Интернет-магазин не имеет ограничений на виртуальную площадь. Можно разместить сколь угодно товаров.
Срок и стоимость создания интернет-магазина несоизмеримо ниже, чем обычного магазина.
Для создания интернет-магазина не требуется получения многочисленных разрешений и лицензий. Его не проверяет пожарный инспектор, санэпидемстанция и другие службы.
Интернет-магазины — это наше недалекое будущее. В городах миллионниках они пользуются большим спросом. Кажется что их уже достаточно много, но перенасыщенности в этой сфере пока нет. Содержать интернет-магазин намного выгоднее чем его аналог. За него не нужно платить арендную плату или зарплату продавцам. Он прост и удобен в применении. Экспуатировать его так же легко. Все что для этого нужно — это подключение к сети Интернет.

2.2.4 Требования к системе
Требования к системе в целом:
- удобный интерфейс, рассчитанный на неопытного пользователя;
- возможность быстрого поиска как по наименованию товара, так и по его характеристикам;
- возможность ввода и хранения данных неограниченного числа зарегистрированных пользователей;
- защита от ошибок пользователей (не заполнение всех необходимы полей при регистрации пользователя или при оформлении заказа);
- воозможность необходимых настроек системы.
Требования к составу функций:
Все пользователи, работающие с программой могут иметь разные права. В пользовательском режиме это может быть, например, группа «оптовики» (их преимущество в том, что когда они зайдут на сайт под своим пролем - получат 5% скидку на весь товар). В режиме администратора также может быть несколько пользователей. Наделяет пользователей правами главный администратор. 
Главный администратор может:
1. Добавлять и удалять любую информацию на сайте (новости, товар, описание продукции, баннеры и т.д.);
2. Изменять внешний вид сайта;
3. Наделять правами пользователей.
Требования к  инструментальным средствам
Для разработки программного продукта использовать систему управления сайтом (CMS) Joomla 1.5 и расширение Virtuemart 1.1. Если разработка осуществляется на локальном компьютере, то необходимо использовать Денвер. Денвер — набор дистрибутивов и программная оболочка, предназначенный для создания и отладки сайтов на локальной Windows-машине, без подключения к сети Интернет. 
Требования к системному ПО и техническому обеспечению
Программный продукт ориентирован на работу под управлением операционной системы Windows: 98, 2000, XP, Vista, 7, CPU 1 Ghz, 256 Мб оперативной памяти, подключение к интернет.
Требования к  интерфейсу
Программный продукт должен быть ориентирован на неподготовленного пользователя ЭВМ, имеющего начальные навыки работы с ОС Windows и Internet. Общение с компьютером должно осуществляться на основе графического оконного интерфейса в виде меню, списков, кнопок, полей ввода данных. 
Перечень этапов работ и сроки исполнения 
Перечень этапов работ и сроки исполнения представлены в таблице 2.1
             Таблица 2.1 Перечень этапов работ и сроки исполнения.",0
38,tz_05.docx,"2.2 Техническое задание
2.2.1 Общие сведения.
1) полное наименование системы и ее условное обозначение: АРМ сотрудника организационно-методического кабинета МУЗ «Сенгилеевская ЦРБ»;
2) шифр темы или шифр (номер договора): данный программный продукт разрабатывался вне рамок какого-либо договора;
3) наименование предприятий разработчика и заказчика системы, их реквизиты: МУЗ «Сенгилеевская ЦРБ», . Сенгилей, ул. Н. Выборная, 8.;
4) перечень документов, на основании которых создается информационная система:
1.Приказ Минздрава РФ от 30 декабря . N 413 «Об утверждении учетной и отчетной медицинской документации»
2. Распоряжение Минздрава Ульяновской области РФ от 15 декабря . №512 «О проведении временной оперативной отчетности о деятельности учреждений здравоохранения»
5) плановые сроки начала и окончания работ: 29 марта 2010 года – 7 мая 2010 года;
6) сведения об источниках и порядке финансирования работ: данные работы проводятся на некоммерческой основе;
7) порядок оформления и предъявления заказчику результатов работ по созданию системы, ее частей и отдельных средств: по окончанию работ заказчику должны быть предъявлены и переданы установочный диск со всеми необходимыми дистрибутивами, набор инструкций и документации для полноценного функционирования системы.
 
2.2.2 Назначение и цели создания системы
Разработанная система призвана автоматизировать процессы организационно-методического кабинета. Данная система предназначена для использования в ОМК МУЗ «Сенгилеевская ЦРБ», а также в организационно-методических кабинетах других лечебно-профилактических учреждений. После доработок продукта предполагается возможность его внедрения и использования.
При внедрении данной системы должны быть следующие показатели:
технические: показателей нет;
технологические: уменьшение числа этапов выполнения расчетов численных показателей при подготовке отчетной информации;
производственно-экономические: сокращение времени на расчеты при подготовке отчетной информации, повышение производительности работы организационно-методического кабинета.

2.2.3 Характеристика объектов автоматизации
	Объектом автоматизации является Организационно-методический кабинет МУЗ «Сенгилеевская центральная районная больница».
	Основные: учет первичной медицинской документации (талон амбулаторного пациента, карта выбывшего из стационара)
	Вспомогательные: вывод отчетов на экран.

2.2.4 Требования к системе в целом
2.1.4.1 Требования к структуре и функционированию системы
	Система должна обеспечивать выполнение перечисленных ниже функций:
		- добавление новой учетной медицинской документации;
- редактирование и удаление существующей учетной медицинской документации;
- формирование отчетной медицинской документации

2.2.4.2 Требования к персоналу
	Для функционирования системы необходим сотрудник организационно-методического кабинета. Он должен обладать знаниями в области статистического учета медицинской информации, а так же навыками заполнения учетной медицинской документации и работы с программой на базе платформы 1С:Предприятие 8.1.

2.2.4.3 Степень приспособляемости системы
	Система должна легко дорабатываться для добавления новых или изменения имеющихся функций.

2.2.4.4 Требования к надежности
	Надежность и отказоустойчивость системы к ошибкам пользователей и ошибкам загружаемых данных обеспечивают внутренние средства 1С.
	Интерфейс системы должен быть эргономичным с точки зрения пользователя. Интерфейсы программных продуктов на базе «1С:Предприятие 8.1» ориентированы на удобную работу и простоту освоения.
	Система должна обладать патентной чистотой. Это предполагает использование программы на лицензионных копиях программ «1С:Предприятие».
	Должен быть предусмотрен режим раздельной работы с конфигурацией нескольких пользователей. Для этого необходимо, чтобы при входе в конфигурацию присутствовала авторизация и аутентификация пользователей, а значит, каждый пользователь должен иметь свой прописанный в конфигурации набор прав.

2.2.5 Требования к функциям
2.2.5.1 Перечень подлежащих автоматизации задач
	Для системы должны быть реализованы следующие возможности:
Формирование документов (Талон амбулаторного пациента, Карта выбывшего из стационара), а также по скорой помощи и выполненным объемам учреждений;
Введение амбулаторной карты пациента;
Регистрация заболеваний;
Учет врачебного посещения;
Учет движения больных;
Формирование отчетной медицинской документации.

2.2.5.2 Перечень критериев и отказов
	Фатальные ошибки. Сбои в системе, которые приводят к потере ее работоспособности или порче данных.
	Серьезные ошибки. Ошибки, которые не позволяют достичь желаемого результата при использовании некоторого средства или функции программного продукта, включая невозможность исполнения содержащейся в меню или диалоговом окне команды, выполнения процесса или формирования текста.
	Маленькие ошибки. Ошибки, которые вызывают неудобство работы с системой, например, ошибки в задании порядка перехода от одного элемента управления к другому в форме ввода информации. К данному типу ошибок можно отнести также беспричинные сообщения об ошибках.
	Незначительные ошибки. К данному типу ошибок относятся орфографические ошибки в надписях или не выровненные элементы управления.

2.2.6 Требования к видам обеспечения
	Система предъявляет следующие требования к видам обеспечения:
	а) математическому: к пользователю конфигурации не предъявляется особых требований в области математического анализа;
	б) информационному: конфигурация доступна для использования только при установленной платформе 1С:Предприятие 8.1, которая в свою очередь рекомендуется к использованию совместно с операционной системой Windows 98/2000/XP/Vista/7.
	в) лингвистическому: для написания системы конфигурации использовался встроенный язык системы 1С:Предприятие 8.1. Изменением конфигурации рекомендуется заниматься только специалистам, владеющим этим языком.
	г) программному и техническому: для работы с «1С:Предприятием 8.1» рекомендуемая конфигурация компьютера, приведенная «Руководстве по установке и запуску» имеет следующие характеристики:
	1) компьютер конечного пользователя:
		a) операционная система: MS Windows 2000 / XP / Server 2003;
		b) процессор Intel Pentium III 866 МГц;
		c) оперативная память 256 Мбайт;
	2) компьютер, используемый для разработки конфигураций:
		a) операционная система: MS Windows 2000 / XP / Server 2003;
		b) процессор Intel Pentium IV/Celeron 1800 МГц;
		c) оперативная память 512 Мбайт;
	3) сервер «1С:Предприятие 8.0»:
		a) операционная система: MS Windows 2000 / XP / Server 2003;
		b) процессор Intel Pentium IV/Xeon 2,4 ГГц;
		c) оперативная память 1024 Мбайт;
	Из программных средств необходимы: платформа «1С:Предприятие 8.1».
	д) метрологическому: нет требований к данному виду обеспечения.
	е) организационному: при работе с конфигурацией сразу нескольких пользователей существует требование каждому пользователю входить в информационную базу только со своими правами.
	ж) методическому (состав нормативно-технической документации):
		a) инструкция программисту;
		b) инструкция пользователю;
		c) презентация программного продукта.

2.2.7 Перечень этапов работ и сроки исполнения

2.2.8 Состав исполнителей работ
Работы по созданию системы проводились физическим лицом, Давыдовым Денисом Васильевичем студентом УлГТУ. При этом консультантами выступали:
	а) Меркулова Тамара Алексеевна – УлГТУ, доцент кафедры «Информационные системы», руководитель дипломного проекта.
	б) Давыдова Ольга Николаевна – заведующий организационно-методическим кабинетом МУЗ «Сенгилеевская ЦРБ».

2.2.9 Порядок контроля системы
Для контроля необходимо провести следующие виды тестирования:
	Функциональное тестирование. Оно включает проверку каждой команды меню, панели инструментов и каждой операции, которую выполняет система.
	Тестирование приложения. При выполнении тестирования приложения испытатель моделирует действия пользователя. Воспроизводя различные комбинации действий, можно найти ошибки, относящиеся к интеграции компонентов, а также недоработки, которые не были обнаружены при функциональном тестировании.
	Тестирование на скорость выполнения. Измеряется время отклика системы на некоторое действие, документа. Обычно при этом определяются параметры эффективности. Одновременно с измерением времени на выполнение запроса записать также размер базы данных.
	Все этапы тестирования программы проводились непосредственным разработчиком Давыдовым Денисом Васильевичем.

2.2.10 Требования к составу и содержанию работ по подготовке объекта автоматизации к вводу системы в действие
Для ввода системы в эксплуатацию необходимо провести обучение персонала с программой с использованием всех ее возможностей: сотрудника организационно-методического кабинета – 2 академических часа.
	Необходимо заполнить во внедряемой системе справочники.

2.2.11 Перечень подлежащих разработке документов
	- инструкция пользователю;
	- инструкция администратору;
	- презентация программного продукта.",0
2,tz_06.docx,"2.2 Техническое задание	
1.Общие сведения
Полное наименование системы: Станция технического обслуживания автомобилей. Условное обозначение – СТО автомобилей.
Шифр темы или шифр (номер) договора: данный программный продукт разрабатывался в рамках выполнения должностных обязанностей в компании-заказчике.
 Наименование предприятий разработчика и заказчика системы, их реквизиты: ООО «АвтоРай» (432026 Ульяновск, ул. Московское шоссе, 17а).
Перечень документов, на основании которых создается информационная система: основанием для разработки системы является  необходимость ведения автоматизированного контроля  и учета деятельности на станции технического обслуживания  в организации-заказчике. 
Плановые сроки начала и окончания работ работ:
Начало работ – февраль .
Окончание работ – июнь .
Сведения об источниках и порядке финансирования работ: источником финансирования является ежемесячная зарплата. Результаты работы предъявляются по мере выполнения отдельных функциональных блоков.
Порядок оформления и предъявления заказчику результатов работ по созданию системы, ее частей и отдельных средств : результаты работы внедряются в типовую конфигурацию по мере разработки отдельных функциональных блоков.

2. Назначение и цели создания системы
2.1 Назначение системы:  предоставление удобных механизмов для работы с клиентами на станции технического обслуживания. 
2.2 Цели создания системы: 
автоматизация работы станции технического обслуживания;
предоставление удобных механизмов для работы мастеров-приемщиков и оформителей на станции;
Возможность получения точной информации о работе станции, расчет прибыли (убытков) от работы станции.

3. Характеристики объекта автоматизации
3.1  Объект автоматизации: объектом автоматизации в данной системе являются заявки, поступающие на СТО, документы и договора, составляющиеся в ходе работы с клиентами, а также дополнительные документы, создаваемые в процессе работы на станции. Информация о заявках на обслуживание, договорах, актах и прочие документы заносится и обрабатывается в данной автоматизированной системе.
3.2 Условия эксплуатации: ограничиваются только правилами эксплуатации вычислительной техники. К окружающей среде особых требований не предъявляется.

4.  Требования к системе
4.1 Требования к системе в целом
4.1.1 Требования к структуре и функционированию системы
Перечень подсистем:
Оформление документов
Работа с клиентами
Отчетность
Подсистема оформления документов должна представлять собой совокупность документов, оформляемых в процессе работы по каждой заявке, начиная документом записи на ремонт и заканчивая документами реализации.
Блок работы с клиентами должен включать в себя обработки по формированию списков клиентов для обзвона, сбора и обработки полученных результатов анкетирования.
Блок отчетов должен содержать отчеты, необходимые для анализа работы станции  и для предоставления сводной информации руководству. 
Система  должна иметь два режима работы: 
- конфигурирование
- пользовательский режим.

4.1.2 Требования к персоналу 
Пользователями разрабатываемой системы должны выступать:
Оформители 
Мастер-приемщик
Менеджер по работе с персоналом
Начальник СТО
Кладовщик
Предоставляемые требования к ним — обладание навыками работы в системе 1С 8.1.
Количество пользователей, одновременно работающих в системе, ограничено только ресурсами сети.

4.1.3 Показатели назначения 
Данная система должна быть гибкой в отношении изменения отчетов  и легко модернизироваться под изменяющиеся нужды станции технического обслуживания. 

4.1.4 Требования к надежности, безопасности, эксплуатации и техническому обслуживанию
4.1.4.1 Требования по обеспечению надежности системы
бесперебойное питание технических средств;
использование лицензионного программного обеспечения;
соблюдение рекомендаций по условиям эксплуатации данной системы;
доступ к системе только квалифицированных специалистов.

4.1.4.2 Спецификации по безопасности  информации
 - С целью избежания несанкционированного доступа к документам, справочникам и отчетам в системе должно быть предусмотрено разграничение прав пользователей в зависимости от занимаемой ими должности (реализовано с помощью ролей, ограничивающих  изменение, добавление или удаление вышеназванных объектов), а также должна быть реализована возможность авторизации пользователей. 
 - С целью обеспечения безопасности в системе должна отсутствовать возможность «физического» удаления объектов, возможна только пометка на удаление.
 - При вводе первичных данных там, где это необходимо, необходимо осуществлять проверку корректности ввода данных.

4.1.4.3 Требования к эксплуатации
Должна быть предусмотрена возможность обновления и обслуживания системы, в том числе и сторонними разработчиками. Возможность доработки программных продуктов на базе платформы «1С: Предприятие 8.1» под конкретного пользователя является их главным преимуществом перед другими системами.

4.2 Требования к функциям, выполняемым системой
4.2.1 Перечень подлежащих автоматизации задач:
Фиксирование заявок на ремонт, поступающих от клиентов.
Учет данных о клиентах (в справочнике «Контрагенты») и о их договорах с организацией (документ «Договор») , о машинах контрагентов, заезжающих на СТО ( справочник «Автомобили»).
Фиксирование наряд-заказов, открывающихся в момент заезда машины на станцию и закрывающихся после выполнения всех работ.
Функционирование механизма обзвона клиентов.
Контроль списания запасных частей со склада под конкретный наряд-заказ
Формирование отчетности по работе станции.

4.2.2 Перечень критериев и отказов:
Фатальные ошибки. Сбои в системе, которые приводят к потере ее работоспособности или к порче данных.
Серьезные ошибки. Ошибки, которые не позволяют достичь желаемого результата при использовании некоторого средства или функции программного продукта, включая невозможность исполнения содержащейся в меню или диалоговом окне команды, выполнения процесса или форматирования текста.
Маленькие ошибки. Ошибки, которые вызывают неудобство работы с системой, например, ошибки в задании порядка перехода от одного элемента управления к другому в форме ввода информации. К данному типу ошибок можно отнести также беспричинные сообщения об ошибках.
Незначительные ошибки. К данному типу ошибок относятся орфографические ошибки в надписях или не выровненные элементы управления.

4.3 Требования к видам обеспечения
математическому: особых требований к математическому обеспечению не предъявляется;
информационному:	 реквизиты документов должны соответствовать требованиям, установленным Стандартом предприятия.
лингвистическому: должен использоваться язык программирования «1С v8.1».
программному и техническому: для работы с «1С:Предприятием 8.1» рекомендуемыми являются следующие характеристики: 
1) компьютер конечного пользователя: 
- операционная система: MS Windows 2000/ XP / Server 2003; 
- процессор Intel Pentium III 866 МГц ; 
- оперативная память 256 Мбайт; 
2) компьютер, используемый для разработки конфигураций: 
- операционная система: MS Windows 2000/ XP / Server 2003; 
- процессор Intel Pentium III 866 МГц ; 
- оперативная память 256 Мбайт;    
3) программное обеспечение:
- наличие типовой конфигурации «Управление производственным предприятием».
метрологическому: нет требований к данному виду обеспечения.
организационному:  для функционирования системы необходимо минимум 2 человека: мастер-приемщик, осуществляющий ввод первичных данных в документы «Запись на СТО», «Договор на ремонт», и оформитель, на основании созданных документов создающий документ «Наряд-заказ», документы списания товаров и услуг.  
методическому (состав нормативно-технической документации):
Инструкция программисту; 
Инструкция пользователю.

5. Состав и содержание работ по созданию системы
5.1 Перечень стадий и этапов работ
1. Постановка задачи. На этом этапе   должен быть выполнен этап разработки, согласования и утверждения технического задания к проекту.
2. Проектирование. На стадии проектирования должна быть создана модель разрабатываемой системы (должны быть созданы диаграммы в нотации IDEF  и DFD).
3. Кодирование. Должны быть разработаны все необходимые функциональные блоки в среде 1С 8.1.
4. Тестирование и отладка. На стадии тестирования должна быть осуществлена проверка системы на наличие сбоев и отказов, корректность работы всех функциональных блоков.
5. Анализ результатов.

5.2 Сроки исполнения
Таблица 1

5.3 Состав исполнителей работ
Работы по созданию системы должны проводиться Дюкаревой Ольгой Владимировной, студенткой УлГТУ, инженером-программистом ООО «Авторай».
При этом консультантами выступают:
Меркулова Тамара Алексеевна – УлГТУ, доцент кафедры «Информационные системы», руководитель дипломного проекта.
Орлова Светлана Владимировна – ООО «Авторай», начальник сектора 1С, руководитель преддипломной практики от предприятия.  

6. Порядок контроля и приемки системы
 Виды, состав, объем и методы испытаний системы
Функциональное тестирование. Оно включает проверку каждой команды меню, панели инструментов и каждой операции, которую выполняет система. 
Тестирование приложения. При выполнении тестирования приложения испытатель моделирует действия пользователя. Моделируя различные комбинации действий, можно найти ошибки, относящиеся к интеграции компонентов, а также недоработки, которые не были обнаружены при функциональном тестировании.
Тестирование на скорость выполнения. Измеряется время отклика системы на некоторое действие, документа. Обычно при этом определяются параметры эффективности. Одновременно с измерением времени на выполнение запроса необходимо записать также размер базы данных.
Предельное тестирование. Позволяет определить пропускную способность программного продукта. Запускаются задачи, увеличивая размеры файлов или баз данных, и таким образом выявляют предельное значение объема данных, при котором завершение выполнения задачи невозможно. Максимальный объем данных является существенным ограничением при программировании. 
При тестировании системы были получены следующие результаты
Приемлемое время запуска программы – менее 5 секунд.
Время проведения документа «Наряд-заказ» – 2 секунды.
Время для формирования сводного отчета по услугам и запчастям (за месяц) – 8 секунд.
Время формирования отчета «Отчет СТО по мастерам» (за месяц) – 2 секунды
Фатальные ошибки, приводящие к потере системой работоспособности или порче данных, не обнаружены.
Серьезные ошибки не обнаружены.
Маленькие ошибки не обнаружены.
Незначительных ошибок не обнаружено.

7. Требования к составу и содержанию работ по подготовке объекта автоматизации к вводу системы в действие.
Особых требований не предъявляется, поскольку все подготовки к вводу системы в действие были реализованы на этапе внедрения УПП (приобретение и настройка сервера БД, необходимой компьютерной техники, конфигурация сети и прочее).
7.1 Преобразование входной информации к машиночитаемому виду.
 Дополнительных подгрузок справочной информации не было. Все вновь разработанные объекты конфигурации заполняются данными интерактивно.
 Изменения в объекте автоматизации.
Возможность модификации конфигурации предусмотрена самой платформой.
 Сроки и порядок комплектования и обучения персонала.
   Первоначальное обучение работе в разработанной подсистеме осуществлялось в течение 12 часов. Дальнейшее обучение предполагается только в рамках консультаций.

8. Требования к документированию
8.1 перечень подлежащих разработке документов.
В состав программной документации должны входить следующие документы:
- техническое задание;
- руководство программиста;
- руководство пользователя.

9. Источники разработки
9.1 Источниками разработки являются документы «Стандарт предприятия» для автосалонов ЛАДА, КИА.
",0
4,tz_07.docx,"Техническое задание
Общие сведения
В данном разделе представлены общие сведения о системе:
полное наименование системы и ее условное обозначение:  
«Автоматизация документооборота по заключению договоров» в среде «1С: Предприятие 8.1»;
шифр темы – ДП – УлГТУ – 080801625 – 05/986 – 2010 
наименование предприятия заказчика системы, его реквизиты: ООО «УмКо», г.Ульяновск; 
плановые сроки начала и окончания работ:  29 марта 2010 года — 15 июня 2010 года;
сведения об источниках и порядке финансирования работ: данные работы проводятся на безвозмездной основе;
порядок оформления и предъявления заказчику результатов работ по созданию системы, ее частей и отдельных средств: по окончанию работ заказчику должны быть предъявлены и переданы установочный диск со всеми необходимыми дистрибутивами, набор инструкций и документации для полноценного функционирования системы.

Назначение и цели создания системы
Разработанная система призвана  автоматизировать работу по заключению договор с клиентами и оформлению сопутствующих документов по договору при реализации услуг.

Характеристика объектов автоматизации
Объектом автоматизации является отдел по работе с клиентами, для которого автоматизируется процесс документооборота.

Требования к системе
Требования к системе в целом 
Требования к персоналу
Функционирование программы обеспечивается лицами, обученными работе на ПЭВМ под управлением операционной системы семейства Windows и в программе 1С  на платформе 1С Предприятие 8.1 в конфигурации 1С Бухгалтерия предприятия.
Степень приспособляемости системы
Система должна легко дорабатываться для добавления новых или изменения имеющихся функций. 
Требования к надежности
Надежность и отказоустойчивость системы к ошибкам пользователей и ошибкам загружаемых данных обеспечивают внутренние средства 1С.
Требования к эргономичности
Интерфейс системы должен быть эргономичным с точки зрения пользователя. Интерфейсы программных продуктов на базе «1С: Предприятие 8.1» ориентированы на удобную работу и простоту освоения.
Система должна обладать патентной чистотой. Это предполагает использование программы на лицензионных копиях программ «1С: Предприятие».

Требования к функциям (по подсистемам)
Перечень подлежащих автоматизации задач
С помощью данной системы требуется решать следующие задачи:
заключение договоров с клиентом
оформление документа «Реализация товаров, услуг»
оформление документа «Установка цен и услуг»
оформление «Счетов-фактур» к документам «Реализация услуг»
оформление «Счетов» по документам «Реализация услуг» 
Требования к качеству реализации каждой функции
Система должна запрашивать подтверждение пользователя на разрешение всех существенных изменений в системе. 
Перечень критериев и отказов
Фатальные ошибки. Сбои в системе, которые приводят к потере ее работоспособности или к порче данных.
Серьезные ошибки. Ошибки, которые не позволяют достичь желаемого результата при использовании некоторого средства или функции программного продукта, включая невозможность исполнения содержащейся в меню или диалоговом окне команды, выполнения процесса или форматирования текста.
Маленькие ошибки. Ошибки, которые вызывают неудобство работы с системой, например, ошибки в задании порядка перехода от одного элемента управления к другому в форме ввода информации. К данному типу ошибок можно отнести также беспричинные сообщения об ошибках.
Незначительные ошибки. К данному типу ошибок относятся орфографические ошибки в надписях или не выровненные элементы управления.

Требования к видам обеспечения
Система предъявляет следующие требования к видам обеспечения:
1) математическому: нет требований;
2) информационному: необходимо знать процесс документооборота в фирмах, занимающихся 1С Франчайзингом.
3) лингвистическому: используется язык программирование «1С v8.1».
4) программному и техническому: 
Для работы с «1С: Предприятием 8.1» рекомендуемая конфигурация компьютера, имеет следующие характеристики: 
а) компьютер конечного пользователя: 
операционная система: MS Windows 2000/ XP / Vista ; 
процессор Intel Pentium III 866 МГц; 
оперативная память  не менее 256 Мбайт; 
б) компьютер, используемый для разработки конфигураций: 
операционная система: Microsoft Windows XP ; 
Intel Pentium IV 3.00 ГГц; 
оперативная память 512 Мбайт; 
5) метрологическому: нет требований к данному виду обеспечения.
6) организационному:  для функционирования системы необходим один человек, отвечающий за документооборот по работе с клиентами. 
7) методическому (состав нормативно-технической документации):
Инструкция программисту; 
Инструкция пользователю.

Состав и содержание работ по созданию системы
Перечень этапов работ и сроки исполнения
Этапы и сроки проведения работ приведены в таблице 1.

                                                                             Таблица 1
Этапы и сроки выполнения работ

Состав исполнителей работ
Работы по созданию системы проводились физическим лицом, Жарковой Натальей Владимировной студенткой УлГТУ.
При этом консультантом выступала Суркова Елена Викторовна – УлГТУ.

 Порядок контроля и приемки системы
Для контроля необходимо провести следующие виды тестирования:
Функциональное тестирование. Оно включает проверку каждой команды меню, панели инструментов и каждой операции, которую выполняет система. 
Тестирование приложения. При выполнении тестирования приложения испытатель моделирует действия пользователя. Воспроизводя различные комбинации действий, можно найти ошибки, относящиеся к интеграции компонентов, а также недоработки, которые не были обнаружены при функциональном тестировании.
Тестирование на скорость выполнения. Измеряется время отклика системы на некоторое действие, документа. Обычно при этом определяются параметры эффективности. Одновременно с измерением времени на выполнение запроса необходимо записать также размер базы данных.
Все этапы тестирования программы должны проводиться непосредственным разработчиком Жарковой Натальей Владимировной.

 Требования к составу и содержанию работ по подготовке объекта автоматизации к вводу системы в действие
Для ввода системы в эксплуатацию необходимо правильно (актуальной информацией) заполнить справочники: 
Контрагенты (папка Клиенты);
Номенклатура (папка Программные продукты фирмы 1С, Виды услуг, Услуги абонентского обслуживания 1С);
Тарифный план;
Валюты;
Банки;
Классификатор единиц измерения;
Организации.
Необходимо настроить учетную политику предприятия. Необходимо обучить персонал работе с новой системой документооборота.

 Требования к документированию: 
Инструкция пользователю
Инструкция программисту",0
33,tz_08.docx,"Техническое задание
1 Общие сведения
1.1 Полное наименование: Автоматизированная информационная система «Управление финансово-хозяйственной деятельностью товарищества собственников жилья (ТСЖ)».
1.2 Условное обозначение: АИС «Товарищество собственников жилья».
1.3 Информация о Заказчике и Исполнителе:
Заказчик: ТИВК «Труд»
ИНН/КПП 7328018562/732801001
Адрес: . Ульяновск, ул. Тельмана, 3
ОГРН 1027301584815
Исполнитель: Фомин Александр Сергеевич
ИНН 732815886103
Адрес: . Ульяновск, ул. 40 лет Октября 15/20, 25
1.4 Основания для разработки: 
Программный продукт разрабатывается по заказу ТИВК «Труд» в лице главного бухгалтера Тиминой А.С., а также на основе имеющейся проектной документации на часть программного продукта. Программный продукт является развитием прототипа в форме подсистемы управления жилищно-коммунальным хозяйством.
1.5 Плановые сроки начала и окончания разработки – 1 полугодие .
1.6 Результаты разработки оформляются соответствующей документацией и предъявляются Заказчику в составе:
- отлаженный программный продукт с тестовым набором данных, демонстрирующим функционирование прикладного решения (демо-версия);
- отлаженный программный продукт с пустой информационной базой, готовый для эксплуатации заказчиком;
- руководство по эксплуатации прикладного решения.
Исполнитель при необходимости обязуется произвести установку и настройку соответствующего программного обеспечения на автоматизированном рабочем месте Заказчика.

2 Назначение и цели создания системы
2.1 Вид автоматизируемой деятельности и объект автоматизации
Объектом автоматизации выступает юридическое лицо с организационно-правовой формой товарищества собственников жилья. Вид автоматизируемой деятельности – управление финансово-хозяйственной деятельностью хозяйствующего субъекта.

2.2 Цели создания системы
- организация эффективной системы сбора, хранения, обработки и анализа данных о хозяйственной деятельности товарищества;
- переход на форму бухгалтерского учета с использованием системы счетов;
- сокращение времени на подготовку отчетности;
- минимизация рутинных операций;
- достижение своевременного обеспечения необходимой информацией соответствующих заинтересованных лиц;
- увеличение скорости и качества расчетных операций.

3 Характеристики объекта автоматизации
3.1 Объект автоматизации: некоммерческая организация – товарищество собственников жилья. Общие сведения об объекте автоматизации и особенностях его деятельности представлены в Жилищном кодексе РФ от 01.03.2005 года (разделы VI-VIII). Финансово-хозяйственная деятельность ТСЖ регламентируется общепринятыми законодательными актами (положения по БУ, НК РФ, письма Минфина РФ, Госстроя и т.д.)
3.2 В настоящее время информационные системы в организации не эксплуатируются. Для формирования и сдачи некоторых видов отчетности применяются официально выпущенные программные средства.

4 Требования к системе
4.1 Требования к системе в целом
4.1.1 Требования к структуре и функционированию системы
4.1.1.1 Информационная система предназначена для работы одного пользователя и логически состоит из нескольких взаимосвязанных подсистем:
- подсистема управления жилищно-коммунальным хозяйством;
- подсистема бухгалтерского учета;
- подсистема кадрового учета и зарплаты;
- подсистема налогового учета и отчетности.
Подсистемы не являются самостоятельными программными продуктами и не могут функционировать локально, так как деление на подсистемы условно и лишь отражает направления финансово-хозяйственной деятельности ТСЖ.
4.1.1.2 Компоненты системы и их взаимосвязь
Физически информационная система представляет собой интеграцию двух программных продуктов, между которыми организуется обмен данными посредством технологии OLE Automation.
Физические компоненты информационной системы:
- конфигурация «ТСЖ» (основная), содержащая специфический функционал;
- типовая конфигурация «Бухгалтерия предприятия 8», автоматизирующая общепринятые процессы хозяйствующего субъекта.
4.1.1.3 Система должна работать в двух режимах:
- пользовательский режим с доступными функциями системы;
- режим конфигурирования.
Кроме того, прикладное решение должно иметь возможность функционировать как в файловом, так и по необходимости в клиент-серверном варианте.
4.1.1.4 Разрабатываемая информационная система представляет собой законченный программный продукт для автоматизации деятельности по управлению ТСЖ, и при необходимости может быть развита путем доработки ее функционала в соответствии с новыми требованиями и выпуском новых версий.

4.1.2 Требования к численности и квалификации персонала системы и режиму его работы
4.1.2.1 Для эксплуатации информационной системы достаточно одной штатной единицы.
4.1.2.2 Предполагаемый пользователь должен владеть следующими знаниями и навыками:
- знание области профессиональной деятельности;
- владение компьютером на уровне пользователя.
В качестве подготовительных мероприятий по обучению пользователя должны выступать:
- ознакомление пользователя с общими принципами работы с системой;
- изучение эксплуатационной документации.
4.1.2.3 Режим работы персонала с информационной системой устанавливается произвольно. Информационная система используется по мере необходимости в процессе работы.

4.1.3 Требования к безопасности и надежности
4.1.3.1 Система должна быть защищена от несанкционированного доступа, что должно достигаться путем авторизации пользователя и временной блокировки во время работы.
4.1.3.2 Данные требуется хранить в недоступном для чтения формате с помощью сторонних приложений.
4.1.3.3 При работе пользователя необходимо вести контроль входной информации. Целесообразно иметь возможность ведения журнала регистрации действий пользователя, возникающих ошибок, для последующего анализа в исключительных ситуациях.

4.1.4 Требования к эргономике и технической эстетике
4.1.4.1 Требования к интерфейсу системы:
- удобство манипулирования и простота использования;
- структуризация интерфейса. Выполняемые функции должны быть сгруппированы по смыслу по разделам меню, подменю. Наиболее часто используемые функции вынести на панель инструментов;
- диалоговая форма работы системы с пользователем посредством вывода сообщений, вопросов, диалогов;
- оформление элементов интерфейса в строгих, спокойных тонах, не раздражающих психику человека; 
- формы необходимо разрабатывать таким образом, чтобы они не были перегружены различными элементами, элементы, в свою очередь, располагать максимально удобно, предусмотреть порядок обхода элементов;
- использование элементов справочной системы;
- наличие возможности использования панели функций, режима рабочего стола.
4.1.4.2 Требования к эксплуатации:
- созданная система эксплуатируется с использованием компьютерной техники;
- в производственных помещениях, в которых работа с использованием ПК является вспомогательной, температура, относительная влажность и скорость движения воздуха на рабочих местах должны соответствовать действующим санитарным нормам микроклимата производственных помещений (СанПиН 2.2.2/2.4.1340-03);
- при эксплуатации системы рекомендуется соблюдать общие правила техники безопасности.
4.1.4.3 Требования к сохранности информации
Информационная система должна обеспечивать сохранность информации, введенную в базу данных системы, а также средства для восстановления, тестирования и исправления информационной базы в случае отказа технических средств, отключения питания, сбоя программного обеспечения.
4.1.4.5 Требования к стандартизации и унификации
При разработке и реализации информационной системы следует использовать соответствующие стандарты и методологии (стандарты IDEF, UML, структурный анализ, методологии разработки программных систем).
При необходимости максимально использовать типовые проектные решения в целях оптимизации процесса разработки и сокращения затрат на создание системы.
Информационная система должна поддерживать документооборот, отвечающий требованиям законодательства РФ и использовать унифицированные системы документации, кодирования и классификации.

4.2 Требования к функциям (задачам)
4.2.1 Перечень функций по подсистемам
4.2.1.1 Функции подсистемы управления ЖКХ
- организация накопления и хранения необходимой информации об общем имуществе, собственниках и жильцах, льготах, тарифах, услугах, нормативах;
- ведение списка квартир и жильцов;
- формирование справок для собственников и жильцов;
- организация учета движения жильцов;
- ведение списка льготников по оплате ЖКУ;
- расчет начислений по оплате коммунальных услуг;
- расчет компенсаций по оплате коммунальных услуг (ЕДК);
- учет приборов учета (счетчиков) квартир;
- учет потребленной электроэнергии.
4.2.1.2 Функции подсистемы бухгалтерского учета:
- ввод начальных остатков по счетам;
- начисление и прием платежей за коммунальные услуги;
- регистрация показаний счетчиков и начисление по факту;
- формирование лицевых счетов и выписок;
- учет потребленных товаров, работ, услуг (по видам затрат);
- оплата поставщикам и подрядчикам;
- учет входящих и исходящих счетов-фактур;
- формирование книги покупок и книги продаж;
- ведение списка сотрудников и кадровых документов;
- учет расчетов по заработной плате (расчет, начисление, выплата);
- учет наличных и безналичных денежных средств (кассовые и банковские операции, по статьям движения);
- закрытие отчетного периода;
- формирование бухгалтерской отчетности (бухгалтерский баланс, отчет о прибылях и убытках, отчет о целевом использовании полученных средств).
4.2.1.3 Функции подсистемы налогового учета:
- исчисление и перечисление налогов и взносов (страховые взносы с ФОТ, НДФЛ, земельный налог, плата за негативное воздействие на окружающую среду);
- распределение суммы земельного налога между жильцами;
- формирование ведомостей учета налогов;
- формирование налоговой отчетности.
4.2.1.4 Общие функции и механизмы
4.2.1.4.1 Формирование внутренней отчетности
- список жилых помещений кондоминимума;
- список собственников и жильцов;
- список льготников по категориям;
- отчет о движении жильцов за период;
- список приборов учета квартир;
- список граждан, имеющих право на ЕДК;
- отчет по рассчитанной ЕДК;
- оборотно-сальдовая ведомость (в целом и по счету);
- главная книга (приход и расход по банку – в целом и по статьям);
- отчет по проводкам (по счетам);
- ведомость ФОТ;
4.2.1.4.2 Организация обмена данными между компонентами системы
4.2.1.4.3 Формирование аналитической информации о хозяйственной деятельности
- анализ дебиторской и кредиторской задолженности;
- анализ использования целевых средств и резервов.
4.2.2 Требования к качеству реализации функций:
- доступ к функциям осуществляется посредством диалоговых форм. Организовать эффективную структуру и взаимодействие экранных форм;
- выходная информация может быть представлена как в форме данных, так и в форме отчетов;
- расчетные функции должны требовать минимум действий от пользователя и безошибочно исчислять необходимые показатели в соответствии с имеющейся информацией;
- расчетные функции не должны занимать много времени;
- наличие возможности хранения периодических массивов данных;
- наличие возможности сохранения информации в других форматах за пределами информационной базы.

4.3 Требования к видам обеспечения
4.3.1 Требования к программному обеспечению:
- информационная система должна эксплуатироваться на платформе операционной системы Windows 2000/XP;
- инструмент для реализации – платформа 1С:Предприятие 8.1;
- наличие типовой конфигурации «Бухгалтерия предприятия 8» (профессиональная или базовая версия);
- установленная библиотека машиночитаемых форм отчетности.
4.3.2 Требования к техническому обеспечению:
- для эксплуатации системы необходим персональный компьютер средних характеристик (объем оперативной памяти – от 512 Мбайт, процессор: от 2,4 ГГц, жесткий диск – от 80 Гбайт);
- монитор с разрешением экрана не менее 1024х768 пикселей;
- необходимо наличие принтера с черно-белой печатью формата А4.
4.3.3 Требования к информационному и методическому обеспечению:
- необходимость удобной организации данных в системе, их структуризация в соответствии с их семантикой, иерархическая упорядоченность и взаимосвязь;
- для функционирования системы необходимо начальное заполнение информационной базы;
- обмен данными между компонентами системы по технологии OLE Automation должен осуществляться соответствующим модулем;
- последующий сбор, обработка данных в системе осуществляется в динамике протекающих бизнес-процессов;
- в процессе функционирования системы наряду с эксплуатационной документацией к системе по необходимости применять справочную информацию по системе программ 1С:Предприятие 8, поставляемой фирмой 1С.

4.4 Состав и содержание работ по созданию системы
4.4.1 Состав и содержание работ по разработке системы определяется календарным планом работы в соответствии с выбранной методологией разработки систем.

4.5 Порядок контроля и приемки системы
4.5.1 Система после завершения разработки передается в опытную эксплуатацию Заказчику с целью тестирования работы системы и ее адекватности поставленным целям.
4.5.2 Разработчик по требованию Заказчика дорабатывает систему или отдельные ее части при обнаружении ошибок и в других необходимых случаях.
4.5.3 Приемочная комиссия представляется ответственным лицом Заказчика, с которым осуществляется взаимодействие по вопросам разработки системы.

4.6 Требования к составу и содержанию работ по подготовке объекта автоматизации к вводу системы в действие
4.6.1 Приведение поступающей в систему информации к виду, пригодному для обработки с помощью ЭВМ
Для функционирования системы необходимо определить списковую и условно-постоянную информацию предметной области и ввести ее в информационную базу для многократного использования.
Хозяйственные операции отражаются в информационной системе посредством периодического ввода и проведения документов.
4.6.2 Для ввода системы в эксплуатацию необходимо выполнить следующие действия:
- приобретение соответствующих технических средств и их установка;
- установка необходимых программных средств;
- установка системы и ее настройка;
- обучение пользователя.

4.7 Требования к документированию
В состав эксплуатационной документации должны входить следующие документы:
- руководство пользователя;
- руководство программиста;
- официальная документация по системе программ 1С:Предприятие 8.

4.8 Источники разработки
Основные источники разработки системы:
- учредительные, первичные учетные документы и отчетность организации-заказчика;
- нормативно-правовая документация;
- литературные источники и статьи.",0
39,tz_09.docx,"2.2. Техническое задание
2.2.1.

Общие сведения
В данной главе представлены общие сведения о системе:
полное наименование системы и ее условное обозначение:  Web-приложение «Аутсорсинг Информационных Систем и Технологий » (АИСТ);
шифр темы или шифр (номер) договора: данный программный продукт разрабатывался в рамках дипломного проектирования, какой-либо договор не заключался; 
наименование предприятий разработчика и заказчика системы, их реквизиты: ООО «Торговая компания «Альфа» (ИНН/КПП, г. Ульяновск, ул.); 
плановые сроки начала и окончания работ: 1 марта 2009 года — 30 мая 2009 года;
сведения об источниках и порядке финансирования работ: данные работы проводятся на абсолютно безвозмездной основе;
порядок оформления и предъявления заказчику результатов работ по созданию системы, ее частей и отдельных средств: по окончанию работ заказчику должны быть предъявлены и переданы установочный диск со всеми необходимыми дистрибутивами, набор инструкций и документации для полноценного функционирования указанной системы.

2.2.2. Назначение и цели создания системы
Разработанная система предназначена для автоматизации деятельности отдела по обслуживанию клиентов. Данную систему предполагается использовать в  ООО «ТК «Альфа» .
 При внедрении ИС должны быть достигнуты следующие цели: 
с технологической точки зрения: должен быть упрощен процесс взаимодействия начальника отдела с сотрудниками, находящимися в его подчинении, улучшено качество работы отдела;
с производственно-экономической точки зрения: должно быть сокращено время на организацию работы сотрудников и формирование соответствующей отчетности.

2.2.3. Характеристика объектов автоматизации
Объектом автоматизации является процесс управления отделом обслуживания клиентов ООО «ТК «Альфа». Процесс заключается в учете рабочего времени сотрудников данного отдела, а так же учете выполненных работ.
ООО «ТК «Альфа»» ведет различные виды деятельности:
Продажа компьютерной техники.
Установка, настройка и техническая поддержка компьютерной  техники.
Продажа программного обеспечения.
Ремонт оборудования.
Внедрение программных продуктов фирмы 1С.
Разработка веб-сайтов.

2.2.4. Требования к системе 
Требования к системе в целом:
а) требования к структуре и функционированию системы:
Разработанная система должна состоять из следующих подсистем:
планирование работы с клиентами;
анализ деятельности отдела.
Первая подсистема должна предоставить руководителю отдела возможность видеть своевременное взаимодействие сотрудников с клиентами с тем, чтобы ни один клиент не оказался «забытым», во время выявить возникшие проблемы. 
Вторая подсистема должна подсчитывать и наглядно представлять экономический результат деятельности, среднее время работы.

б) требования к персоналу:
Количество пользователей системы соответствует количеству сотрудников отдела обслуживания клиентов предприятия ООО «ТК «Альфа». Так же, необходим администратор системы, к чьим обязанностям относится:
Установка и настройка системы.
Установка и настройка дополнительного программного обеспечения.
Исправление ошибок в случае их возникновения.
Администратор системы должен иметь навыки:
Программирования на языках высокого уровня.
Написание запросов на языке SQL.
Количество пользователей системы соответствует количеству сотрудников отдела обслуживания клиентов предприятия ООО «ТК «Альфа».

в) степень приспособляемости системы:
Данная система должна быть гибкой в отношении изменения отчетов, должна обеспечивать настройку их параметров.

г) требования к системе:
         Система должна быть надежной, т.е. отказоустойчивой к ошибкам пользователя (нарушения правильной последовательности действий).
Она должна быть удобна для работы пользователя. 
		Должна присутствовать авторизация и аутентификация пользователя, возможность тонкой настройки доступа к объектам и функциям системы. 
Программный продукт должен быть патентно чист и иметь возможность законно использоваться в коммерческих целях. Разрабатываемый программный продукт является патентно-чистым. 
Для безопасности системы необходимо, чтобы пользователи:
Надежно хранили свои данные для входа в систему.
Осуществляли доступ в систему только с рабочего места.
Использовали систему только для рабочих целей.
Имели  понимание о проблемах безопасности.
Умели преобразовывать задачи к возможностям системы.
Необходимо исключать ситуации:
Неопытность пользователя.
Неисправность ПК.
Неисправность каналов связи.
Перебои с электроэнергией.
Наделение пользователей лишними правами в системе.
Предоставление информации пользователю, которому она не предназначена.

Требования к видам обеспечения:
Система предъявляет следующие требования к видам обеспечения:
а) информационному: Microsoft SQL Server 2005, либо MYSQL Server;
б) лингвистическому: используется язык программирования «PHP» и Java-script;
в) программному и техническому: 
 1) компьютер конечного пользователя (рекомендуемые параметры): 
операционная система: MS Windows 2000/ XP / Server 2003; 
процессор Intel Pentium III 866 МГц; 
оперативная память 256 Мбайт; 
2) компьютер, используемый для разработки конфигураций: 
операционная система: MS Windows 2000/ XP / Server 2003; 
Intel Pentium IV/Celeron 1800  МГц ; 
оперативная память 512 Мбайт; 
3) сервер ПП: 
операционная система: MS Windows 2000/Server 2003, ОС семейства UNIX; 
процессор Intel Pentium IV/Xeon 2,4 ГГц, рекомендуется два и более процессоров; 
оперативная память 1024 Мбайт; 
4) сервер баз данных: 
технические характеристики компьютера и операционная система должны соответствовать требованиям Microsoft SQL Server 2005, MYSQL Server; 
г) организационному: для функционирования системы необходимы системный администратор и несколько сотрудников;
д) методическому (состав нормативно-технической документации):
инструкция программисту; 
инструкция пользователю.

2.2.5. Состав и содержание работ по созданию системы
Перечень этапов работ и сроки исполнения:
Перечень этапов работ и сроки исполнения представлены в таблице 2.1
Таблица 2.1 
Основные этапы работ и сроки их исполнения

Состав исполнителей работ:
Работы по созданию системы проводились физическим лицом - _______, студентом УлГТУ, под руководством преподавателя кафедры «Информационные системы» Наместникова Алексея Михайловича.

Перечень подлежащих разработке документов:
Инструкция пользователю
Инструкция системному администратору",0
1,tz_10.docx,"2.2. Техническое задание
2.2.1. Общие сведения
В данной главе представлены общие сведения о системе:
полное наименование системы и ее условное обозначение:  web-сайт территориально-производственного предприятия «Урайнефтегаз»
шифр темы или шифр (номер) договора: данный программный продукт разрабатывался вне рамок какого-либо договора, а в рамках дипломного проектирования.
наименование предприятий разработчика и заказчика системы, их реквизиты: 
перечень документов, на основании которых создается информационная система: нет
плановые сроки начала и окончания работ: 1 апреля 2010 года — 30 мая 2010 года;
сведения об источниках и порядке финансирования работ: данные работы проводятся на безвозмездной основе;
порядок оформления и предъявления заказчику результатов работ по созданию системы, ее частей и отдельных средств: по окончанию работ заказчику должны быть предъявлены и переданы диск с данными проекта,  набор инструкций и документации для полноценного функционирования сайта.

2.2.2. Назначение и цели создания системы
Видом автоматизируемой деятельности является распространение информации, получение обратной связи. Данную систему предполагается использовать в организации. 
Целью создания системы является всестороннее представление предприятия, как на местном, так и на федеральном уровне. В следствии - привлечение молодых квалифицированных специалистов, организация обратной связи с сотрудниками предприятия, взаимодействие со СМИ.

2.2.3. Характеристика объектов автоматизации
Объектом автоматизации являются: 
получение пользователями внутренних документов предприятия,
размещение контактной информации, 
размещение информации о вакансиях, 
размещение данных о производственной деятельности предприятия,
размещение внутренних нормативных документов.
Требований к условиям эксплуатации и характеристиках окружающей среды нет.

2.2.4. Требования к системе в целом
а) Требования к структуре и функционированию системы.
Разработанная система сайта должна состоять из следующих подсистем: 
доступа к БД MySQL
пользовательского интерфейса
визуализации данных
хранения данных
классов уровня приложения
Подсистема доступа к БД должна позволять легко изменять структуру БД без изменения большей части программы, обеспечить корректную загрузку и выгрузку данных, правильную работу запросов и снижать вероятность ошибок.
Подсистема пользовательского интерфейса должна обеспечивать динамическую сборку страниц, легкость корректировки отдельных частей и отсутствие конфликтов между ними, правильный вывод страниц.
Подсистема визуализации данных должна корректно и визуально привлекательно для пользователя предоставлять информацию.
Структура таблиц БД, каталогов и файлов подсистемы хранения данных должна быть разработана таким образом, что бы легко было найти и изменить хранящуюся в них информацию.
Подсистема классов должна строится таким образом, чтобы каждый класс обладал хорошо определённой сферой ответственности. Код должен быть снабжен комментариями и был понятен другому программисту.
В проекте должно быть несколько режимов функционирования. Главные – это режим администратора и режим пользователя.
В перспективе развитие системы должно быть легко осуществимо. Возможно добавление новых сервисов.
б) Требования к персоналу.
Для функционирования системы необходим 1 человека: администратор.
Системный администратор должен уметь работать с оболочкой phpMyAdmin, обладать знаниями по web-программированию, в частности на языке php. А также выполнять роль модератора при проверке комментариев и добавлять в базу новые данные.
Пользователь должен обладать знаниями об использовании браузера.
в) Требования к системе.
Система должна быть надежной: отказоустойчивой к ошибкам пользователя (нарушения правильной последовательности действий), ошибкам в загружаемых данных. Также система должна восстанавливаться после различных сбоев (отключение электричества, сбой в работе операционной системы, оборудования т т.д.). За данный функционал отвечает сервер MySQL
Программный комплекс должен быть кросс-платформенен, легко мигрировать на разные архитектуры серверов и операционные системы. 
Продукт должен обладать  эргономичным и интуитивно-понятным интерфейсом. 
Должна быть предусмотрена возможность обновления и обслуживания системы, в том числе и сторонними разработчиками. Возможность расширения функционала приложений.
Должна присутствовать аутентификация пользователя на сервере, для разграничения доступа к информации и ее защите от изменений, настройки доступа к БД. 

2.2.5. Требования к функциям (по подсистемам)
Перечень подлежащих автоматизации задач:
Поступление сообщений с вопросами от пользователей, 
Организация обратной связи,
Возможность скачивания внутренних документов предприятия.

2.2.6. Перечень критериев и отказов
Фатальные ошибки. Сбои в системе, которые приводят к потере ее работоспособности или к порче данных. Ошибка управления или попытка взлома системы. Ошибка авторизации.
Серьезные ошибки. Ошибки, которые не позволяют достичь желаемого результата при использовании некоторого средства или функции программного продукта. Ошибка выполнения SQL-запроса. Ошибка запроса открытия файла.
Маленькие ошибки. Ошибки, которые вызывают неудобство работы с системой, например, ошибки в задании порядка перехода от одного элемента управления к другому в форме ввода информации.
Незначительные ошибки. К данному типу ошибок относятся орфографические ошибки в надписях или не выровненные элементы управления. Ошибки ввода данных в форму.

2.2.7. Требования к видам обеспечения.
Система предъявляет следующие требования к видам обеспечения:
а) информационному: для хранения данных использовать СУБД MySQL, запущенную на удаленном, либо этом же компьютере. Для выполнения скриптов, написанных на языке PHP понадобится интерпретатор PHP. Для управления базами данных phpMyAdmin.
в) лингвистическому: использовать язык программирования PHP, язык запросов SQL, язык описания HTML, язык разметки CSS, XML.
г) программному и техническому: 
Характеристики компьютера пользователя: 
операционная система: Windows/Linux/MacOS/Solaris; 
Intel Pentium III/Celeron 800  МГц ; 
оперативная память 256 Мбайт;  
Сервер баз данных:
операционная система: Windows/Linux/MacOS/Solaris; 
Intel Pentium III/Celeron 800  МГц; 
оперативная память 256 Мбайт;  
Необходимый набор программ пользователя:
браузер Internet Explorer/ Opera и др.; 
Необходимый набор программ администратора:
браузер Internet Explorer/ Opera и др.; 
phpMyAdmin;
текстовый редактор
е) организационному:  для функционирования системы необходим 1 человека: администратор.
Системный администратор должен уметь работать с оболочкой phpMyAdmin, обладать знаниями по web-программированию, в частности на языке php. А также выполнять роль модератора при проверке комментариев и добавлять в базу новые данные.
ж) методическому (состав нормативно-технической документации):
Инструкция программисту
Инструкция администратору 
Инструкция пользователю

2.2.8. Перечень этапов работ и сроки исполнения
Таблица 1 Этапы и сроки выполнения проекта

2.2.9. Состав исполнителей работ
Работы по созданию проекта проводились физическим лицом - студентом УлГТУ, Кандрушиным Алексеем Олеговичем. Консультантом по разработке являлся к.э.н. доцент кафедры «Информационные системы», руководитель дипломного проекта Суркова Елена Викторовна.

2.2.10. Порядок контроля системы
Для контроля необходимо провести следующие виды тестирования:
Функциональное тестирование. Оно включает проверку каждой команды меню, панели инструментов и каждой операции, которую выполняет система. 
Тестирование приложения. При выполнении тестирования приложения испытатель моделирует действия пользователя. Моделируя различные комбинации действий, можно найти ошибки, относящиеся к интеграции компонентов, а также недоработки, которые не были обнаружены при функциональном тестировании.
Тестирование на скорость выполнения. Измеряется время отклика системы на некоторое действие, документа. Обычно при этом определяются параметры эффективности. Одновременно с измерением времени на выполнение запроса необходимо записать также размер базы данных.
Предельное тестирование. Позволяет определить пропускную способность программного продукта. Запускаются задачи, увеличивая размеры файлов или баз данных, и таким образом выявляют предельное значение объема данных, при котором завершение выполнения задачи невозможно. Максимальный объем данных является существенным ограничением при программировании. 

2.2.11. Перечень подлежащих разработке документов
Инструкция пользователю
Инструкция программисту
Инструкция системному администратору",0
5,tz_11.docx,"2.2.	Техническое задание
2.2.1.	Общие сведения
2.2.1.1. Полное наименование системы: «Анализ финансового состояния предприятия» 
2.2.1.2. Шифр темы: АФСП.
2.2.1.3. Наименование предприятия заказчика: ООО «Газовая компания»
2.2.1.4. Основание для разработки системы: Задание на выполнение дипломного проекта. 
2.2.1.5. Плановые сроки начала и окончания работ
Начало работ: 26 марта .
Окончание работ: 31 мая .
2.2.1.6. Порядок оформления и предъявления заказчику 
результатов работ
Результаты работ оформляются в виде пояснительной записки, иллюстративного материала и ИС. «Пояснительная записка является основным документом, в котором излагаются исчерпывающие сведения о выполненном дипломном проекте» [1, с.8].
«Структура пояснительной записки включает: 
титульный лист;
задание на выполнение дипломного проекта 
содержание; 
аннотация  
перечень сокращений, символов и специальных терминов с их определениями; 
введение;
основная часть (главы);
заключение;
список использованной литературы; 
приложения.

2.2.2.	Назначение и цели создания системы
2.2.2.1. Вид автоматизируемой деятельности: анализ деятельности предприятия различными методами и предоставление выводов, советующего характера.
2.2.2.2. Перечень объектов, на которых предполагается 
использование системы: Автоматизированное рабочее место аналитика, бухгалтера, руководителя.
2.2.2.3. Цели создания ИС
Разработать программное средство позволяющее автоматизировать процесс анализа ликвидности и платежеспособности, сравнительного баланса, деловой активности и рентабельности, финансовой независимости, вероятности банкротства, эффективности вложения заемных средств в оборот предприятия, производить трендовый анализ финансовых коэффициентов с использованием типового программного продукта 1С: Бухгалтерия предприятия 8.1. 
Цель разработки – повышение оперативности и качества процесса анализа предприятия и достоверности результатов анализа, предоставление выводов, как в текстовой формулировке, так и посредством диаграмм, графиков.

2.2.3.	Характеристика объектов автоматизации
Объектом автоматизации является деятельность предприятия в срезе анализа  деятельности, указанной в пункте 2.2.2.3.
2.2.3.2. Сведения об условиях эксплуатации и характеристиках окружающей среды.
Климатические условия эксплуатации должны удовлетворять требованиям, предъявляемым к техническим средствам в части условий их эксплуатации.

2.2.4.	Требования к системе:
2.2.4.1. Требования к системе в целом:
Требования к персоналу
Количество персонала, требуемого для работы программы, должно составлять минимум 1 штатную единицу — конечный пользователь программы — аналитик. Аналитик должен быть уверенным пользователем ПК.
Требования к надежности
Надёжное (устойчивое) функционирование программы должно быть обеспечено выполнением фотографом совокупности организационно-технических мероприятий, перечень которых приведён ниже:
организацией бесперебойного питания технических средств;
регулярным выполнением рекомендаций Министерства труда и социального развития РФ, изложенных в постановлении от 23 июля 1998г. «Об утверждении межотраслевых типовых норм времени на работы по сервисному обслуживанию ПЭВМ и оргтехники и сопровождению программных средств»;
Отказы программы вследствие некорректных действий пользователя при взаимодействии с программой через интерфейс недопустим.
Требования к интерфейсу программы: 
Программный продукт должен быть ориентирован на неподготовленного пользователя ЭВМ, имеющего начальные навыки работы с ОС Windows и программным продуктом 1С:Бухгалтерия предприятия 8.1. Общение с компьютером должно осуществляться на основе графического оконного интерфейса в виде иерархической системы меню, кнопок, полей ввода данных. 

2.2.4.2. Требования к функциям
Программа должна обеспечивать выполнение перечисленных ниже функций:
Требования к составу входной информации:
в качестве входной информации используются данные стандартных форм бухгалтерской отчетности с привязкой к отчетному периоду и организации – Форма №1, Форма №2;
ввод данных за различные отчетные периоды;
ввод данных по различным организациям.
Требования к составу выходной информации:
Выходная информация включает
исходные данные;
численные значения рассчитанных показателей;
результаты расчетов показателей за последовательные периоды в виде таблиц и диаграмм и значений отдельных показателей;
текстовые комментарии к результатам анализа.
 Требования к подсистеме анализа:
Подсистема анализа должна предоставлять следующие возможности:
расчет абсолютных показателей финансового состояния предприятия;
расчет относительных показателей финансового состояния предприятия;
построение диаграмма по рассчитанным показателям (автоматически и по запросу пользователя);
логические заключения на основании полученных данных. 
ввод данных с привязкой к отчетному периоду;
хранение данных за различные отчетные периоды;
представление результатов анализа в виде численных значений отдельных показателей, таблиц, диаграмм; 
реализация  следующих методов финансового анализа:
трендовый анализ;
вертикальный анализ;
горизонтальный анализ;
метод финансовых показателей;
метод аналитических таблиц;
формирование отчетных материалов по результатам анализа;

2.2.4.3. Требования к видам обеспечения:
Требования к программному обеспечению
Программный продукт должен работать на платформе 1С:Предприятие 8.1.
Требования к техническому обеспечению:
операционная система: MS Windows 98/Me, MS Windows NT 4.0/2000/XP/Server 2003 (рекомендуется MS Windows 2000/XP/Server 2003);
процессор Intel Pentium II 400 МГц и выше (рекомендуется Intel Pentium III 866 МГц);
оперативная память 128 Мбайт и выше (рекомендуется 256 Мбайт);
SVGA дисплей.

2.2.5.	Состав и содержание работ по созданию системы
2.2.5.1. Перечень стадий и этапов работ:
 1 – систематизация материала;
2 – описание бизнес-процессов;
3 – формулировка постановки задачи;
4 – подготовка обзора состояния вопроса;
5 – решение задач экономического раздела дипломного проекта; 
6 – проектирование и разработка информационной системы;
7 – оформление проекта.
2.2.5.2. Сроки исполнения 
15 апреля .: этапы 1 –4;
30 апреля 2010г.: этап 5;
15 мая 2010г.: этап 6;
31 мая 2010г.: этап 7.

2.2.6.	Порядок контроля и приемки системы
2.2.6.1. Виды, состав, объем и методы испытаний системы
Испытания системы проходят по факту ее готовности. Методами испытаний являются тестовый пример проведения анализа на тестовых данных.
2.2.6.2. Общие требования к приемке работ по стадиям
Так как разработка системы ведется как единое целое, то и особых требований к приемке по стадиям не выдвигалось. 
2.2.6.3. Статус приемной комиссии
В составе приемной комиссии присутствовали главный бухгалтер предприятия и два учредителя компании. 

2.2.7.	Требования к документированию
2.2.7.1. Перечень подлежащих разработке документов
Пояснительная записка, структура которой приведена в пункте 2.2.1.6

2.2.8.	Источники разработки
Документами и информационными материалами, на основании которых разрабатывается ТЗ и система, являются требования и пожелания руководства предприятия, нормативная база по проведению финансового анализа на предприятии.",0
36,tz_12.docx,"2.2	Техническое задание
2.2.1	Общие сведения
2.2.1.1 Полное наименование системы: Учёт фотоуслуг.
2.2.1.2 Шифр темы: УФ.
2.2.1.3 Наименование предприятия заказчика: Ульяновский государственный технический университет.
2.2.1.4 Основание для разработки системы: Задание на выполнение дипломного проекта. 
2.2.1.5 Плановые сроки начала и окончания работ
Начало работ: 1 апреля 2010 г.
Окончание работ: 31 мая 2010 г.
2.2.1.6 Порядок оформления и предъявления заказчику 
результатов работ
Результаты работ оформляются в виде пояснительной записки, иллюстративного материала и ИС. «Пояснительная записка является основным документом, в котором излагаются исчерпывающие сведения о выполненном дипломном проекте» [1, с.8].
«Структура пояснительной записки включает: 
титульный лист (Приложение 4); 
задание на выполнение дипломного проекта (Приложение 2);
содержание (на первой странице содержания располагается основная надпись по форме 2); 
аннотация (Приложение 5); 
перечень сокращений, символов и специальных терминов с их определениями; 
введение;
основная часть (главы);
заключение;
список использованной литературы; 
приложения» [1, с.9].

2.2.2	Назначение и цели создания системы
2.2.2.1 Вид автоматизируемой деятельности: учёт фотоуслуг и подготовка отчётов.
2.2.2.2 Перечень объектов, на которых предполагается 
использование системы: Автоматизированное рабочее место фотографа.
2.2.2.3 Цели создания ИС
Целью проектирования ИС является сокращение посредствам автоматизации затрат времени на выполнение следующих функций:
учёт совершённых операций (фиксация информации о событиях);
подготовка данных для анализа (осуществления расчётных процедур);
представления информации для анализа в наглядном виде (отчёты).

2.2.3	Характеристика объектов автоматизации
2.2.3.1 Краткие сведения об объекте автоматизации
Объектом автоматизации является деятельность фотографа в срезе вспомогательной деятельности, указанной в пункте 2.2.2.3.
2.2.3.2 Сведения об условиях эксплуатации и характеристиках окружающей среды
Климатические условия эксплуатации должны удовлетворять требованиям, предъявляемым к техническим средствам в части условий их эксплуатации.

2.2.4	Требования к системе:
2.2.4.1 Требования к системе в целом:
2.2.4.1.1 Требования к персоналу
Количество персонала, требуемого для работы программы, должно составлять 1 штатную единицу — конечный пользователь программы — фотограф. Фотограф должен быть уверенным пользователем ПК.
2.2.4.1.2 Требования к надежности
Надёжное (устойчивое) функционирование программы должно быть обеспечено выполнением фотографом совокупности организационно-технических мероприятий, перечень которых приведён ниже:
организацией бесперебойного питания технических средств;
регулярным выполнением рекомендаций Министерства труда и социального развития РФ, изложенных в постановлении от 23 июля 1998г. «Об утверждении межотраслевых типовых норм времени на работы по сервисному обслуживанию ПЭВМ и оргтехники и сопровождению программных средств»;
регулярным выполнением требований ГОСТ 51188-98. Защита информации. Испытания программных средств на наличие компьютерных вирусов.
Отказы программы вследствие некорректных действий пользователя при взаимодействии с программой через интерфейс недопустим.
2.2.4.1.3 Требования к интерфейсу программы: Классический интерфейс Windows.
2.2.4.2 Требования к функциям
Программа должна обеспечивать выполнение перечисленных ниже функций:
2.2.4.2.1Ввод, хранение и вывод информации, соответствующей операциям:
оформить заказ (номер заказа, дата, наименование заказа, срок исполнения, комментарий, стоимость заказа, вид фотосъёмки, продолжительность фотосъёмки, дата съемки, время съемки, результат съёмки, количество результирующих продуктов; оформленный заказ будем называть договором);
закупка материалов (номер, дата, поставщик, наименование материала, цена единицы, количество единиц, сумма покупки);
расход материалов в рамках заказа (номер, дата, договор, наименование расходного материала, количество расходного материала);
списание брака (номер, дата, наименование расходного материала, количество расходного материала);
печать (номер, дата, заказ, кто оказывает услуги, вид печати, цена за единицу, количество единиц, сумма печати);
оплата заказа (номер, дата, заказ, вносимая сумма);
заказ выполнен (номер, дата, договор);
аренда (номер, дата, договор, предмет договора аренды, контрагент, дата съёмки, время съёмки, продолжительность, стоимость аренды);
оплата работы (номер, дата, работник, сумма);
прочие расходы (номер, дата, вид расхода, сумма, комментарий)
Данные для ввода информации по операциям должны иметь следующую структуру:
заказчики (код, ФИО, дата рождения, телефон, идентификационный номер в социальной сети «В контакте», электронный адрес, комментарий);
контрагенты (код, наименование, режим работы, улица, дом, офис, телефон, электронный адрес, комментарий);
работники (код, ФИО, комментарий, является ли ИП);
расходные материалы (код, наименование материала);
виды фотосъёмки (код, наименование, описание);
виды результата (код, наименование, описание);
вид печати(код, наименование, описание);
оборудование (код, наименование, контрагент, комментарий);
студии (код, наименование, контрагент, комментарий);
прочие расходы (код, наименование).
2.2.4.2.2 Вывод следующей информации о заказе (состояние заказа) на экран и на печать на конкретную дату:
номер заказа;
дата, на которую действительна информация;
когда принят заказ;
суть заказа;
выполнен ли заказ;
какая сумма внесена заказчиком;
оплачен ли заказ;
на заказ произведено затрат;
если заказ выполнен, то какова ожидаемая прибыль от заказа (разница между суммой прихода денежных средств и суммой произведённых для выполнения данного заказа расходов).
2.2.4.2.3Вывод списка активных заказов (не выполненных и/или не оплаченных):
номер договора;
название;
оплачен ли заказ либо сколько внесено денежных средств;
выполнен ли заказ
Должна быть предусмотрена возможность быстрого перехода к просмотру состояния любого заказа из выведенного списка.
2.2.4.2.4 Вывод остатков материалов на выбранную дату (наименование материала и количество).
2.2.4.2.5 Вывод информации по выданной зарплате за выбранный период по месяцам (период, работник, сумма).
2.2.4.2.6 Вывод остатка в кассе на выбранную дату.
2.2.4.2.7 Отразить динамику прибыли (доходы минус расходы за период) за выбранный промежуток времени с заданной периодичностью (год или месяц): значения прибыли в периоде и изменение прибыли в % в к предыдущему периоду. Значения вывести в числовом и наглядном представлении (график в абсолютных единицах и гистограмма изменения).
2.2.4.2.8 Вывод информации, детализирующей доход и расходы по месяцам за выбранный период. Для каждого месяца, должна быть выведена сумма прихода по каждому виду съёмки, сумма общего прихода денежных средств, сумма по каждому виду расхода (со знаком минус) и по всем расходам в целом. Данные должны быть представлены в табличной форме и на графике. При необходимости должна быть возможность скрыть на графике любой вид дохода/расхода, при этом ещё одна таблица должна отображать значения только выведенных доходов/расходов.
2.2.4.2.9 Вывод для выбранного месяца списка заказчиков, день рождения которых в этом месяце (ФИО, день рождения, телефон).

2.2.4.3 Требования к видам обеспечения:
2.2.4.3.1 Требования к программному обеспечению
Программный продукт должен работать на платформе 1С:Предприятие 8.1.
2.2.4.3.2 Требования к техническому обеспечению:
операционная система: MS Windows 98/Me, MS Windows NT 4.0/2000/XP/Server 2003 (рекомендуется MS Windows 2000/XP/Server 2003);
процессор Intel Pentium II 400 МГц и выше (рекомендуется Intel Pentium III 866 МГц);
оперативная память 128 Мбайт и выше (рекомендуется 256 Мбайт);
жесткий диск (при установке используется около 120 Мбайт);
устройство чтения компакт дисков;
USB-порт;
SVGA дисплей.

2.2.5	Состав и содержание работ по созданию системы
2.2.5.1 Перечень стадий и этапов работ: 1 – систематизация материала, 2 – описание бизнес-процессов, 3 – формулировка постановки задачи, 4 – подготовка обзора состояния вопроса, 5 – решение задач экономического раздела дипломного проекта, 6 – проектирование и разработка информационной системы, 7 – оформление проекта.
2.2.5.2 Сроки исполнения 
15 апреля 2010 г.: этапы 1 –4;
30 апреля 2010г.: этап 5;
15 мая 2010г.: этап 6;
31 мая 2010г.: этап 7.

2.2.6	Порядок контроля и приемки системы
В соответствии с учебным планом.

2.2.7	Требования к документированию
2.2.7.1 Перечень подлежащих разработке документов
Пояснительная записка, структура которой приведена в пункте 2.2.1.6",0
37,tz_13.docx,"2.2. Техническое задание
2.2.1. Общие сведения
В данной главе представлены общие сведения о системе:
полное наименование системы и ее условное обозначение:  Документооборот. ИФНС;
шифр темы или шифр (номер) договора: данный программный продукт разрабатывался в рамках дипломного проектирования, какой-либо договор не заключался; 
наименование предприятий разработчика и заказчика системы, их реквизиты: ИФНС;
плановые сроки начала и окончания работ: 1 марта 2010 года — 30 мая 2010 года;
сведения об источниках и порядке финансирования работ: данные работы проводятся на абсолютно безвозмездной основе;
порядок оформления и предъявления заказчику результатов работ по созданию системы, ее частей и отдельных средств: передача программного продукта не производится.

2.2.2. Назначение и цели создания системы
Разработанная система предназначена для автоматизации документооборота. Данную систему предполагается использовать в  налоговых инспекциях различных уровней.
 При внедрении ИС должны быть достигнуты следующие цели: 
обеспечить сокращение трудозатрат и времени на обработку и подготовку документов, принятие управленческих решений;
повысить уровень исполнительской дисциплины и упростить механизм её контроля;
обеспечить оперативность предоставления услуг населению;
ускорить взаимодействие между подразделениями.

2.2.3. Характеристика объектов автоматизации
Объектом автоматизации является инспекция федеральной налоговой службы. Это предприятие специализируется на контроле и надзоре за соблюдением законодательства Российской Федерации о налогах и сборах, за правильностью исчисления, полнотой и своевременностью внесения в соответствующий бюджет налогов и сборов, в случаях, предусмотренных законодательством Российской Федерации, за правильностью исчисления, полнотой и своевременностью внесения в соответствующий бюджет иных обязательных платежей, а также за производством и оборотом этилового спирта, спиртосодержащей, алкогольной и табачной продукции и за соблюдением валютного законодательства Российской Федерации в пределах компетенции налоговых органов.
ФНС осуществляет свою деятельность непосредственно и через свои территориальные органы во взаимодействии с другими федеральными органами исполнительной власти, органами исполнительной власти субъектов Российской Федерации, органами местного самоуправления и государственными внебюджетными фондами, общественными объединениями и иными организациями. 
ФНС является уполномоченным федеральным органом исполнительной власти, осуществляющим государственную регистрацию юридических лиц, физических лиц в качестве индивидуальных предпринимателей и крестьянских (фермерских) хозяйств.

2.2.4. Требования к структуре и функционированию системы
Разработанная система должна состоять из следующих подсистем:
организация процесса ввода, хранения и редактирования документов;
слежение за сроками исполнения поручений.
Первая подсистема должна предоставить возможность регистрации всех документов, поступающих в инспекцию, ни один документ не должен быть забыт. 
Вторая подсистема должна отслеживать процесс обработки документа: рассмотрение, ознакомление и согласование.

2.2.5. Требования к персоналу
Число человек, работающих с системой, неограниченно. Оно определяется количеством сотрудников в организации.  Кроме того, необходим системный администратор.
Системный администратор должен обладать знаниями по администрированию и сопровождению систем, а также выполнять соответствующую настройку и поддержку.
Сотрудники инспекции должны быть квалифицированными сотрудниками и быть знакомыми с основными принципами работы офисных программ.

2.2.6. Степень приспособляемости системы
Данная система должна быть гибкой в отношении изменения баз данных, должна обеспечивать настройку их параметров.

2.2.7. Требования к системе
Система должна быть надежной, т.е. отказоустойчивой к ошибкам пользователя (нарушения правильной последовательности действий).
Она должна быть удобна для работы пользователя. 
	Должна быть предусмотрена возможность обслуживания системы, в том числе и сторонними разработчиками.
	Должна присутствовать авторизация и аутентификация пользователя, возможность тонкой настройки доступа к объектам и функциям системы. 
Программный продукт должен быть патентно чист и иметь возможность законно использоваться в коммерческих целях. Разрабатываемый программный продукт является патентно-чистым. Для функционирования системы необходима операционная система Windows.

2.2.8. Требования к видам обеспечения
Система предъявляет следующие требования к видам обеспечения:
информационному: Microsoft Office;
лингвистическому: используется язык программирования «Delphi 7»;
программному и техническому: 
компьютер конечного пользователя (рекомендуемые параметры): 
операционная система: MS Windows 2000/ XP / Vista/ 7; 
процессор Intel Pentium III 866 МГц, AMD; 
оперативная память 256 Мбайт; 
компьютер, используемый для разработки конфигураций: 
операционная система: MS Windows 2000/ XP / XP / Vista/ 7 ; 
Intel Pentium IV/Celeron 1800  МГц ; 
оперативная память 512 Мбайт; 
сервер баз данных: 
технические характеристики компьютера и операционная система должны соответствовать требованиям Microsoft Access;
организационному: для функционирования системы необходим системный администратор;
методическому (состав нормативно-технической документации):
инструкция программисту; 
инструкция пользователю.

2.2.9. Перечень этапов работ и сроки исполнения
Перечень этапов работ и сроки исполнения представлены в таблице 1
Таблица 1
Основные этапы работ и сроки их исполнения

2.2.10. Состав исполнителей работ
Работы по созданию системы проводились физическим лицом – Фирсовой Кристиной Эдуардовной, студенткой УлГТУ, под руководством преподавателя кафедры «Информационные системы» Ларионовой Ольги Борисовны.

2.2.11. Перечень подлежащих разработке документов
инструкция пользователю;
инструкция системному администратору.",0
20,tz_14.docx,"Техническое задание
Рассмотрев общие требования и составив представление о предметной области, приступим к разработке технического задания. 
Техническое задание составлено по ГОСТ 34.602-89. 

 Общие сведения
В данной главе представлены общие сведения о системе:
Полное наименование системы и ее условное обозначение: web-сайт компании строительных материалов «Новый Стандарт».
Шифр темы или шифр (номер) договора: данный программный продукт разрабатывался вне рамок какого-либо договора, а в рамках дипломного проектирования.
Перечень документов, на основании которых создается информационная система: задание на дипломное проектирование.
Плановые сроки начала и окончания работ: с 01.02.2010 по 31.05.2010.
Сведения об источниках и порядке финансирования работ: данные работы проводятся на безвозмездной основе;
Порядок оформления и предъявления заказчику результатов работ по созданию системы, ее частей и отдельных средств: по окончанию работ заказчику должны быть предъявлены и переданы диск с данными проекта,  набор инструкций и документации для полноценного функционирования сайта.

 Назначение и цели создания системы
Сайт компании строительных материалов «Новый стандарт» создаётся для достижения следующих целей:
распространение информации о компании, ее продукции и услугах; 
формирование благоприятного имиджа фирмы; 
получение от потребителей оперативной информации;
дополнительная рекламная компания – расширить сферу влияния и узнаваемости
Перечень объектов, на которых предполагается использование системы: данную систему предполагается использовать в организации.
	    При внедрении ИС должны быть достигнуты следующие показатели: 
технологические: упрощение процедуры анализа проведенных мероприятий;
экономических: должно быть увеличение количества объемов продаж и предложений на услуги компании.

Характеристика объектов автоматизации
Объектом автоматизации является подача информации, консультация посетителей, техническая поддержка, получение отзывов. 
Пользователями сайта выступают клиенты, заинтересованные в услугах компании.
Требования к условиям эксплуатации и характеристиках окружающей среды отсутствуют.

 Требования к системе
Требования к системе в целом
Разработанная система сайта должна состоять из следующих подсистем: 
доступа к БД MySQL
пользовательского интерфейса
визуализации данных
хранения данных
классов уровня приложения
Подсистема доступа к БД должна позволять легко изменять структуру БД без изменения большей части программы, обеспечить корректную загрузку и выгрузку данных, правильную работу запросов и снижать вероятность ошибок.
Подсистема пользовательского интерфейса должна обеспечивать динамическую сборку страниц, легкость корректировки отдельных частей и отсутствие конфликтов между ними, правильный вывод страниц.
Подсистема визуализации данных должна корректно и визуально привлекательно для пользователя предоставлять информацию.
Структура таблиц БД, каталогов и файлов подсистемы хранения данных должна быть разработана таким образом, что бы легко было найти и изменить хранящуюся в них информацию.
Подсистема классов должна строится таким образом чтобы каждый класс обладал хорошо определённой сферой ответственности. Код должен быть снабжен комментариями и был понятен другому программисту.
В проекте должно быть несколько режимов функционирования. Режим администратора и режим пользователя.
В перспективе развитие системы должно быть легко осуществимо. Возможно добавление новых сервисов.
Требования к персоналу
Для функционирования системы необходим 1 человек: администратор.
Системный администратор должен уметь работать с оболочкой phpMyAdmin, обладать знаниями по web-программированию, в частности на языке php, HTML,CSS.
Требования к системе.
Система должна быть надежной: отказоустойчивой к ошибкам пользователя (нарушения правильной последовательности действий), ошибкам в загружаемых данных. Также система должна восстанавливаться после различных сбоев (отключение электричества, сбой в работе операционной системы, оборудования т т.д.). За данный функционал отвечает сервер MySQL
Программный комплекс должен быть кросс-платформенен, легко мигрировать на разные архитектуры серверов и операционные системы. 
Продукт должен обладать  эргономичным и интуитивно-понятным интерфейсом. Расположение  управляющих элементов и меню должно быть выполнено в привычном стиле. Цветовая гамма оформления должна быть подобрана таким образом, чтобы обеспечить удобочитаемость информации;
Должна быть предусмотрена возможность обновления и обслуживания системы, в том числе и сторонними разработчиками. Возможность расширения функционала приложений.
Требования к функциям
Перечень подлежащих автоматизации задач
Общие функции, доступные всем типам пользователей:
Поиск информации по ключевому слову;
Организация обратной связи;
Возможность выставления рейтинга статьи.
Функции, доступные для Администратора:
Администрирование общих настроек сайта: установка размеров изображений, метаданных ресурса, оформления;
Добавление/редактирование/удаление данных.
Перечень и критерии отказов
В процессе работы с программной системой могут возникать ошибки.
фатальные ошибки – ошибки, в результате которых нарушается нормальная работоспособность ресурса. К ним относятся взломы, ошибки в кодировании;
существенные ошибки – те, в результате которых работоспособность ресурса в целом сохраняется, однако запрос пользователя выполняется некорректно. К ним относится появление на экране сообщений об ошибках в SQL-запросах, перенаправление пользователя на несуществующие страницы;
ошибки средней значимости в виде очевидных ошибок позиционирования элементов дизайна;
несущественные ошибки, в результате появления которых затрудняется восприятие информации. К ним относятся орфографические, пунктуационные, стилистические ошибки текстов, применение неудобочитаемого цвета и размера текста.
Требования к видам обеспечения
К видам обеспечения предъявлены следующие требования:
информативные. Для хранения данных использовать СУБД MySQL, запущенную на удаленном, либо этом же компьютере. Для выполнения скриптов, написанных на языке PHP понадобится интерпретатор PHP. Для управления базами данных phpMyAdmin.
лингвистические. Использовать язык программирования PHP, язык запросов SQL, язык описания HTML, язык разметки CSS, XML. Пользователи взаимодействуют с системой на русском языке по умолчанию;
программному и техническому: 
Характеристики компьютера пользователя: 
операционная система: Windows/Linux/MacOS/Solaris; 
Intel Pentium III/Celeron 800  МГц ; 
оперативная память 256 Мбайт;  
Серверная часть:
операционная система: Windows/Linux/MacOS/Solaris; 
web-сервер «Apache» c поддержкой языка программирования PHP версии 4.1 и выше, БД MySQL версии 4.0 и выше;
Intel Pentium III/Celeron 800  МГц ; 
оперативная память 1Гб; 
жесткий диск с объемом памяти не менее 20Гб;
наличие на сервере возможности использования СУБД MySQL, объем не менее 1 Гб;
желательно наличие phpMyAdmin для администрирования БД;
Необходимый набор программ пользователя:
браузер Internet Explorer/ Opera и др.; 
Необходимый набор программ администратора:
браузер Internet Explorer/ Opera и др.; 
желательно наличие phpMyAdmin для администрирования БД;
текстовый редактор
организационные. Для функционирования системы необходим 1 человек - администратор.
Системный администратор должен уметь работать с оболочкой phpMyAdmin, обладать знаниями по web-программированию, в частности на языке php
		Для обеспечения требуемой надёжности необходимо один раз в месяц производить выгрузку данных из БД и производить резервное копирование данных.
методические.
Инструкция программисту
Инструкция администратору 
Инструкция пользователю

 Состав и содержание работ по созданию системы
Перечень этапов работ и сроки их исполнения приведены в таблице 1.

Таблица 1

 Порядок контроля и приемки системы
Виды, состав, объем и методы испытаний системы
Испытанию должны подвергнуться основные функции и модули системы. Необходимо обеспечить отсутствие MySQL, PHP, JavaScript ошибок при выполнении основных функций. Методы испытания не регламентируются.
Общие требования к приемке работ по стадиям
Каждая стадия работ завершается вводом тестовых данных в рамках соответствующей функциональности. После чего проводятся испытания основных функций реализованного модуля. В случае возникновения критических или серьёзных ошибок необходимо провести исследование системы с целью их устранения.
Статус приемной комиссии
В роли приёмной комиссией выступает руководитель дипломного проекта – Евсеева О.Н. доцент кафедры «Информационные системы».
Исполнитель работы
Работы по созданию проекта проводились - студенткой УлГТУ, Шаныгиной В.В. гр. ИСЭд-52.

Требования к составу и содержанию работ по подготовке объекта автоматизации к вводу системы в действие
Преобразование входной информации к машиночитаемому виду
		Заполнение наиболее важной для функционирования сайта информации будет производиться администраторами. 
Изменения в объекте автоматизации
		Установка сайта на сервер выбранного провайдера возложена на исполнителя проекта.
Сроки и порядок комплектования и обучения персонала
		В обучение персонала нет необходимости, поскольку необходимы лишь базовые представления администратора о функционировании сайтов.

Требования к документированию
Перечень подлежащих разработке документов включает:
Инструкция пользователю
Инструкция программисту
Инструкция системному администратору

Источники разработки
Техническое задание полностью разрабатывается исполнителем на основе предпочтений заказчика. Заказчиком является компания «Новый Стандарт».",0
27,tz_15.docx,"Техническое задание
2.2.1. Общие сведения
Полное наименование программного продукта: «Автоматизированная система учета товарных запасов в рамках розничного магазина».
Наименование предприятий:
разработчик: Почиль Максим Васильевич;
заказчик: ООО «АйТи-Сервис»;
ИС разрабатывается на основе задания на дипломное проектирование;
Плановые сроки начала и окончания работ:
начало: 1.04.2010 г.;
окончание: 31.05.2010 г. 

2.2.2. Назначение и цели создания системы 
Целью создания программного продукта является автоматизация работы по учету товарных запасов в рамках розничного магазина компьютерной техники, работающего преимущественно под заказ.
Задачи:
автоматизировать создание списка товаров для заказа, расчет общей стоимости заказа и формирование счета на оплату;
проводить мониторинг состояния баланса взаиморасчетов между контрагентами;
вести учет товаров на складе в разрезе серийных номеров;
ускорить формирование гарантийного талона (и товарного чека).

2.2.3. Характеристика объектов автоматизации
В настоящий момент значительное число реселлеров, особенно компьютерной техники, для продажи используют ПО поставщика (NIXoft от nix.ru или NL-Dialer от компании Сетевая Лаборатория), что привязывает их к этому поставщику, а расчеты платежного баланса проводят с помощью электронных таблиц. Лидеры Ульяновского рынка обладают модифицированными конфигурациями 1С, но их код сохраняют в тайне.
Данную систему можно внедрить не только у заказчика, но и в любом другом учреждении, продающем товар от разных поставщиков на заказ с гарантией: от магазина бытовой техники до автозапчастей (после небольшой доработки и адаптации).

2.2.4. Требования к системе
Требования к системе в целом 
Программа должна быть разработана на платформе 1С 8.2 и иметь уникальные имена объектов метаданных (планируется объединение со стандартной конфигурацией 1С:Бухгалтерии).
Требования к персоналу
менеджер должен обладать минимальными практическими навыками для корректной работы с программой как пользователь, но довольно обширными теоретическими познаниями в компьютерных областях как эксперт-помощник покупателя.
Для данной системы подходит стандартный уровень безопасности, обеспечиваемый методами парольной аутентификации платформы 1С.
Функциональные требования 
Основные функциональные группы:
подсистема формирования прайс-листа, включающая в себя загрузку прайсов поставщиков, задание товарных наценок и публикацию фирменного прайса;
подсистема заказа товаров, формирующая заказы и счета для оплаты, а так же следящая за платежным балансом;
подсистема складского учета в разрезе серийных номеров, позволяющая принимать, перемещать и списывать товары;
подсистема передачи товара покупателю с оформлением гарантийного талона и товарного чека.
Требования к видам обеспечения 
Программа должна корректно работать на следующем или совместимом с ним оборудовании:
Pentium 4, 1800 MHz и выше;
512 MB RAM.
Программа должна быть работоспособна в любой версии Windows, где установлены 1С 8.2 и Office Excel.

2.2.5. Состав и содержание работ по созданию системы 
Разработка программы должна выполняться по следующим этапам: 
разработка, согласование и утверждение технического проекта программы с пояснительной запиской – с  1.04.2010 по 10.04.2010;
разработка программы – с 11.04.2010 по 15.05.2010; 
прием-сдача с исправлением обнаруженных недостатков в программе и программной документации – 15.05.2010 по 31.05.2010.

2.2.6. Требования к документированию
Состав программной документации должен включать следующие документы: 
1)	технический проект программы по ГОСТ 34.602-89 в машинописном исполнении, содержащий: 
а)	раздел ""ВХОДНЫЕ ДАННЫЕ"" (Характер, организация и предварительная подготовка     входных данных); 
б)	раздел ""ВЫХОДНЫЕ ДАННЫЕ"" (Характер и организация выходных данных); 
в)	раздел ""ОПИСАНИЕ ЛОГИЧЕСКОЙ СТРУКТУРЫ"" при технологии объектно-ориентированного программирования должен включать следующие материалы: 
- описание связей программы с другими программами; 
- описание внутренних массивов и переменных, которые используются в межмодульном обмене данными; 
- схема иерархии классов (Приводится рисунок или рисунки); 
- расшифровка наименований методов и описаний самих методов (Приводится таблица);
г) раздел ""ИСПОЛЬЗУЕМЫЕ ТЕХНИЧЕСКИЕ СРЕДСТВА"" (Типы ЭВМ, на которых возможно выполнение программы; устройства ЭВМ, которые используются при выполнении программы); 
д) раздел ""ВЫЗОВ И ЗАГРУЗКА"" (Виды носителей программы, их используемый объем; способы вызова программы с соответствующих носителей данных; входные точки в программу (запуск программы); 
е) раздел ""ПЛАН МЕРОПРИЯТИЙ ПО РАЗРАБОТКЕ И ВНЕДРЕНИЮ ПРОГРАММЫ"" 
2) описание программы по ГОСТ 19.402-78 на машинном носителе (дискете с маркировкой DESCRIBE), включающее: назначение программы; дата ее создания; Ф.И.О. разработчика, а также данные, позволяющие связаться с ним; минимальные требования к аппаратным ресурсам; руководство пользователя, содержащее описание всех документированных возможностей программы. 
3) текст программы по ГОСТ 19.401-78 на машинном носителе (дискете с маркировкой SOURCE), представленный в виде текстового файла. 
4) руководство программиста по ГОСТ 19.504-79 на машинном носителе (дискете с маркировкой PROG) в виде файла README.TXT, содержащий данные о технологии проектирования и программирования данной программы, а также о языке программирования, назначение программы и список литературы, содержащей теоретический материал, необходимый для создания программы.

2.2.7. Источники разработки 
Работа ведётся на основании задания на дипломное проектирование.",0
9,tz_16.docx,"2.2	Техническое задание
2.2.1	Общие сведения
Полное наименование программного продукта: ""Автоматизация рабочего места менеджера-фармацевта"".
шифр темы – ДП – УлГТУ – 08080165 – 07/704 – 2010 
Наименование предприятий разработчика; 
разработчик: Сарбахтин Артем Анатольевич;
заказчик: УлГТУ;
перечень документов, на основании которых создается информационная система: 1) Разработка ведется на основании приказа на дипломное проектирование от 28.12.2009 № 2202;
Плановые сроки начала и окончания работ – 1 полугодие 2010 г.
порядок оформления и предъявления заказчику результатов работ по созданию системы, ее частей и отдельных средств: по окончанию работ заказчику должны быть предъявлены и переданы установочный диск со всеми необходимыми дистрибутивами, набор инструкций и документации для полноценного функционирования системы.

2.2.2 Назначение и цели создания систем
Разработать программный продукт, позволяющий автоматизировать процессы обработки данных для создания эффективной информационной поддержки деятельности менеджера по продажам медикаментов. 
Цель разработки: повышение эффективности работы и сокращения затрат времени на получение и анализ необходимой информации, а также повысить эффективность деятельности предприятия за счет оперативного предоставления менеджеру предприятия актуальной и аналитической информации.
Назначение разработки:
Обеспечить прозрачность хозяйственных процессов предприятия и оперативность получения аналитической информации.
Ускорить процесс расчета результатов финансовой деятельности предприятия. 

2.2.3 Характеристика объектов автоматизации
Объектом автоматизации является  ООО “ФАРМТРАСТ”. 
2.2.4 Требования к системе
2.2.4.1 Требования к системе в целом 
Требования к персоналу
Программный продукт должен быть ориентирован на пользователя ЭВМ, имеющего начальные навыки работы с ОС Windows и программным продуктом 1С: Предприятие 8.1.
Степень приспособляемости системы
Разрабатываемая конфигурация должна функционировать автономно и допускаются изменения только внутри системы при необходимости. Система должна легко дорабатываться для добавления новых или изменения имеющихся функций. 
Требования к надежности
Надежность и отказоустойчивость системы к ошибкам пользователей и ошибкам загружаемых данных обеспечивают внутренние средства 1С.
Интерфейс системы должен быть эргономичным с точки зрения пользователя. Интерфейсы программных продуктов на базе «1С: Предприятие 8.1» ориентированы на удобную работу и простоту освоения.
Система должна обладать патентной чистотой. Это предполагает использование программы на лицензионных копиях программ «1С: Предприятие».

2.2.4.2 Требования к функциям
 Перечень функций:
ввод и накопление данных о хозяйственных операциях с возможностью их редактирования;
ведение базы поставщиков;
учет медикаментов; 
формирование отчетов.
Перечень критериев и отказов
Фатальные ошибки. Сбои в системе, которые приводят к потере ее работоспособности или к порче данных.
Серьезные ошибки. Ошибки, которые не позволяют достичь желаемого результата при использовании некоторого средства или функции программного продукта, включая невозможность исполнения содержащейся в меню или диалоговом окне команды, выполнения процесса или форматирования текста.
Маленькие ошибки. Ошибки, которые вызывают неудобство работы с системой, например, ошибки в задании порядка перехода от одного элемента управления к другому в форме ввода информации. К данному типу ошибок можно отнести также беспричинные сообщения об ошибках.
Незначительные ошибки. К данному типу ошибок относятся орфографические ошибки в надписях или не выровненные элементы управления.

2.2.4.3 Требования к видам обеспечения:
а) математическому (состав и область применения мат. моделей и методов, типовых и разрабатываемых алгоритмов) особых требований нет;
б) информационному (состав, структура и организация данных, обмен данными между компонентами системы, информационная совместимость со смежными системами, используемые классификаторы, СУБД, контроль данных и ведение информационных массивов)
- необходимость удобной организации данных в системе, их структуризация в соответствии с их семантикой, иерархическая упорядоченность и взаимосвязь;
- для функционирования системы необходимо начальное заполнение информационной базы;
- последующий сбор, обработка данных в системе осуществляется в динамике протекающих бизнес-процессов;
в) лингвистическому (языки программирования, языки взаимодействия пользователей с системой, системы кодирования, языки ввода- вывода) используется язык программирование «1С v8.1»;
г) программному и техническому: 
Для работы с «1С: Предприятием 8.1» рекомендуемая конфигурация компьютера, имеет следующие характеристики: 
1) компьютер конечного пользователя: 
операционная система: MS Windows 2000/ XP / Server 2003; 
процессор Intel Pentium III 866 МГц; 
оперативная память 256 Мбайт; 
2) компьютер, используемый для разработки конфигураций: 
операционная система: MS Windows 2000/ XP / Server 2003; 
Intel Pentium IV 2800 МГц; 
оперативная память 512 Мбайт; 
3) платформа «1С: Предприятие 8.1»; 
е) метрологическому; (нет особых требований)
д) организационному (структура и функции эксплуатирующих подразделений, защита от ошибочных действий персонала); 
(нет особых требований)
е) методическому (состав нормативно-технической документации.
Инструкция для пользователя и программиста;

2.2.5 Состав и содержание работ по созданию системы
2.2.5.1 Перечень стадий и этапов работ. Сроки исполнения
Подробные сроки исполнения проекта представлены в таблице 1
Таблица 
Перечень стадий и этапов работ

2.2.5.2 Состав организаций  исполнителей работ
Работы, по созданию системы, проводились Сарбахтиным Артемом Анатольевичем студентом УлГТУ.
При этом консультантом выступал Шанченко Николай Иванович – УлГТУ, доцент кафедры «Информационные системы», руководитель дипломного проекта.

2.2.5.4 Вид и порядок экспертизы технической документации
Контроль технической документации по графику кафедры.

2.2.6  Порядок контроля и приемки системы
1) Система после завершения разработки передается в опытную эксплуатацию Заказчику с целью тестирования работы системы и ее адекватности поставленным целям.
2) Разработчик по требованию Заказчика дорабатывает систему или отдельные ее части при обнаружении ошибок и в других необходимых случаях.
3) Приемочная комиссия представляется ответственным лицом Заказчика, с которым осуществляется взаимодействие по вопросам разработки системы.

2.2.7 Требования к составу и содержанию работ по подготовке объекта автоматизации к вводу системы в действие
2.2.7.1 Приведение поступающей в систему информации к виду, пригодному для обработки с помощью ЭВМ
Для функционирования системы необходимо определить списковую и условно-постоянную информацию предметной области и ввести ее в информационную базу для многократного использования.
Хозяйственные операции отражаются в информационной системе посредством периодического ввода и проведения документов.
2.2.7.2 Для ввода системы в эксплуатацию необходимо выполнить следующие действия:
- приобретение соответствующих технических средств и их установка;
- установка необходимых программных средств;
- установка системы и ее настройка;
- обучение пользователя.

Требования к документированию
В состав эксплуатационной документации должны входить следующие документы:
Инструкция пользователю
Инструкция программисту

2.2.9  Источники разработки 
Работа ведётся на основании приказа на дипломное проектирование от 28.12.2009 №2202, а также по заказу заказчика – ООО «ФАРМТРАСТ».
Основные источники разработки системы:
- Необходимые документы и отчетность организации-заказчика;
- Отраслевой стандарт 91500.05.0007-2003 ""Правила отпуска (реализации) лекарственных средств в аптечных организациях.
",0
18,tz_17.docx,"2.2 Техническое задание.
2.2.1 Общие сведения.
1) полное наименование системы и ее условное обозначение: «Автоматизация бизнес - проектов на базе 1С ГК «Софт Плюс» средствами 1С: Предприятие 8.1/8.2»; АРМ сотрудника отдела решений (внедрения) на базе 1С  ГК  «Софт Плюс»;
2) шифр темы или шифр (номер договора): данный программный продукт разрабатывался вне рамок какого-либо договора;
3) наименование предприятий разработчика и заказчика системы, их реквизиты:
 ГК «Софт Плюс», 432071, Ульяновская обл, г. Ульяновск, улица Карла Маркса, дом № 13а, корпус 2,  кв.710.;
4) перечень документов, на основании которых создается информационная система:
1.Устав Общества с ограниченной ответственностью ""СКС"";
5) плановые сроки начала и окончания работ: 29 марта 2010 года – 7 мая 2010 года;
6) сведения об источниках и порядке финансирования работ: данные работы проводятся на некоммерческой основе;
7) порядок оформления и предъявления заказчику результатов работ по созданию системы, ее частей и отдельных средств: по окончанию работ заказчику должны быть предъявлены и переданы установочный диск со всеми необходимыми дистрибутивами, набор инструкций и документации для полноценного функционирования системы.

2.2.2 Назначение и цели создания системы
Разработанная система призвана автоматизировать процессы отдела решений (внедрения) на базе 1С.  Цель разработки – повышение оперативности и качества процессов, существующих в ОР.
При внедрении данной системы должны быть следующие показатели:
технические: показателей нет;
технологические: уменьшение числа этапов выполнения операций, связанных с выводом нужной, оперативной информации;
производственно-экономические: должно быть сокращено время на процессы, связанные с учетом заявок и анализом загруженности специалистов, значительно облегчен труд диспетчера отдела.

2.2.3 Характеристика объектов автоматизации
	Объектом автоматизации является отдел решений (внедрения) ГК «Софт Плюс». Основные функции отдела автоматизированы.

2.2.4 Требования к системе в целом
2.2.4.1 Требования к структуре и функционированию системы
	Система должна обеспечивать выполнение перечисленных ниже функций:
добавление новой учетной  документации;
хранение данных за различные отчетные периоды;
редактирование и удаление существующей учетной документации;
формирование отчетной документации.

2.2.4.2 Требования к персоналу
	Для функционирования системы необходим сотрудник отдела решений (внедрения) на базе 1С. Он должен обладать навыками работы с программой на базе платформы 1С: Предприятие 8.1, которые позволят ему фиксировать все операции и быстро получать необходимую информацию, а также должен знать регламенты принятия заявок по телефонным звонкам внутри отдела, месячного и позадачного планирования загрузки специалистов ОР (регламенты приведены в приложении).
2.2.4.3 Степень приспособляемости системы
	Система должна легко дорабатываться для добавления новых или изменения имеющихся функций.

2.2.4.4 Требования к надежности
	Надежность и отказоустойчивость системы к ошибкам пользователей и ошибкам загружаемых данных обеспечивают внутренние средства 1С.
	Интерфейс системы должен быть эргономичным с точки зрения пользователя. Интерфейсы программных продуктов на базе «1С:Предприятие 8.1» ориентированы на удобную работу и простоту освоения.
	Система должна обладать патентной чистотой. Это предполагает использование программы на лицензионных копиях программ «1С:Предприятие».
	Должен быть предусмотрен режим раздельной работы с конфигурацией нескольких пользователей. Для этого необходимо, чтобы при входе в конфигурацию присутствовала авторизация и аутентификация пользователей, а значит, каждый пользователь должен иметь свой прописанный в конфигурации набор прав.

2.2.5 Требования к функциям
2.2.5.1 Перечень подлежащих автоматизации задач
	Для системы должны быть реализованы следующие возможности:
Учет по ЛУСВ;
Контроль загруженности исполнителей;
Учет и контроль обновлений ПО;
Контроль исполнения заявок ;
Проверка эффективности - СМК;
Формирование План - Факта отработки по клиентам;
Формирование отчетности по ЛУСВ сотрудников подразделения.

2.2.5.2 Перечень критериев и отказов
	Фатальные ошибки. Сбои в системе, которые приводят к потере ее работоспособности или порче данных. При работе с системой фатальные ошибки не обнаружены.  
	Серьезные ошибки. Ошибки, которые не позволяют достичь желаемого результата при использовании некоторого средства или функции программного продукта, включая невозможность исполнения содержащейся в меню или диалоговом окне команды, выполнения процесса или формирования текста. Серьезных ошибок не обнаружено.
	Маленькие ошибки. Ошибки, которые вызывают неудобство работы с системой, например, ошибки в задании порядка перехода от одного элемента управления к другому в форме ввода информации. К данному типу ошибок можно отнести также беспричинные сообщения об ошибках.
В документе «Проект» не формировалась печатная форма;
Не проводился документ «Отмена ЛУСВ»;
При открытии созданного документа «Проект» выдавалось предупреждение «Разрешен только просмотр документа!» .
В результате внесенных изменений в конфигурацию – данные ошибки исправлены.
	Незначительные ошибки. К данному типу ошибок относятся орфографические ошибки в надписях или не выровненные элементы управления.  При работе с ИС были выявлены орфографические ошибки, которые в дальнейшем были исправлены.

2.2.6 Требования к видам обеспечения
	Система предъявляет следующие требования к видам обеспечения:
	а) математическому:  к пользователю конфигурации не предъявляется особых требований в области математического анализа;
	б) информационному: конфигурация доступна для использования только при установленной платформе «1С: Предприятие 8.1», которая в свою очередь рекомендуется к использованию совместно с операционной системой Windows 98/2000/XP/Vista/7.
	в) лингвистическому: для написания модулей конфигурации использовался встроенный язык системы 1С: Предприятие 8.1. Изменением конфигурации рекомендуется заниматься только специалистам, владеющим этим языком.
	г) программному и техническому: для работы с «1С:Предприятием 8.1» рекомендуемая конфигурация компьютера  имеет следующие характеристики:
	1) компьютер конечного пользователя:
		a) операционная система: MS Windows 2000 / XP / Server 2003;
		b) процессор Intel Pentium III 866 МГц;
		c) оперативная память 256 Мбайт.
	2) компьютер, используемый для разработки конфигураций:
		a) операционная система: MS Windows 2000 / XP / Server 2003;
		b) процессор Intel Pentium IV/Celeron 1800 МГц;
		c) оперативная память 512 Мбайт.
	3) сервер «1С:Предприятие 8.0»:
		a) операционная система: MS Windows 2000 / XP / Server 2003;
		b) процессор Intel Pentium IV/Xeon 2,4 ГГц;
		c) оперативная память 1024 Мбайт.
	Из программных средств необходимы: платформа «1С:Предприятие 8.1».
	д) метрологическому: нет требований к данному виду обеспечения.
	е) организационному: для функционирования системы необходим один человек.  При работе с конфигурацией сразу нескольких пользователей существует требование каждому пользователю входить в информационную базу только со своими правами.
	ж) методическому (состав нормативно-технической документации):
		a) инструкция программисту;
		b) инструкция пользователю;	

2.2.7 Перечень этапов работ и сроки исполнения.
	Перечень этапов работ и сроки исполнения представлены в таблице 1.
Таблица 1
Перечень этапов работ и сроки исполнения

2.2.8 Состав исполнителей работ
Работы по созданию системы проводились физическим лицом, Саржановым Робертом  студентом УлГТУ. При этом консультантами выступали:
	а) Меркулова Тамара Алексеевна – УлГТУ, доцент кафедры «Информационные системы», руководитель дипломного проекта.
	б) Миронов Владимир Валерьевич – руководитель отдела решений (внедрения) ГК  «Софт Плюс».

2.2.9 Порядок контроля системы
Для контроля необходимо провести следующие виды тестирования:
	Функциональное тестирование. Оно включает проверку каждой команды меню, панели инструментов и каждой операции, которую выполняет система.
	Тестирование приложения. При выполнении тестирования приложения испытатель моделирует действия пользователя. Воспроизводя различные комбинации действий, можно найти ошибки, относящиеся к интеграции компонентов, а также недоработки, которые не были обнаружены при функциональном тестировании.
	Тестирование на скорость выполнения. Измеряется время отклика системы на некоторое действие, документа. Обычно при этом определяются параметры эффективности. Одновременно с измерением времени на выполнение запроса записать также размер базы данных.
Тест на скорость выполнения задач пройден успешно (проведение документов при объеме 10 строк, формирование отчетов – составило менее 3-х секунд).
	Все этапы тестирования программы проводились непосредственным разработчиком Саржановым Робертом Рамисовичем.

2.2.10 Требования к составу и содержанию работ по подготовке объекта автоматизации к вводу системы в действие
Для ввода системы в эксплуатацию необходимо провести обучение персонала с программой с использованием всех ее возможностей: руководителя отдела решений (внедрений) и диспетчера – 2 академических часа.
	Необходимо дополнить во внедряемой системе справочники.

2.2.11 Перечень подлежащих разработке документов
	- регламент по  принятию заявок  от клиента в отделе решений (внедрения)  на базе 1С;
- регламент месячного и позадачного планирования загрузки специалистов ОР;
	- инструкция администратору;
- инструкция пользователю;
	- презентация программного продукта.",0
23,tz_18.docx,"2.2. Техническое задание
Общие сведения:
Полное наименование системы: Система хранения и визуализации информационных потоков сотовой компании «МегаФон».
Шифр темы: ДП-УлГТУ-08080165-05/1039-2010
Наименование предприятия заказчика системы: УРО ПФ ООО «МегаФон».
Перечень документов, на основании которых создается информационная система: инструкция инженера по ремонту и обслуживанию БТС и ТС УРО ПФ ООО «МегаФон».
Плановые сроки начала работ: 1 февраля . Плановые сроки окончания работ: 15 июня .

Назначение и цели создания системы
Назначение системы. Система предназначена для хранения и визуального представления данных о соединениях между РРС сотовой сети УРО ПФ ООО «МегаФон».
Цели создания системы. Основными целями создания системы являются:
Замещение существующей системы, которая не представляет возможности комплексного обеспечения процессов, описанных выше. Действующая информационная система является устаревшей, так как хранение данных ведется частично на бумажных носителях, частично в среде графической обработки, не предназначенной непосредственно для специалистов по обслуживанию базовых станций.
Повышение скорости получения необходимой информации. Все данные должны храниться в единой системе, доступ к ним должен увеличиться, поскольку поиск и структурирование информации возлагается на вычислительную машину.
Стандартизация хранения информации о соединениях РРС на уровне регионального отделения. База данных будет оставаться неизменной, независимо от того, какой инженер с ней работает.

Характеристика объекта автоматизации.
Объектом автоматизации является деятельность инженеров по обслуживанию базовых станций и транспортных сетей. В настоящий момент в УРО ПФ ООО «МегаФон» используются следующие информационные системы:
Microsoft Excel. Отчеты и перечни оборудования хранятся в электронных книгах Excel.

Требования к системе.
Требования к системе в целом.
Требования к структуре и функционированию системы
Перечень подсистем, их назначение и основные характеристики. В состав программного продукта должны входить следующие подсистемы:
подсистема хранения данных – предназначена для хранения данных о соединениях РРС;
подсистема формирования отчета – предназначена для создания отчетов.

Требование к численности и квалификации персонала системы.
Для эксплуатации системы необходим только пользователь, являющийся инженером по обслуживанию базовых станций сотовой связи. Пользователь должен обладать следующими навыками:
опыт работы с персональным компьютером на базе операционных систем Microsoft Windows;
знания принципа работы сетей сотовой связи;
опыт работы с электронными книгами Microsoft Excel.

Требования к надежности.
Система должна сохранять работоспособность и обеспечивать восстановление своих функций при возникновении следующих внештатных ситуаций:
при сбоях в системе электроснабжения аппаратной части, приводящих к перезагрузке ОС, восстановление программы должно происходить после перезапуска ОС и запуска исполняемого файла системы;
при ошибках в работе аппаратных средств (кроме носителей данных и программ) восстановление функции системы возлагается на ОС;
при ошибках, связанных с программным обеспечением (ОС и драйверы устройств), восстановление работоспособности возлагается на ОС.
Для защиты аппаратуры от бросков напряжения и коммутационных помех должны применяться сетевые фильтры.

Требования к безопасности.
Все внешние элементы технических средств системы, находящиеся под напряжением, должны иметь защиту от случайного прикосновения, а сами технические средства иметь зануление или защитное заземление в соответствии с ГОСТ 12.1.030-81 и ПУЭ.
Система электропитания должна обеспечивать защитное отключение при перегрузках и коротких замыканиях в цепях нагрузки, а также аварийное ручное отключение.
Общие требования пожарной безопасности должны соответствовать нормам на бытовое электрооборудование. В случае возгорания не должно выделяться ядовитых газов и дымов. После снятия электропитания должно быть допустимо применение любых средств пожаротушения. 
Факторы, оказывающие вредные воздействия на здоровье со стороны всех элементов системы (в том числе инфракрасное, ультрафиолетовое, рентгеновское и электромагнитное излучения, вибрация, шум, электростатические поля, ультразвук строчной частоты и т.д.), не должны превышать действующих норм (СанПиН 2.2.2./2.4.1340-03 от 03.06.2003 г.).

Требования к эргономике и технической эстетике.
Взаимодействие пользователей с прикладным программным обеспечением, входящим в состав системы должно осуществляться посредством визуального графического интерфейса (GUI). Интерфейс системы должен быть понятным и удобным, не должен быть перегружен графическими элементами и должен обеспечивать быстрое отображение экранных форм. Навигационные элементы должны быть выполнены в удобной для пользователя форме. Средства редактирования информации должны удовлетворять принятым соглашениям в части использования функциональных клавиш, режимов работы, поиска, использования оконной системы. Ввод-вывод данных системы, прием управляющих команд и отображение результатов их исполнения должны выполняться в интерактивном режиме. Интерфейс должен соответствовать современным эргономическим требованиям и обеспечивать удобный доступ к основным функциям и операциям системы.
Интерфейс должен быть рассчитан на преимущественное использование манипулятора типа «мышь», то есть управление системой должно осуществляться с помощью набора экранных меню, кнопок, значков и т. п. элементов. Клавиатурный режим ввода должен использоваться главным образом при заполнении и/или редактировании текстовых и числовых полей экранных форм.
Все надписи экранных форм, а также сообщения, выдаваемые пользователю (кроме системных сообщений) должны быть на русском языке. Система должна обеспечивать корректную обработку аварийных ситуаций, вызванных неверными действиями пользователей, неверным форматом или недопустимыми значениями входных данных. В указанных случаях система должна выдавать пользователю соответствующие сообщения, после чего возвращаться в рабочее состояние, предшествовавшее неверной (недопустимой) команде или некорректному вводу данных. Экранные формы должны проектироваться с учетом требований унификации:
все экранные формы пользовательского интерфейса должны быть выполнены в едином графическом дизайне, с одинаковым расположением основных элементов управления и навигации;
для обозначения сходных операций должны использоваться сходные графические значки, кнопки и другие управляющие (навигационные) элементы. Термины, используемые для обозначения типовых операций (добавление информационной сущности, редактирование поля данных), а также последовательности действий пользователя при их выполнении, должны быть унифицированы;
внешнее поведение сходных элементов интерфейса (реакция на наведение указателя «мыши», переключение фокуса, нажатие кнопки) должны реализовываться одинаково для однотипных элементов.
Система должна соответствовать требованиям эргономики и профессиональной медицины при условии комплектования высококачественным оборудованием (ПЭВМ, монитор и прочее оборудование), имеющим необходимые сертификаты соответствия и безопасности Росстандарта.

Требования к функциям, выполняемым системой
хранение структурированной информации обо всех соединениях РРС, принадлежность РРС к базовым станциям сотовой сети;
графическое и текстовое представление данных о соединениях каналов РРС, находящихся на одной БС;
расположение базовых станций на карте;
отображение на карте соединений между РРС, находящимися на различных БС;
отображение принадлежности РРС к конкретной БС;
предоставление информации обо всех станциях, передающих информационный поток;

Требования к видам обеспечения:
Требования к информационному обеспечению системы. В состав системы должны входить возможности аварийного сохранения данных при возникновении исключительных ситуаций в работе программы.

Требования к лингвистическому обеспечению системы.
Интерфейс программного обеспечения должен иметь русский язык, исключением являются наименования оборудования, которое приводится на английском языке.

Требования к программному обеспечению системы.
Базовой программной платформой должна являться операционная система Microsoft Windows. Необходимо осуществлять выгрузку отчетов в электронные книги Microsoft Excel. Система должна использовать платформу Microsoft .NET Framework версии 2.0 и выше.

Требования к техническому обеспечению системы
IBM PC-совместимый компьютер;
процессор – Pentium 200 МГц и выше;
объем оперативной памяти – 128 Мб и выше;
свободного места на жестком диске – 200 Мб.

Требования к организационному обеспечению системы.
К работе с системой должны допускаться сотрудники компании, обладающие навыками работы с персональным компьютером, ознакомленные с правилами эксплуатации, специалисты в области обслуживания базовых станций и прошедшие обучение работе с системой.

Состав и содержание работ по созданию системы.
Перечень стадий и этапов работ со сроками исполнения:
1 февраля . – 28 марта . Сбор фактического материала, обзор состояния вопроса и анализ предметной области;
29 марта . – 11 апреля . Систематизация материала. Описание бизнес-процессов, формулировка постановки задачи, подготовка обзора состояния вопроса;
12 апреля . – 25 апреля . Проектирование предметно-ориентированной информационной системы;
26 апреля . – 30 мая . Разработка предметно-ориентированной информационной системы;
31 мая . – 13 июня . Оформление проекта;

Требования к составу и содержанию работ по подготовке объекта автоматизации к вводу системы в действие.
При подготовке к вводу в эксплуатацию системы заказчик должен обеспечить выполнение следующих работ:
определить подразделение и должностных лиц, ответственных за внедрение и проведение опытной эксплуатации системы;
обеспечить присутствие пользователей на обучении работе с системой, проводимом исполнителем;
обеспечить соответствие помещений и рабочих мест пользователей системы в соответствии с требованиями, изложенными в настоящем ТЗ;
обеспечить выполнение требований, предъявляемых к программно-техническим средствам, на которых должно быть развернуто программное обеспечение системы;
совместно с исполнителем подготовить план развертывания системы на технических средствах заказчика;
провести опытную эксплуатацию системы.

Требования к документированию
Информационная система должна сопровождаться следующей документацией:
инструкция пользователя;
инструкция программиста.

Источники разработки
инструкция инженера по ремонту и обслуживанию БТС и ТС УРО ПФ ООО «МегаФон».",0
24,tz_19.docx,"2.2. Техническое задание
2.2.1. Наименование программы
Автоматизированная система (АС) «Обеспечение безопасного доступа к конфеденциальной информации».

2.2.2. Основания для разработки
К основным документам, на основании которых ведется разработка ИС относятся:
Заявка Операционного отдела Банка на разработку программного продукта, средствами которого клиентам предоставляется информация о текущем состоянии их банковских счетов.
 Внутреннее положение Банка «О порядке разработки средств для доступа сторонних лиц к информации, относящейся к коммерческой тайне».
Приказ на дипломное проектирование №

2.2.3. Плановые сроки начала и окончания работ
Начало работы – 1 апреля 2010 года.
Окончание работы – 14 июня 2010 года.

2.2.4. Назначение и область применения
АC  «Обеспечение безопасного доступа к конфеденциальной информации» предназначена для безопасного доступа клиента к БД, с целью получения сведений о состоянии своего банковского счёта.
Область применения АС – Банк в целом, для предоставления удобной услуги клиенту. 

2.2.5. Цели
Увеличение скорости и количества способов получения информации.
Снижение трудозатрат.
Привлечение клиентов.

2.2.6. Требования к системе в целом
Требования к структуре и функционированию системы.
Программный продукт «Обеспечение безопасного доступа к конфеденциальной информации» должен быть разработан в среде Visual Studio 2005. 
Функционирование подсистемы должно осуществляться на английском языке.
Удобный и интуитивно понятный интерфейс - взаимодействие с пользователем осуществляется с помощью окон  и стандартных средств  ввода-вывода информации – клавиатуры и мыши. 
Возможность различных настроек системы.
Предусмотрено наличие двух ролей: а) системный администратор; б) клиент.
Возможность предоставления отчетов.

Требования к персоналу.
           Конечный пользователь программы должен обладать практическими навыками работы с  пользовательским интерфейсом операционной системы Windows, а также навыками работы с разработанным программным продуктом.

Требования к надежности.
Использование лицензионного программного обеспечения.
Надежность работы программного продукта обеспечивается бесперебойным питанием технических средств.

Требования к защите и сохранности информации.
Предусмотрена аутентификация пользователя. При запуске программы пользователю предлагается ввести имя и пароль, что позволяет исключить несанкционированный доступ к системе.
Предусмотрено администрирование. Работа администратора заключается в:
разграничении прав доступа к АС;
резервное копирование информационной базы.

2.2.7. Требования к функциям
Работа с базой данных:
ввод информации о клиенте в БД;
хранение данных за различные отчетные периоды;
возможность редактирования данных.  
Работа с серверной частью программы:
доступ к функциям программы;
возможность настройки прав доступа.
Работа с клиентской частью:
возможность вводить требуемую информацию;
обеспечение безопасного просмотра информации.

2.2.8. Требования к видам обеспечения
Требования к информационному обеспечению.
Состав исходных данных. В качестве исходных данных используются числовые, буквенные и символьные данные, необходимые для заполнения форм клиентской части, также использутся выгружаемые БД с информацией в виде таблиц, в которых хранятся конфеденциальные данные о клиентах.
Состав выходных данных. Выходные данные содержат числовую информацию в виде значений, сумм, отчетов, содержащих текст и числа.
Требования к программному обеспечению.
Системные программные средства, используемые программой, должны быть представлены лицензионными  версиями:
операционной системы MS Windows;
Visual Studio 2005 или более новая версия.
Требования к техническому обеспечению.
Минимальные системные требования к оборудованию: 
процессор Pentium  3 и выше;
оперативная память объемом не менее 256 Мегабайт;
свободное пространство на жестком диске не менее 10Мегабайт.

2.2.9. Требования к документированию
Должны быть разработаны:
Пояснительная записка.
Руководство программиста.
Инструкция пользователя.	",0
10,tz_20.docx,"2.2. Техническое задание
2.2.1. Общие сведения
Полное наименование программного продукта: Анализатор запросов.
Наименование разработчика и заказчика:
разработчик: Субхангулов Руслан Айратович;
заказчик: Наместников Алексей Михайлович;
ИС разрабатывается на основе задания на дипломное проектирование;
Плановые сроки начала и окончания работ:
начало: 1.04.2010 г.;
окончание: 31.05.2010 г. 

2.2.2. Назначение и цели создания системы 
Целью создания программного продукта является предоставление удобного интерфейса пользователю для формирования запросов (в том числе нечетких запросов) на языке XQuery к XML Server Tamino.
Задачи:
клиент-серверное приложение;
возможность быстро создать запрос  и получить имеющиеся данные;
представление информации в удобной пользователю форме;
защита от некорректных действий пользователей системы.

2.2.3. Характеристика объектов автоматизации
Данную систему можно внедрять в крупные коммерческих организациях, задавших целью получать не только оперативную информацию о своей деятельности, но и информацию прошлых периодов с последующим анализом, для принятие управленческих решений.

2.2.4. Требования к системе
Требования к системе в целом 
Информационная система должна являться клиент-серверным приложением, поэтому она будет распределенной, база данных располагается на XML сервере, доступ к которой осуществляется с помощью клиентской части.
Такая структура позволяет быстро осуществить доступ к необходимым данным благодаря особенностям работы XML сервера.
Требования к персоналу: пользователь данной системы должен обладать минимальными знаниями в компьютерной области для корректной работы с программой.
Функциональные требования 
Основные функции:
ввод, редактирование, чтение и удаление лингвистических перемен;
обращения к базе данных по средствам запросов;
представление данных;
механизм транзакций.
Требования к видам обеспечения 
Программа должна корректно работать на следующем или совместимом с ним оборудовании:
Pentium 450 и выше;
128 MB RAM.
Программа должна быть разработана на языке С# в среде разработки Visual Studio 2005.

2.2.5. Состав и содержание работ по созданию системы 
Разработка программы должна выполняться по следующим этапам: 
разработка, согласование и утверждение технического проекта программы с пояснительной запиской – с  1.04.2010 по 10.04.2010;
разработка программы – с 11.04.2010 по 15.05.2010; 
прием-сдача с исправлением обнаруженных недостатков в программе и программной документации – 15.05.2010 по 31.05.2010.

2.2.6. Требования к документированию
Состав программной документации должен включать следующие документы: 
1)	технический проект программы по ГОСТ 34.602-89 в машинописном исполнении, содержащий: 
а)	раздел ""ВХОДНЫЕ ДАННЫЕ"" (Характер, организация и предварительная подготовка     входных данных); 
б)	раздел ""ВЫХОДНЫЕ ДАННЫЕ"" (Характер и организация выходных данных); 
в)	раздел ""ОПИСАНИЕ ЛОГИЧЕСКОЙ СТРУКТУРЫ"" при технологии объектно-ориентированного программирования должен включать следующие материалы: 
- описание связей программы с другими программами; 
- описание внутренних массивов и переменных, которые используются в межмодульном обмене данными; 
- схема иерархии классов (Приводится рисунок или рисунки); 
- расшифровка наименований методов и описаний самих методов (Приводится таблица);
г) раздел ""ИСПОЛЬЗУЕМЫЕ ТЕХНИЧЕСКИЕ СРЕДСТВА"" (Типы ЭВМ, на которых возможно выполнение программы; устройства ЭВМ, которые используются при выполнении программы); 
д) раздел ""ВЫЗОВ И ЗАГРУЗКА"" (Виды носителей программы, их используемый объем; способы вызова программы с соответствующих носителей данных; входные точки в программу (запуск программы); 
е) раздел ""ПЛАН МЕРОПРИЯТИЙ ПО РАЗРАБОТКЕ И ВНЕДРЕНИЮ ПРОГРАММЫ"" 
2) описание программы по ГОСТ 19.402-78 на машинном носителе (дискете с маркировкой DESCRIBE), включающее: назначение программы; дата ее создания; Ф.И.О. разработчика, а также данные, позволяющие связаться с ним; минимальные требования к аппаратным ресурсам; руководство пользователя, содержащее описание всех документированных возможностей программы. 
3) текст программы по ГОСТ 19.401-78 на машинном носителе (дискете с маркировкой SOURCE), представленный в виде текстового файла. 
4) руководство программиста по ГОСТ 19.504-79 на машинном носителе (дискете с маркировкой PROG) в виде файла README.TXT, содержащий данные о технологии проектирования и программирования данной программы, а также о языке программирования, назначение программы и список литературы, содержащей теоретический материал, необходимый для создания программы.

2.2.7. Источники разработки 
Работа ведётся на основании задания на дипломное проектирование.",0
32,"Архитектура, управляемая модель.docx","Архитектура, управляемая модель
Аббревиатура MDA расшифровывается как Model Driven Architecture архитектура, управляемая моделью. MDA это архитектура, описывающая новый способ разработки программного обеспечения. Название говорит само за себя очевидно, что в рамках этой архитектуры создание приложений базируется на разработке модели приложения. 
В основе новой архитектуры лежит идея о полном разделении этапов общего проектирования (моделирования) и последующей реализации приложения на конкретной программной платформе. Идея эта не нова: сначала при помощи специальных средств проектирования создается общая и независимая от способов реализации модель приложения, а затем осуществляется реализация программы в какой-либо среде разработки. При этом процесс разработки полностью основан на модели, которая должна содержать всю необходимую для программирования информацию. Очевидны преимущества, которые дает такой подход:
Независимость модели от средств разработки обеспечивает возможность реализации на любой программной платформе. 
Приложение, реализованное в архитектуре MDA, может быть легко перенесено из одной операционной системы в другую. 
Существенна экономия ресурсов при реализации приложения для нескольких программных платформ одновременно. 
Архитектура позволяет до известной степени автоматизировать процесс программирования. Наличие подробной модели обеспечивает автоматическое создание типовых частей приложения, разработка которых поддается автоматизации. Например, создание пользовательского интерфейса, программирование типовых операций, создание базы данных и организация доступа к данным.
Архитектура MDA возникла не на пустом месте. Само ее появление и возможность реализации обусловило наличие ряда стандартов и технологий, на практике доказавших свою полезность. Концептуальной основой появления MDA стали спецификации OMA, ORB, CORBA. Перевести замысел в практическую плоскость позволили технологии объектно-ориентированного программирования (ООП), стандарт CWM, языки UML, XML, MOF. Работами по созданию новой архитектуры программирования занялся консорциум OMG (Object Management Group)*. 
По мнению создателей, архитектура MDA является новым витком эволюции технологий программирования, так как описывает процесс разработки в целом. Подготовленные читатели с высшим техническим образованием могут возразить, что процесс разработки программного обеспечения описан и стандартизован вдоль и поперек: в нашей стране существует ряд ГОСТов, другие страны также имеют соответствующие стандарты. Но новизна MDA заключается в том, что описание процесса разработки в ней выполнено с использованием современных средств представления и позволяет автоматизировать создание приложений. И весьма вероятно, что через некоторое время архитектура MDA станет общим промышленным стандартом в разработке программного обеспечения. 

Основные понятия
Прежде чем перейти к описанию собственно архитектуры, необходимо привести некоторые общие термины и определения. 
Модель описание или спецификация системы и ее окружения, созданная для определенных целей. Часто является комбинацией текстовой и графической информации. Текст может быть описан специализированным или естественным языком. 
Управление на основе модели процесс разработки системы, использующий модель для понимания, конструирования, распространения и других операций. 
Платформа набор подсистем и технологий, которые представляют собой единый набор функциональности, используемой любым приложением без уточнения деталей реализации. 
Вычислительная независимость качество модели, обозначающее отсутствие любых деталей структуры и процессов. 
Платформенная независимость качество модели, обозначающее ее независимость от свойств любой платформы. 
Вычислительно-независимая модель модель, скрывающая любые детали реализации и процессов системы; описывает только требования к системе и ее окружению. 
Платформенно-независимая модель модель, скрывающая детали реализации системы, зависимые от платформы, и содержащая элементы, не изменяющиеся при взаимодействии системы с любой платформой. 
Платформенно-зависимая модель модель системы с учетом деталей реализации и процессов, зависимых от конкретной платформы. 
Модель платформы набор технических характеристик и описаний технологий и интерфейсов, составляющих платформу. 
Преобразование модели процесс преобразования одной модели системы в другую модель той же системы. 

Архитектура разработки приложений на основе моделей
Что такое архитектура, управляемая моделью (MDA)? Архитектура MDA описывает и структурирует поэтапный процесс разработки любых программных систем на основе создания и использования моделей. При этом используется несколько типов моделей, создаваемых и преобразуемых на различных этапах разработки. Процесс разработки по MDA это последовательное (поэтапное) продвижение от одной модели системы к другой. При этом каждая последующая модель преобразуется из предыдущей и дополняется новыми деталями. Модели, общая схема разработки и процесс преобразования моделей ключевые составные части архитектуры. 

Типы моделей
Рассмотрим типы моделей, используемых в архитектуре MDA. 
Вычислительно-независимая модель (Computation Independent Model, CIM) описывает общие требования к системе, словарь используемых понятий и условия функционирования (окружение). Модель не должна содержать никаких сведений технического характера, описаний структуры и функционала системы. CIM максимально общая и независимая от реализации системы модель. Спецификация MDA подчеркивает, что CIM должна быть построена так, чтобы ее можно было преобразовать в платформенно-независимую модель. Поэтому CIM рекомендуется выполнять с использованием унифицированного языка моделирования UML. 
Платформенно-независимая модель (Platform Independent Model, PIM) описывает состав, структуру, функционал системы. Модель может содержать сколь угодно подробные сведения, но они не должны касаться вопросов реализации системы на конкретных платформах. Модель PIM создается на основе CIM. Для создания модели используется унифицированный язык моделирования UML. 
Платформенно-зависимая модель (Platform Specific Model, PSM) описывает состав, структуру, функционал системы применительно к вопросам ее реализации на конкретной платформе. В зависимости от назначения модель может быть более или менее детализированной. Модель создается на основе двух моделей. Модель PIM служит основой модели PSM. Модель платформы используется для доработки PSM в соответствии с требованиями платформы. 
Модель платформы описывает технические характеристики, интерфейсы, функции платформы. Зачастую модель платформы представлена в виде технических описаний и руководств. Модель платформы используется при преобразовании модели PIM в модель PSM. Для целей MDA описание модели платформы должно быть представлено на унифицированном языке моделирования UML. 

Уровни модели
В зависимости от уровня детализации платформы, модели (кроме модели платформы) могут содержать сведения о различных функциональных частях системы. В этом случае говорят об уровнях модели. Обычно различают следующие основные уровни модели. 
Уровень бизнес-логики содержит описание основного функционала приложения, обеспечивающего исполнение его назначения. Как правило, уровень бизнес-логики хуже всего поддается автоматизации. Он составляет львиную долю кода приложения, который приходится писать вручную. 
Уровень данных описывает структуру данных приложения, используемые источники, форматы данных, технологии и механизмы доступа к данным. Для приложений .NET чаще всего используются возможности ADO.NET. 
Уровень пользовательского интерфейса описывает возможности приложения по взаимодействию с пользователями, а также состав форм приложения, функционал элементов управления (например, контроль ввода данных). Легкость автоматизации этого уровня зависит от того, насколько унифицированы пользовательские операции. Если удается создать типовые шаблоны элементов управления для основных операций, появляется возможность автоматической генерации форм и их содержимого при создании приложения из модели. 

Этапы разработки
Процесс разработки разбивается на три этапа. На первом этапе разрабатывается вычислительно-независимая модель (CIM). Часто модель, создаваемую на этом этапе, также называют доменной или бизнес-моделью. Цель данного этапа разработка общих требований к системе, создание общего словаря понятий, описание окружения, в котором система будет функционировать. Сущности, описываемые в модели CIM этого этапа, должны тщательно анализироваться и отрабатываться. Право на включение в модель должны иметь только те элементы, которые будут использованы и развиты на последующих этапах разработки. Для создания модели CIM на данном этапе можно использовать любые средства. Однако для совместимости с последующими этапами весьма желательно иметь описание модели на языке UML. Следует учитывать, что модель CIM первого этапа представляет собой скорее общую концепцию системы и не является насущно необходимой для процесса разработки приложения. При создании небольших программных систем этот этап можно опустить, однако при работе со сложными проектами он становится почти обязательным. К примеру, разработка текстового технического задания, казалось бы, никак не помогает собственно процессу программирования, зато, существенно способствует пониманию задачи в целом и позволяет избежать грубых ошибок проектирования в дальнейшем. На втором этапе разрабатывается платформенно-независимая модель (PIM). Она может разрабатываться с нуля в случае отсутствия модели первого этапа или основываться на CIM. Преобразование CIM в PIM осуществляется на основе описания на зыке UML, созданного на первом этапе. Здесь в него добавляются элементы, описывающие бизнес-логику, общую структуру системы, состав и взаимодействие подсистем, распределение функционала по элементам, общее описание и требования к пользовательскому интерфейсу. Модель PIM этого этапа обязательно включается во все автоматизированные среды разработки приложений на основе MDA. 
На третьем этапе создаются платформенно-зависимые модели (PSM). Их число соответствует числу программных платформ, на которых будет функционировать приложение. Кроме этого, возможны случаи, когда приложение (или его составные части) должны работать на нескольких платформах одновременно. Модель PSM создается путем преобразования модели PIM с учетом требований модели платформы. Процесс преобразования описывается ниже. На этапе создания модели PSM разработка приложения согласно архитектуре MDA заканчивается. Считается, что правильно построенная PSM содержит техническую информацию, достаточную для генерации исходного кода (там, где это возможно) и необходимых ресурсов приложения. Здесь эстафетную палочку должна подхватить среда разработки, реализующая MDA. В нашем случае Delphi 9 обеспечивает генерацию кода и компиляцию приложений ECO. С формальной точки зрения это уже не относится к компетенции MDA, но для разработчика преобразование PSM в исполняемый код приложения непосредственное продолжение процесса разработки. Однако, архитектура MDA описывает еще один вариант прохождения третьего этапа, который называется прямым преобразованием в код. Спецификация MDA для этого случая сообщает, что могут существовать инструментарии, напрямую преобразующие модель PIM в исполняемый код приложения. Модель PSM при этом может создаваться как контрольное описание, позволяющее проверить результат прямого преобразования. 

Преобразование моделей PIM PSM
Наиболее сложным и ответственным этапом при разработке приложений в рамках архитектуры MDA является преобразование модели PIM в модель PSM. Именно на этом этапе общее описание системы на языке UML приобретает вид, пригодный для воплощения приложения на конкретной платформе. Как уже говорилось, в процессе принимает участие модель платформы. Преобразование моделей проходит три последовательные стадии:
Разработка схемы преобразования (mapping) 
Маркирование (marking) 
Собственно преобразование (transformation)
Рассмотрим их подробнее. Первоначально необходимо разработать схему преобразования элементов модели PIM в элементы модели PSM. Для каждой платформы создается собственная схема преобразования, которая напрямую зависит от возможностей платформы. Схема преобразования затрагивает как содержание модели (совокупность элементов и их свойства), так и саму модель (метамодель, используемые типы). В схеме преобразования нужным типам модели, свойствам метамодели, элементам модели PIM ставятся в соответствие типы модели, свойства метамодели, элементы модели PSM. При преобразовании моделей может использоваться несколько схем преобразования. Для связывания используются марки (mark) самостоятельные структуры данных, принадлежащие не моделям, а схемам преобразования и содержащие информацию о созданных связях. Наборы марок могут быть объединены в тематические шаблоны, которые возможно использовать в различных схемах преобразования. Процесс задания марок называется маркированием. В простейшем случае один элемент модели PIM соединяется маркой с одним элементом модели PSM. В более сложных случаях один элемент модели PIM может иметь несколько марок из разных схем преобразования. Что касается преобразования метамодели, то в большинстве случаев марки могут расставляться автоматически. А вот для элементов модели часто требуется вмешательство разработчика. В процессе маркирования необходимо использовать сведения о платформе. Эти сведения содержатся в модели платформы. 
Процесс преобразования моделей заключается в переносе маркированных элементов модели и метамодели PIM в модель и метамодель PSM. Процесс преобразования должен документироваться в виде карты переноса элементов модели и метамодели. Способ преобразования моделей может быть:
Ручной 
С использованием профилей 
С настроенной схемой преобразования 
Автоматический

Многоплатформенные модели
Архитектура MDA учитывает возможность разработки приложений, одновременно функционирующих на нескольких платформах. Для этого марки схемы преобразования моделей PIM PSM устанавливаются в соответствии с распределением функционала приложения по платформам. Затем генерируется несколько платформенно-зависимых частей приложения. Проблема взаимодействия частей такого гетерогенного приложения решается на уровне бизнес-логики приложения на этапе разработки. Для обмена данными могут использоваться специально разработанные подсистемы, использующие для организации обмена заранее согласованные механизмы, форматы данных, интерфейсы. Более того, разработка механизмов межплатформенного взаимодействия хорошо поддается автоматизации. Инструментарии MDA могут содержать функционал для создания таких механизмов. 
*Консорциум OMG создан сообществом IT-компаний, специализирующихся на разработке программного и аппаратного обеспечения. Основной задачей консорциума является стандартизация и спецификация в сфере информационных технологий. При этом деятельность консорциума в значительной степени ориентирована на разработку перспективных стандартов. Программистам известны такие разработки OMG, как OMA, CORBA, UML.
",1
15,Введение в проектирование ИС.docx,"1. ВВЕДЕНИЕ В ПРОЕКТИРОВАНИЕ ИНФОРМАЦИОННЫХ СИСТЕМ
1.1. Методы проектирования информационных систем
Индустрия разработки автоматизированных информационных систем управления родилась в 50-х - 60-х годах и к концу века приобрела вполне законченные формы. Материалы данного руководства являются обобщением цикла лекций по Автоматизированным Банковским Системам (АБС) и Автоматизированным системам управления конструкторско-технологическим проектированием (АСУ КТП), читаемым в МГТУ им.Н.Э.Баумана. Не смотря на имеющиеся различия в реализации функциональных модулей данных систем, общие подходы к их разработки во многом схожи, что позволило нам объединить вопросы их проектирования в рамках одного издания. 
На рынке автоматизированных систем для крупных корпораций и финансово-промышленных групп на сегодня можно выделить два основных субъекта: это ранок автоматизированных банковских систем (АБС) и рынок корпоративных информационных систем промышленных предприятий. Не смотря на сильную взаимосвязь этих двух рынков систем автоматизации, предлагаемые на них решения пока еще не достаточно интегрированы между собой, чего следует ожидать в недалеком будущем. 
В дальнейшем под Автоматизированной Банковской Системой (АБС) будем понимать комплекс аппаратно-программных средств реализующих мультивалютную информационную систему, обеспечивающую современные финансовые и управленческие технологии в режиме реального времени при транзакционной обработке данных. 
Под Автоматизированной Информационной Системой промышленного предприятия (АСУ КТП) будем понимать комплекс аппаратно-программных средств реализующих мультикомпонентную информационную систему, обеспечивающую современное управление процессами принятия решений, проектирования, производства и сбыта в режиме реального времени при транзакционной обработке данных. 
Как вы видите, оба определения достаточно схожи. На сегодня существования нескольких методов построения автоматизированных информационных систем (АИС), среди которых можно выделить следующие: 

1.1.1 Метод ""снизу-вверх"".
Менталитет российских программистов сформировался именно в крупных вычислительных центрах (ВЦ), основной целью которых было не создание тиражируемых продуктов, а обслуживание сотрудников конкретного учреждения. Этот подход во многом сохранялся и при автоматизации и сегодня. В условиях постоянно изменяющихся законодательства, правил ведения производственной, финансово-хозяйственной деятельности и бухгалтерского учета руководителю удобно иметь рядом посредника между спущенной сверху новой инструкцией и компьютером. С другой стороны, программистов, зараженных ""вирусом самодеятельности"", оказалось предостаточно, тем более что за такую работу предлагалось вполне приличное вознаграждение. 
Создавая свои отделы и управления автоматизации, предприятия и банки пытались обустроиться своими силами. Однако периодическое ""перетряхивание"" инструкций, сложности, связанные с разными представлениями пользователей об одних и тех же данных, непрерывная работа программистов по удовлетворению все новых и новых пожеланий отдельных работников и как следствие - недовольство руководителей своими программистами несколько остудило пыл как тех, так и других. Итак, первый подход сводился к проектированию ""снизу-вверх"". В этом случае, при наличии квалифицированного штата программистов, вполне сносно были автоматизированы отдельные, важные с точки зрения руководства рабочие места. Общая же картина ""автоматизированного предприятия"" просматривалась недостаточно хорошо, особенно в перспективе. 

1.1.2. Метод ""сверху-вниз"".
Быстрый рост числа акционерных и частных предприятий и банков позволил некоторым компаниям увидеть здесь будущий рынок и инвестировать средства в создание программного аппарата для этого растущего рынка. Из всего спектра проблем разработчики выделили наиболее заметные: автоматизацию ведения бухгалтерского аналитического учета и технологических процессов (для банков это в основном - расчетно-кассовое обслуживание, для промышленных предприятий - автоматизация процессов проектирования и производства, имеется в виду не конкретных станков и т.п., а информационных потоков). Учитывая тот факт, что ядром АИС безусловно является аппарат, обеспечивающий автоматизированное ведение аналитического учета, большинство фирм начали с детальной проработки данной проблемы. Системы были спроектированы ""сверху"", т.е. в предположении что одна программа должна удовлетворять потребности всех пользователей. 
Сама идея использования ""одной программы для всех"" резко ограничила возможности разработчиков в структуре информационных множеств базы данных, использовании вариантов экранных форм, алгоритмов расчета и, следовательно, лишила возможности принципиально расширить круг решаемых задач - автоматизировать повседневную деятельность каждого работника. Заложенные ""сверху"" жесткие рамки (""общие для всех"") ограничивали возможности таких систем по ведению глубокого, часто специфического аналитического и производственно - технологического учета. Работники проводили эту работу вручную, а результаты вводили в компьютер. При этом интерфейс каждого рабочего места не мог быть определен функциями, возложенными на пользователя, и принятой технологией работы. Стало очевидно, что для успешной реализации задачи полной автоматизации банка следует изменить идеологию построения АИС. 

1.1.3. Принципы ""дуализма"" и многокомпонентности.
Развитие банковских структур и промышленных предприятий, увеличение числа филиалов, рост количества клиентов, необходимость повышения качества обслуживания предъявляли к автоматизированным системам новые требования. Новый подход к проектированию АИС заключается в сбалансированном сочетании двух предыдущих. В первую очередь это относилось к идеологии построения ядра системы: ""Автоматизированная бухгалтерия - аналитический учет"". 
Для банковских структур это дало: с одной стороны, в ядре системы сохранялась возможность работы ""от лицевого счета"", с автоматическим формированием соответствующих бухгалтерских проводок, с другой стороны, отменялись жесткие требования работы только с лицевыми счетами. Появилась возможность ведения бухгалтерского учета по балансовым счетам любого порядка без углубления до уровня лицевых счетов клиентов. При этом ведение аналитического учета по лицевым счетам клиентов опускалось на уровень специализированного программного обеспечения (СПО), установленного на рабочих местах банковских работников (контролеров, кредитных бухгалтеров, инспекторов и т. д.). Таким образом, принципиальное отличие нового подхода к созданию АБС заключается в идее распределения плана счетов по уровням экспертизы. При этом и сам справочник плана счетов с соответствующими описаниями, и информационное множество клиентов проектировались по принципу распределенной базы данных. Результатом этого явилось: 
формирование всех необходимых бухгалтерских проводок, уже агрегированных по балансовым счетам, и автоматическая их передача в базу данных ""Автоматизированной бухгалтерии""; 
реализация специфических требований каждого банковского работника, в том числе по формированию произвольных отчетов и справок, мемориальных ордеров, операционных дневников; выполнение любых вспомогательных и технологических расчетов и пр. 
С использованием гибкой системы настроек СПО (компонентов АБС) появилась реальная возможность адаптации программного аппарата к практически любым условиям и различным требованиям инструктивных материалов и правилам работы, принятым либо в вышестоящей организации, либо в данном банковском учреждении. Кроме того, при многокомпонентной схеме организации АБС при проведении модернизации одного из компонентов центральная часть (ядро) АБС и другие ее компоненты не затрагивались, что значительно повышало надежность, продолжительность жизни автоматизированной системы и обеспечивало наиболее полное выполнение требуемых функций. 
Двойственный подход к формированию ежедневного баланса лег в основу т.н. ""принципа дуализма"" - одного из важных принципов построения современных банковских систем. Реализация принципа дуализма неизбежно требовала построения АБС нового поколения в виде программных модулей, органически связанных между собой, но в то же время способных работать и автономно. 
Задача проектирования АИС промышленных предприятий более сложна, т.к. характер обрабатываемой информации еще более разнороден и сложно формализуем. Однако и здесь можно выделить основную модель работы - это работа ""от кода проекта"". В общем случае код проекта представляет собой аналог (функциональный) лицевого счета, он имеет определенную разрядность, порядок (т.е. конкретная группа цифро-буквенного обозначения характеризует деталь, сборочную единицу, изделие и их уровень взаимосвязи). Причем конкретная часть кода характеризует технологические, конструкторские, финансовые и др. документы. Все это регламентируется соответствующими ГОСТами (аналог инструкций ЦБ для банков), поэтому может быть формализовано. При этом модульный подход к реализации АИС в этом случае еще более важен. 
Двойственный подход к формированию ежедневного производственного плана лег в основу т.н. ""принципа дуализма"" для АИС промышленных предприятий. Реализация принципа дуализма неизбежно также требовала построения АИС предприятий нового поколения в виде программных модулей, органически связанных между собой, но в то же время способных работать и автономно. 
Такая многокомпонентная система обеспечивала соблюдение основополагающего принципа построения автоматизированных информационных систем - отсутствия дублирования ввода исходных данных. Информация по операциям, проведенным с применением одного из компонентов системы, могла быть использована любым другим ее компонентом. Модульность построения АИС нового поколения и принцип одноразового ввода дают возможность гибко варьировать конфигурацией этих систем. Так, в банках, имеющих разветвленную филиальную сеть и не передающих данные в режиме реального времени, установка всего СПО во всех филиалах не всегда экономически оправдано. В этих случаях возможна эксплуатация в филиалах ПО общего назначения, предназначенного для первичного ввода информации и последующей автоматизированной обработки данных в СПО, установленном в головном офисе банка. Такая структура дает возможность органически включить в АБС нового поколения компонент для создания хранилища данных, разделяя системы оперативного действия и системы поддержки принятия решения. 
Кроме того, одно из достоинств принципа многокомпонентности, являющегося базовым при создании АИС нового поколения, состоит в возможности их поэтапного внедрения. На первом этапе внедрения устанавливаются (или заменяются уже устаревшие) компоненты системы на те рабочие места, которые нуждаются в обновлении ПО. На втором этапе происходит развитие системы с подсоединением новых компонентов и отработкой межкомпонентных связей. Возможность применения такой методики внедрения обеспечивает ее достаточно простое тиражирование и адаптацию к местным условиям. Таким образом, автоматизированная информационная система нового поколения - это многокомпонентная система с распределенной базой данных по уровням экспертизы. 
Что же заставляет банки разрабатывать предприятия и банки свои АИС собственными силами [1,2]: 
Во-первых, это конечно относительно низкая стоимость таких разработок (по сравнению с покупными). Как правило, к существующим подразделениям департамента информатизации, таким как: управление эксплуатации, управление эксплуатации вычислительной сети и средств связи, экспертно-аналитическое управление (постановка задач), добавляется лишь новая структура: управление развития и разработки АИС, что, как правило, не влечет за собой больших финансовых затрат. 
Во-вторых, собственная разработка - это максимальная ориентация на реализацию бизнес - процессов предприятия или банка, его уникальных финансовых и управленческих технологий, складывающихся годами. 
В третьих, это позволяет обеспечивать значительно более высокий уровень безопасности и независимости от внешних факторов. 
В четвертых, оперативная реакция на изменения правил игры на рынке.
Вместе с тем при собственной разработке необходимо решить целый комплекс организационно-технических задач, которые позволили бы избежать ошибочных решений [1,2]: 
Во-первых, правильный выбор архитектуры построения вычислительно-коммуникационной сети и ориентация на профессиональные СУБД. По экспертным оценкам собственные разработки АИС в 53% базируются на СУБД Oracle, около 15% на Informix, 22% - другие СУБД. 
Во-вторых, использование при разработке современного инструментария (CASE средства, эффективные средства разработки: Delphi, Designer2000, Developer2000, SQL-Stations и т.п.). 
В третьих, мультизадачная инфраструктура разработки проекта, когда конкретный модуль АИС ведет группа разработчиков с взаимосвязанным перечнем задач, построенная на принципах полной взаимозаменяемости, т.е. функционирование данного модуля АИС и его развитие не связано с одним конкретным разработчиком. 
В четвертых, применение эффективных организационно-технических средств по управлению проектом и контролю версий АИС. 
Только при соблюдении этих основных положений можно рассчитывать, что собственная разработка окажется конкурентной и эффективной. В противном же случае можно столкнуться с эффектом ""неоправданных ожиданий"" - это в лучшем случае, а в крайнем случае вообще задуматься о смене АИС. При этом, смена АИС может вызвать как непосредственно смену клиентских модулей и табличной структуры БД, так и потребовать замены серверного и клиентского аппаратного и общесистемного программного обеспечения, включая СУБД, а это дело не дешевое. Поэтому очень важно при выборе варианта реализации АИС сразу решить вопрос о возможностях экспорта/импорта данных в создаваемой системе. При правильном решении данного вопроса смена АИС, если в ней все-таки возникнет необходимость, произойдем практически безболезненно для функциональных подразделений. 
В отличие от банковских структур крупные отечественные промышленные предприятия сейчас только подходят к осознанию явной необходимости внедрения и развития корпоративных информационных систем как одной из основных компонент стратегического развития бизнеса. В связи с этим в недалеком будущем можно ожидать расширение рынка корпоративных информационных систем и в последующем его значительно роста. Учитывая тесную интеграцию финансовых и промышленных структур можно полагать, что основой построения корпоративных систем финансово-промышленных групп будут являться, используемые в их финансовых учреждениях, АБС. 

1.2. Ориентация на профессиональные СУБД - ""За"" и ""Против""
По материалам периодической печати [1,2] можно судить, что 1998 год стал годом перехода к внедрению АБС четвертого поколения, основой которых, в свою очередь, является ориентация на профессиональные СУБД. Что же это дает и зачем все это нужно: 
Оптимизированный многопользовательский режим работы с развитой системой транзакционной обработки, что обеспечивает многочисленным пользователям возможность работы с базой данных, не мешая друг другу. 
Надежные средства защиты информации (учитывая стандартную трехзвенную архитектуру защиты на уровне сети - на уровне сервера БД - на уровне клиентской ОС). 
Эффективные инструменты для разграничения доступа к БД. 
Поддержка широкого диапазона аппаратно - программных платформ. 
Реализация распределенной обработки данных. 
Возможность построения гетерогенных и распределенных сетей. 
Развитые средства управления, контроля, мониторинга и администрирования сервера БД. 
Поддержка таких эффективных инструментариев, как: словари данных, триггеры, функции, процедуры, пакеты и т.п. 
Все выше перечисленное обусловило широкое распространение решений на базе профессиональных СУБД в крупных коммерческих банках и промышленных корпорациях. По экспертным оценкам по числу установок лидируют СУБД Oracle, Informix, Sybase. Несмотря на это в большинстве средних и малых банках и предприятиях по-прежнему, ориентируются на решения на базе АИС третьего и даже второго поколения. Какие же основные ""мнимые"" стереотипы пока не позволяют этим структурам ориентироваться на использования профессиональных СУБД при построении своих АИС [1,2]: 
""ПРОТИВ"" - Относительно высокая дороговизна профессиональных СУБД 
""ЗА"" - Как правило, поставщиками практически всех профессиональных СУБД сейчас предлагаются масштабируемые решения, т.е. например, Enterprise Database - для крупных систем и WorkGroup Database - для средних и малых систем, причем цена последних сравнима с ценами на локальные СУБД. 
""ПРОТИВ"" - Профессиональные СУБД предъявляют высокие требования к аппаратной платформе. 
""ЗА"" - С резким ростом производительности Intel-ориентированных аппаратных платформ большинство производителей профессиональных СУБД выпустила свои версии и под Intel-сервера, в том числе и под ОС LINUX, а учитывая что LINUX при всей своей мощности UNIX системы практичсеки беспланая ОС, то и решение на ее основе как правило не повлечет больших финансовых затрат. Это позволяет при построении системы ориентироваться не только на высокопроизводительные многокластерные RISC сервера, но и использовать серверные Intel-платформы. 
""ПРОТИВ"" - Профессиональные АИС сложны и дороги в администрировании. 
""ЗА"" - Как правило, сложность администрирования зависит от конкретной АИС. Кроме этого, при эксплуатации АИС в многопрофильном банке или предприятии на UNIX платформе снимает многие проблемы, возникающие на местах, за счет широких возможностей удаленного администрирования из центра. 
""ПРОТИВ"" - Разработки АИС на промышленной платформе слишком дороги. 
""ЗА"" - Проектирование современных интегрированных систем - процесс трудоемкий, требующей высокой квалификации разработчиков. Все это находит отражение в цене и объективно делает АИС нового поколения более дорогими, но все же сравнимыми по стоимости с их предшественниками. 
""ПРОТИВ"" - Внедрение систем на профессиональной платформе процесс затяжной и дорогостоящий. 
""ЗА"" - Затяжка внедрения, как правило, обусловлена либо недостатком опыта фирмы поставщика по установке таких систем, либо недостаточной готовностью самого внедряемого продукта. Ориентировочный срок установки типовой АИС четвертого поколения под СУБД Oracle при отлаженном технологическом процессе составляет несколько недель. 
""ПРОТИВ"" - Сопровождение систем на базе профессиональной платформы неоправданно дорого, а качественные характеристики такой АИС оставляют желать лучшего. 
""ЗА"" - Во многом это предубеждение сложилось на основании опыта эксплуатации АИС зарубежного производства. Можно указать целый ряд случаев, когда зарубежные фирмы поставщики либо отказывались своевременно вносить изменения, обусловленные новыми инструкциями ЦБ, либо требовали за эти изменения неоправданно крупные суммы. Однако это совсем не относится к отечественным системам нового поколения, изначально рассчитанным на изменчивое российское законодательство.
Выводы: Анализ рынка показывает, что на сегодня современная АИС должна представлять собой интегрированный комплекс аппаратно-программных средств реализующих мультипредметную информационную систему, обеспечивающую современные финансовые, управленческие, проектирующие, производственные и сбытовые технологии в режиме реального времени при транзакционной обработке данных. Если задуматься, то это достаточно закономерно. Персональные СУБД (Clipper, Clarion, FoxPro) совершенно не приспособлены для создания интегрированных систем, работающих с общей базой. В принципе эти СУБД вообще не поддерживают понятие ""база данных"", работая на уровне индивидуальных таблиц-файлов. 
Широко распространенные сегодня системы на базе Btrieve все же трудно назвать масштабируемыми, а саму Btrieve - профессиональной СУБД, пригодной для построения корпоративной информационной системы. Btrieve-системы унаследовали свою архитектуру и большую часть кода от своих предшественников, разработанных на Clipper и Clarion, что во многом объясняет столь большую популярность Btrieve среди фирм, разрабатывавших ранее под эти платформы. Действительно, механически перенести Clarion систему под использование менеджера записей Btrieve относительно несложно, а вот для использования в качестве СУБД Oracle придется существенно изменить архитектуру системы. 
В чем основные отличительные особенности корпоративных СУБД. Во-первых, они были изначально направлены на создание интегрированных, многопользовательских систем, имея в своем распоряжении развитые словари данных, что значительно повышает роль системного анализа и моделирования при проектировании системы. Во-вторых, средства разработки для данных СУБД оптимизированы для коллективной разработки сложных систем в рамках единой продуманной стратегической линии. Все это обуславливает неуклонно растущее количество успешных внедрений систем на базе профессиональных СУБД. 

1.3. Этапы разработки автоматизированных информационных систем.
Итак, мы выбрали метод, которым будем руководствоваться при проектировании автоматизированной информационной системы. Теперь нам необходимо спланировать комплекс работ по созданию нашей системы в соответствии с типовыми этапами разработки АИС, краткая характеристика которых приведена в табл.1., а последовательность трансформации бизнес модели в объекты базы данных на рис.1. 

1.3.1. Разработка и анализ бизнес-модели
При построении эффективной автоматизированной системы первым этапом является исследование и формализация бизнес-процессов деятельности банка или предприятия. Т.е. описание системы ведения делопроизводства с целью эффективного использования информации для достижения поставленных задач и решения проблем, стоящих перед организацией. Организация работы с документами (будь то платежные или конструкторско-технологические документы) является важной составной частью процессов управления и принятия управленческих решений, существенно влияющей на оперативность и качество управления. Процесс принятия управленческого решения состоит из: 
Получения информации; 
Переработка информации; 
Анализа, подготовки и принятия решения. 
Все эти этапы самым тесным образом связаны с документационным обеспечением процессов управления, проектирования и производства. Если на предприятии отсутствует четкая организация работы с документами, то, как следствие этого, закономерно появление документов низкого качества, как в оформлении, так и в полноте и ценности содержащейся в них информации, увеличение сроков их обработки. Это приводит к ухудшению качества управления и увеличению сроков принятия решений и числу неверных решений. С ростом масштабов предприятия и численности его сотрудников вопрос об эффективности документационного обеспечения управления становится все более актуальным. Основные проблемы, возникающие при этом, выглядят примерно так: 
руководство теряет целостную картину происходящего; 
структурные подразделения, не имея информации о деятельности друг друга, перестают слаженно осуществлять свою деятельность. Неизбежно падает качество обслуживания клиентов и способность организации поддерживать внешние контакты; 
это приводит к падению производительности и вызывает ощущение недостатка в ресурсах: людских, технических, коммуникационных и т.д.; 
приходится расширять штат, вкладывать деньги в оборудование новых рабочих мест, помещения, коммуникации, обучение новых сотрудников; 
для производственных предприятий увеличение штата может повлечь изменение технологии производства, что потребует дополнительных инвестиций; 
оказывается, что штат увеличен, производительность упала, производство требует инвестиций, соответственно возникает потребность в увеличении оборотного капитала, что может потребовать новых кредитов и уменьшить плановую прибыль. 
В итоге предприятие перестает расти интенсивно и дальнейшее расширение происходит чисто экстенсивным путем за счет ранее созданной прибыли. 
Почему же сегодня, когда для организации документооборота (в дальнейшем под этим термином мы будем понимать документооборот любых документов: конструкторских, технологических, финансовых, организационных и т.п.) предлагается множество самых различных средств автоматизации, документооборот часто организован плохо, даже на относительно небольших предприятиях? Ответ, независимо от степени автоматизации предприятия и его типа, может быть один - отсутствие или игнорирование модели организации документооборота неизбежно приведет к тому, что старые проблемы останутся нерешенными. При этом, если по состоянию делопроизводства в организации был ""ручной"" хаос, то результатом автоматизации будет ""компьютерный"" хаос. 
Когда на Западе, а теперь и в России схлынула первая волна увлечения системами автоматизации документооборота, оказалось, что без должной оценки возможностей пользователя, исследования бизнес - процессов его предприятия трудно ожидать эффекта от внедрения как систем документооборота класса docflow так и, тем более, workflow. При этом совсем неважно, как планируется или уже реализован документооборот: вручную или путем автоматизации с помощью мощных западных либо отечественных пакетов - всегда на первом месте должна быть четкая стратегия, направленная на упорядочение бизнес - процессов. Иначе говоря, прежде чем что-то делать, неплохо было бы ответить на вопрос, кому и почему выгодно выполнять те или иные процессы, имеющие место на предприятии. Проводя в жизнь программу модернизации делопроизводства, важно представлять, какого уровня уже достигло предприятие и какое место ему отводится в модельном пространстве системы документооборота. 

1.3.1.1. Основные понятия электронного документооборота
Документ. 
Пример: Вы написали заявление на отпуск и передали его в отдел кадров. Так появился документ. Что же превратило чистый лист бумаги в документ? Во-первых, информация, представленная в виде текста. Во-вторых, текст в форме заявления. И в-третьих, бумагу готовили с расчетом на последующую деятельность сотрудников отдела кадров. 
Теперь предположим, что вы обратились в отдел кадров с устным заявлением об отпуске. Можно ли назвать документом эту процедуру? Устная беседа не была зафиксирована физически, она не поддается точному воспроизведению и, следовательно, документом не является. 
Итак, документ - это совокупность трех составляющих [3]: 
Физическая регистрация информации. 
Форма представления информации 
Активизация определенной деятельности. 
Именно некоторая деятельность и превращает информацию в документ. Но документ перестает существовать, если в дальнейшем не подразумевает процедуры обработки. При этом форма документа тесно связана с характером дальнейшей деятельности, она порождает необходимость документов. Так родилась бюрократия- неизбежный спутник цивилизации. 
Документ [4] - слабоструктурированная совокупность блоков или объектов информации, понятная человеку. В общем случае обойтись без документов пока нельзя. Сам по себе документ, независимо от того, обычная ли это бумага или электронный бланк, проблем корпорации не решает - первичны бизнес-процессы и четкий контроль за выполнением проекта. 
Бюрократическая технология - это технология взаимодействия людей, служб и подразделений внутри и вне организации. Не будет технологии - возникнет анархия. Если работник не знает что ему надо делать, он делает то, что считает нужным, а не то, что требует тот или иной бизнес-процесс предприятия. Сама бюрократия неизбежна, опасность представляет отрыв реальных целей предприятия от работы текущей системы документооборота. 
Собственно документооборот может быть двух типов: 
универсальный - автоматизирующий существующие информационные потоки слабоструктурированной информации. Справедливо было бы его называть аморфным или беспорядочным документооборотом; 
операционный - ориентированный на работу с документами, содержащими операционную атрибутику, вместе с которой ведется слабоструктурированная информация. 
Кроме собственно документов важен еще регламент работы с ними. Любой опытный менеджер может подтвердить, что работа не по регламенту порой отнимает намного больше времени, чем собственно производственная деятельность. Дублирование документов, их потеря, навязчивый способ их распространения, а также запутанный порядок их прохождения могут существенно усложнить работу, повысив вероятность допущения ошибки вследствие, например, потери нужной информации. 
Итак, документ занимает определенное место в процессе некоторой деятельности на границе разделяемых функций исполнения. Поэтому правильно рассматривать документ как инструмент распределения функций между работниками [3]. 

1.3.1.2. Преимущества электронного документооборота
К основным преимуществам электронного документооборота можно отнести следующие: 
Полный контроль за перемещением и эволюцией документа, регламентация доступа и способ работы пользователей с различными документами и их отдельными частями. 
Уменьшение расходов на управление за счет высвобождения (на 90% и более) людских ресурсов, занятых различными видами обработки бумажных документов, снижение бюрократической волокиты за счет маршрутизированного перемещения документов и жесткого контроля за порядком и сроками прохождения документов. 
Быстрое создание новых документов из уже существующих. 
Поддержка одновременной работы многих пользователей с одним и тем же документом, предотвращение его потери или порчи. 
Сокращение времени поиска нужных документов. 
Использование АИС может рассматриваться в качестве базы для общего совершенствования управления предприятием. При этом управление предприятием реализует следующие основные функции: 
обслуживание клиентов; 
разработка продукции; 
учет и контроль за деятельностью предприятия; 
финансовое обеспечение деятельности предприятия и т.д. 

1.3.1.3. Модели информационного пространства предприятия.
Комплексная автоматизация этих функции требует создания единого информационного пространства предприятия, в котором сотрудники и руководство могут осуществлять свою деятельность, руководствуясь едиными правилами представления и обработки информации в документном и бездокументном виде. 
Для этого в рамках предприятия требуется создать единую информационную систему по управлению информацией или единую систему управления документами, включающую возможности: 
удаленной работы, когда члены одного коллектива могут работать в разных комнатах здания или в разных зданиях; 
доступа к информации, когда разные пользователи должны иметь доступ к одним и тем же данным без потерь в производительности и независимо от своего местоположения в сети; 
средств коммуникации, например: электронная почта, факс, печать документов; 
сохранения целостности данных в общей базе данных; 
полнотекстового и реквизитного поиска информации; 
открытость системы, когда пользователи должны иметь доступ к привычным средствам создания документов и к уже существующим документам, созданным в других системах; 
защищенность информации; 
удобства настройки на конкретные задачи пользователей; 
масштабируемости системы для поддержки роста организаций и защиты вложенных инвестиций и т.д. 
Начальным этапом создания такой системы является построение модели предметной области или другими словами модели документооборота для конкретного бизнеса и позиционировать в ней свое предприятие. 
Определенные ранее направления автоматизации документооборота: поддержка фактографической информации, возможность работы с полнотекстовыми документами, поддержка регламента прохождения документов, определяют трехмерное пространство свойств, где по некоторой траектории движется любой программный продукт данного класса, проходя различные стадии в своем развитии (рис.2.). 
Первая ось (F) характеризует уровень организации хранения фактографической информации, которая привязана к специфике конкретного рода деятельности компании или организации. Например: при закупке материальных ценностей происходит оформление товарно-сопроводительных документов (накладных, приемо-передаточных актов, приходных складских ордеров и т.д.), регистрируемых в качестве операционных документов, атрибутика которых очень важна для принятия управленческих решений. Информация из операционных документов используется при сложной аналитической и синтетической обработке, и, в частном случае, может быть получена пользователем через систему отчетов. 
Вторая ось (D) - полнотекстовые документы, отражает необходимость организации взаимодействия: формирование и передача товаров, услуг или информации как внутри корпорации, так и вне ее. В этих документах наряду с фактографической информацией содержится слабо структурированная информация, не подлежащая автоматизированной аналитической обработке, такая, например, как форс-мажерные факторы и порядок предъявления претензий при нарушении условий договора. Все взаимоотношения между субъектами бизнеса сопровождаются документами, которые становятся осязаемым отражением результата взаимодействия. 
Третья ось (R) вносит в пространство документооборота третье измерение - регламент процессов прохождения документов, а именно: описание того какие процедуры, когда и как должны выполняться. Основа для позиционирования относительно данной оси - набор формальных признаков (атрибутов) и перечень выполнения операций. 
Точка в пространстве (F, D, R) определяет состояние системы документооборота и имеет координаты (f,d,r), где f,d и r принадлежат множествам F,D и R, соответственно. Положение этой точки зависит от уровня развития и стадии внедрения системы документооборота на предприятии, а также от его специфики и самих масштабов бизнеса. 
Представив модель документооборота именно таким образом, можно, например, зная текущее положение дел с организацией делопроизводства на каждом конкретном предприятии, четко представить, в каких направлениях нужно двигаться дальше, чего недостает в текущий момент и каким образом органично использовать уже существующие системы автоматизации. Например, в одном из московских банков был накоплен большой массив фактографических данных, для обработки которых использовалась современная СУБД, развернутая на мощных, отказоустойчивых серверах - все, казалось бы, должно быть отлично. Однако при работе с внутренними документами наблюдалось дублирование информации: возникали ситуации, когда ""никто вроде бы и не виноват"", а банк время от времени лишается выгодных клиентов. Причина в том, что точка, отражающая положение системы документооборота для этой организации, имела достаточно большие координаты по оси ""F"" и, возможно, по оси ""D"", однако значение координаты по оси ""R"" было близко к нулю. Конкретным решением в этом случае может быть рассмотрение вопроса о внедрении системы управления регламентом. При этом не надо пока заботится о СУБД (ось ""F"") или электронных архивах (ось ""D"") - речь идет только об изменении значения координат по оси ""R"". 
В общем случае, как уже отмечалось, процесс автоматизации делопроизводства на предприятии можно представить в виде кривой в трехмерном пространстве координат F,D,R. Причем, чем круче эта кривая, тем быстрее идет процесс модернизации, а чем больше значения всех трех координат - тем выше уровень автоматизации на корпорации и, как следствие, тем меньше у нее проблем с организацией своей собственной деятельности. 
Работоспособна ли данная модель для задания пространства развития неавтоматизированной системы управления документооборотом? Да. Единственно, что в этом случае решается задача не облегчения рутинного труда по перемещению документов, их поиску и регистрации, а упорядочения всей системы документооборота. Новое качество, с которым сегодня ассоциируется возросший интерес к системам электронного документооборота, связано с использованием инструментальных систем, предназначенных для хранения, регистрации, поиска документов, а также для управления регламентом. Чаще ошибочно под новым качеством сегодня понимается простое внедрение отличной от ранее используемой технологии работы с документами, например локальной сети вместо дискет, переносимых с одного компьютера на другой. Вряд ли в этом случае уместно говорить о новом качестве управления предприятием. Кстати, уже упомянутый пример ручной работы режимных служб ""почтовых ящиков"", прекрасно вписывается в предложенную модель документооборота, а точка, отражающая его состояние, будет иметь координаты (1,1,1) - все равномерно, единственное, что отсутствует - компьютеризация. 
Эволюция модели. 
Рассмотренная модель документооборота не является застывшим образованием, данным нам в ощущениях - прежде чем сформировалось современное представление о контурах этой модели, она претерпела три основные фазы своей эволюции, две из которых представлены на рис.3., а третья на рис.2. 
Фаза первая - фактографическая. Начало любой деятельности знаменуется обычно периодом накопления первичной информации, имеющей жесткую структуру и атрибутику. Условно эту фазу можно представить в виде одной единственной оси. 
Точка на этой оси - это текущее состояние системы документооборота организации. Движение по оси вверх характеризует накопление фактографической информации и начиная с определенного момента которого можно отметить второй этап первой фазы - возникновение понятия ""операция"". Документ теперь представляется как некоторый привязанный к бизнес - процессам предприятия агрегат из имеющихся характеристик (атрибутов). На этом этапе начинается процесс возникновения неравенства между ранее равноправными документами, в частности, документ-основание, а дальнейшее движение по оси приобретает все более операционный оттенок. После возникновения привязки к конкретным бизнес - процессам дальнейшая эволюция документооборота в одномерном пространстве уже невозможна - необходим новый качественный скачок к новой фазе. 
Фаза вторая - полнотекстовая. Расширение организации и увеличение круга решаемых задач требуют использования полнотекстовых документов, включающих уже не только тексты, но и любые другие способы представления: графики, таблицы, видео и т.п виды конструкторско-технологической документации. Возникает новая ось - полнотекстовые или, лучше, мультимедийные документы, а точка в новом, уже двумерном, пространстве характеризует систему документооборота предприятия, где кроме фактографической базы документов имеются уже хранилища и архивы информации. 
Хранилища позволяют накапливать документы в различных форматах, предполагают наличие их структуризации и возможностей поиска. Если на предприятии уже используется автоматизация, то хранилище - это не что иное, как электронный архив. Движение по оси ""полнотекстовые документы"" предполагает наращивание атрибутивных возможностей: разграничение доступа, расширение средств поиска, иерархию хранения, классификация. Здесь же возникают такие понятия как электронная подпись, шифрование и т.п. 
На данной оси также имеются свои этапы - с определенного момента развития хранилища можно уже говорить не об индивидуальном, а о корпоративном архиве, обслуживающем деятельность рабочих групп. Точка на плоскости эволюции, достигнутой во второй фазе, характеризует систему документооборота, позволяющую отображать фактографическую информацию в виде полнотекстовых документов, имеющих необходимое количество атрибутов. Доступ к этим документам может быть осуществлен по маршруту любого уровня сложности с соблюдением различных уровней конфиденциальности. Если, например, говорить о точке ""А"", то соответствующее ей состояние системы документооборота позволяет осуществлять синхронизацию работы различных рабочих групп сотрудников корпорации, расположенных на различных площадках. Система для этой точки предполагает также структурирование информации по уровням управления и наличие средств репликации данных. Однако, как только речь пошла о корпорации, двумерного пространства для соответствующей ей системы документооборота опять становится недостаточно - необходим новый скачок к очередной фазе. 
Фаза третья - регламентирующая. Нормальный документооборот в масштабах корпорации невозможен без решения вопросов согласования или соблюдения регламента работы. Если ранее, на второй фазе (плоскость) негласно присутствовал лишь один, простейший регламент (нулевая точка) - каждый сотрудник имел доступ к архиву или его части, либо в папку каждому работнику помещалось индивидуальное задание (иначе говоря, было известно только, что документ существует), то сейчас этого недостаточно. Требуется уже интегральная оценка. Необходим, например, контроль за тем, как работник выполнил задание, или как продвигается документ в условиях нелинейного процесса своего согласования (например согласования пакета конструкторско-технологической документации на сборочную единицу). 
Третья ось в пространстве документооборота предприятия, как и две другие имеет свое деление на этапы. Первоначальный этап движения по оси характеризуется наличием упрощенного регламента, отображаемого появлением атрибутов, отвечающих за регламент, например: ""оплатить до"", ""действителен для"". Количественное накопление атрибутов и расширение возможностей по управлению регламента сопровождается постепенным переходом ко второму этапу, отличительная черта которого - появление системы, специально предназначенной для отслеживания процесса соблюдения регламента. При дальнейшем движении вдоль этой оси можно говорить о появлении единой системы управления проектом. Теперь документ в системе ""документооборота"" становится вторичным - первична цель бизнеса, сам процесс реализации бизнес - процедур, оставляющий после себя документы. 
Оси ""F"" и ""D"" определяют специфику деятельности организации, регламентируемую положением третьей координаты (R) пространства модели документооборота. При этом модель не зависит от технологии обработки документов, принятой на предприятии - все решает только цель деятельности, будь то государственная организация, торговая компания и промышленная фирма. В общем случае можно выделить три типа организаций: 
Банк и торговая компания: приобретение, наценка, продажа, получение прибыли - главный объект деятельности; 
бюджетная организация: основная деятельность - формирование документов; 
промышленное предприятие: закупка сырья, переработка, создание нового продукта, реализация, получение прибыли. Цель деятельности - операция. 
Если задачей организации является формирование документов, например мэрия, суд или министерство, то ее позиция в модели будет занимать достаточно высокое положение относительно осей ""F"" и ""D"". Кстати, сегодня наибольшей популярностью пользуются именно приложения, ориентированные на автоматизацию деятельности государственных и правительственных административных структур - основная цель которых и состоит в подготовке документов. Однако если рассматривать деятельность коммерческого банка или фирмы задача которой - производство операций, материальных ценностей , то здесь уже все три координаты должны иметь сбалансированные значения. 
Рассмотрим в качестве примера основные шаги при разработки функциональной модели типовой АБС. Среди архитектур реализации АБС на сегодня выделят АБС пяти поколений: первые были предназначены для решения задач автоматизации бухгалтерских операций, АБС второго и третьего поколений также реализовывали элементы автоматизированного документооброта, АБС четвертого поколения строились по классической схеме трехзвенной клиент-серверной архитектуры и имели модульную структуру, реализующую концепции docflow. АБС пятого поколения являются информационными системы реилизующими полнофункциональную модель workflow - автоматизации бизнесс-процессов (рис.4,5). 
Схема функциональных бизнес-потоков типовой АБС четвертого поколения представлена на рис.6., а функциональная схема технологических потоков операций на рис.7. 
Назначения большинства модулей АБС (рис.6) достаточны понятны, едиснтвенное следует уточнить, что под интернет-банкингом понимает автоматизированная система реализующая технологии busines-to-customers (клиентское обслуживание, включая электронные платежы физических лиц) и bisnes-to-bisnes (обеспечение работы дистрибьюторско-дилерской сети корпораций в режиме on-line коммерции). 
Разработав функциональную схему бизнес-потоков, структурировав ее в соотвествии с модульным принципом построения любой системы управления и выделив базовые технологические потоки операций на каждом из уровне модульности (итог: перечень документов и операций обрабатываемых на конкретном рабочем месте, маршруты их движения, контроля и управления), можно приступать к следующему этапу проектирования информационной системы. 

1.3.1.4. Выводы.
Координаты точки, характеризующей сбалансированную систему документооборота (бизнес - модель функционирования предприятия), должны иметь ненулевые значения, а в идеале быть примерно одинаковы - соответствовать друг другу. Главное не автоматизация как таковая, а оптимизация потоков документов и интегральность - даже самая прекрасная программа автоматизации документооборота окажется напрасным вложением средств, если модель одномерная или плоская. 
Нет большого смысла говорить о жизненном цикле документов без связи с основными бизнес-процессами предприятия. Система автоматизации документооборота, функционирующая в отрыве от всех слоев, будет мертва, мало того, она может нанести вред: запутать и без того неуправляемые бизнес - процессы, отвлечь персонал от выполнения основной работы ради поддержания системы автоматизации документооборота, по сути дела, ничего не автоматизирующего. И, как следствие, раздувание штатного расписания и дискредитация самой идеи автоматизации делопроизводства. Знакомая ситуация - все работники заняты, работа кипит, однако если рассмотреть две разные фирмы имеющие равный доход, занимающиеся одним бизнесом, то штат сотрудников у одной из них будет вдвое больше, чем у другой. При создании или внедрении АИС необходимо всегда помнить, что компьютер или комплект программных средств типа workflow - это только голый инструмент, неумелое использование которого чаще всего влечет за собой только вред, а не долгожданное облегчение и освобождение от внутрикорпоративных проблем по управлению. ",1
0,Встроенные операторы SQL.docx,"Встроенные операторы SQL. 
Как было отмечено ранее SQL (Structured Query Language) - структурированный язык запросов, позволяет оперировать данными в реляционных базах данных. Стандарт SQL определен Американским национальным институтом стандартов и ISO в качестве международного стандарта. Целью данного издания не является полное и всеобъемлющее освещение синтаксиса SQL, для этого есть специализированные справочники и документация [1-10], мы же постараемся на нескольких простых конкретных примерах показать Вам всю элегантность и мощь SQL. Все примеры, приведенные ниже даны, применительно к ER-диаграмме ДОКТОР-ПАЦИЕНТ, приведенной на рис.10. 
Что же из себя представляет SQL - программа? Чаще всего это оформленная в виде отдельного файла программная конструкция, написанная в любом текстовом редакторе с учетом требований синтаксиса языка SQL. Такая форма представления SQL программы - называется скриптом и предназначена для выполнения на сервере, например с помощью специальной терминальной программы SQL+ (строка запуска скрипта в SQL+: @<путь>/<имя скрипта>.sql). Считается хорошим тоном наличие в скрипте комментариев. Для выделения строчных комментариев используется следующий набор символов: --. 
Перед тем как перейти непосредственно к рассмотрению использования основных SQL операторов еще несколько слов об организации проектирования БД. Процесс создания БД - это сложный многоэтапный процесс, причем как правило в нем принимают участие большое число разработчиков, поэтому очень важным является правильная организация внесения изменений в БД. Для этих целей очень часто используется технология ""РАЗДЕЛЕНИЯ ЗАДАЧ"", которая заключается в следующем: каждый разработчик, выполняя конкретную часть создания или модификации БД, оформляет все производимые им изменения в виде скриптов (т.е. отдельных файлов), архивные версии которых перед запуском на сервере размещаются на отдельном, специально выделенном, носителе (диске сервера), причем каждое такое изменение БД оформляется в виде отдельной задачи, имеющей свой уникальный номер. Например, в задаче 000001/VER001/ (физически это просто каталог на диске) находятся все скрипты (файлы) по первоначальному созданию БД. Такой подход позволяет максимально удобно решать задачи ""Контроля версий"", производить миграцию созданной БД на другой сервер (достаточно на новом сервере выполнить все задачи в последовательности следования номеров задач), обеспечивает достаточно высокий уровень безопасности, возможности отката на любую предыдущую позицию (этап разработки БД) и многое другое. В дальнейшем при выполнении практических примеров приведенных в данном издании советуем вам придерживаться именно этой технологии. Если вы на каком-то из этапов допустили ошибку (которую выявили на этапе выполнения скрипта в БД) не надо исправлять текст непосредственно этого скрипта, оформьте новую версию выполняемой задачи, в которой разместите исправленный скрипт. Это позволит Вам всегда отслеживать все Ваши ошибки. Последняя рекомендация, которую хотелось бы дать, заключается в том, что если в задачу входит несколько скриптов, то целесообразно оформить один дополнительный запускающий скрипт, например start.sql, в который поместить запуск всех остальных скриптов. Поверьте на слово - это значительно съэкономит ваше время в дальнейшем. Например, если в задачу 000001/VER001/ входят файлы: db1.sql., db2.sql, db3.sql, то файл start.sql может быть представлен следующим способом: 
************************* start.sql *******************************
Spool 000001.log
@db1.sql
@db2.sql
@db3.sql
spool off
***************************************************************
При этом необходимо помнить, что все файлы должны быть в кодировке той среды, из которой вы собираетесь запускать SQL+ (KOI8, Win1251, DOS). 

ОПЕРАТОРЫ СОЗДАНИЯ ОБЪЕКТОВ БД. 
Перед тем как работать с данными с БД ее надо создать, для этих целей используется специальная группа операторов, предназначенных для создания объектов базы данных, все операторы данной группы начинаются с ключевого слова CREATE. 
CREATE DATABASE 
Создает базу данных. Задает и определяет максимальное число экземпляров файлов данных и журнальных файлов, устанавливает режим архивирования. 
Filespec (журнальные файлы)::= 
-- Скрипт создания БД CLINICS
spool clinic.log
connect internal
startup nomount pfile=/oracle/dbs/initclinic.ora
-- создаем базу данных с именем clinics
create database ""clinics""
    maxinstances 1
    maxlogfiles  10
    character set ""RU8PC866""
    national character set ""RU8PC866""
    datafile
'/oracle/db/system01.dbf' size   100M
    logfile
'/oracle/db/lo  g01.dbf' size 1M,
'/oracle/db/log02.dbf' size 1M;
disconnect
spool off
CREATE TABLESPASE 
Создает в базе данных область для хранения таблиц, сегментов и индексов, определяет файлы базы данных, параметры хранения по умолчанию и режим табличного пространства (автономный или оперативный). 
CREATE USER 
Создает пользователя базы данных. (синтаксис команды приведен упрощенно, за дополнительной информацией обратитесь к документации). 
CREATE SCHEMA 
Создает несколько таблиц и представлений и предоставляет некоторые привилегии в одной транзакции. 
 
CREATE TABLE 
Создает новую таблицу БД, определяя ее столбцы, правила целостности и параметры хранения. 
Пример: 
 )   tablespace users;
CREATE SYNONYM 
Создает синоним для таблицы, представления, последовательности, хранимой процедуры или функции, пакетной процедуры, моментальной копии или другого синонима. 
Пример: Сначала удаляем публичный синоним для таблицы DOCTORS, а потом его заново создаем. 
drop public synonym DOCTORS;
create public synonym DOCTORS for DOCTORS;
CREATE INDEX 
Создает индекс для заданных столбцов таблицы или кластера. 
Пример: 
create  UNIQUE  index I_DOCTORS  on DOCTORS (
   DC_NNN
 ) tablespace users;
CREATE TRIGGER 
Создает триггер базы данных. 
CREATE SEQUENCE 
Создает новую последовательность для генерации первичных ключей. 
Пример: 
create sequence S_DOCTORS;
Пример: Приведем полный текст скрипта для создания триггера для таблицы DOCTORS, который будет следить за автоматическим увеличением значения поля DC_NNN на единицу при добавлении каждой новой записи в таблицу DOCTORS, что потребует от нас использование и такой конструкции - как сиквенс (генератор последовательностей). 
-- Сначала удаляем предыдущие изменения в базе (если конечно они были сделаны)
drop sequence S_DOCTORS;
drop trigger tr_DC_NNN;
drop public synonym DOCTORS;
-- создаем таблицу
-- назначаем права доступа
-- создаем публичный синоним
CREATE PUBLIC SYNONYM DOCTORS FOR DOCTORS;
-- создаем сиквенс и устанавливаем его начальное значение в единицу
create sequence S_DOCTORS
start with 1;
-- создаем индексы
create unique index i_dc_nnn on doctors(dc_nnn);
create index i_dc_name on doctors(dc_name);
-- создаем триггер
create trigger tr_dc_nnn
before insert
on doctors
for each row
begin
  select dc_nnn.nextval into :new.dc_nnn from dual;
end;",1
8,Методологии разработки программного обеспечения 2.docx,"Методологии разработки программного обеспечения
В данный момент нет необходимости разрабатывать методологию разработки программного обеспечения (ПО) ""с нуля"". Существует широкий выбор готовых методологий на все случаи жизни. И, хотя, практически каждый достаточно опытный руководитель разработки программного обеспечения со временем находит свои, более удобные для решаемых задач, методы, все же за основу берется одна из стандартных, общепризнанных методологий.
Как же выбрать нужную методологию разработки ПО из такого множества вариантов? По каким параметрам можно оценить различные методологии и оценить их эффективность для решаемых задач? Основными метриками, обычно, называют уровень формализма и модель жизненного цикла проекта.
Различные модели жизненного цикла могут изменяться от итеративной до каскадной разработки и подробно описаны на странице этапы выполнения работ.
По степени формализма методологии могу отличаться по количеству создаваемых документов, степени их актуальности, аккуратности, полноты заполнения и формальности процедур рецензирования.
 Неконтролируемая разработка -  имеет 2 основных проявления. Когда правил разработка ПО нет вообще, либо когда они не выполняются. Чаще всего используется новичками в разработке либо коллективами, в которых разработка программ не является профильной деятельностью. Обычно основывается на личном опыте главного разработчика либо руководителя разработки. Степень формализма низкая. Документирование разработки может отсутствовать как класс, либо заканчиваться на комментировании кода и рисовании пары картинок с общей структурой проекта. Модель жизненного цикла может быть любой, либо даже смешением нескольких моделей.
Гибкие методологии (Agile) - в последние годы получили активное развитие и приобрели большую популярность. Основываются на 12 основных принципах:
1. Главным приоритетом является удовлетворение потребностей заказчика за счет ранней и непрерывной поставки работоспособного программного обеспечения.
2. Приветствуются меняющиеся требования, даже на поздних стадиях разработки. Гибкие процессы используют изменения как средство получить конкурентные преимущества для заказчика.
3. Поставлять работоспособное программное обеспечение часто: от раза в несколько недель, до раза в несколько месяцев, отдавая предпочтение коротким интервалам.
4. Представители заказчика (бизнеса) и разработчики должны работать вместе в течение всего проекта.
5. Проекты строятся вокруг мотивированных личностей. Предоставьте им среду и поддержку, в которой они нуждаются, и доверьте им самим сделать работу.
6. Наиболее эффективный способ передачи информации в команду проекта (а также передавать её внутри команды) - это непосредственное живое общение.
7. Основной мерой прогресса проекта является работоспособное программное обеспечение.
8. Гибкие процессы поощряют разработку с постоянной скоростью. Спонсоры проекта, разработчики и пользователи должны быть способны поддерживать постоянную скорость на неограниченной дистанции.
9. Постоянное внимание техническому совершенству и хорошему дизайну увеличивает степень гибкости.
10. Простота - искусство максимизации работы, которую не надо делать, - является существенным фактором.
11. Наилучшие архитектурные решения, требования и дизайн создаются самоорганизующимися командами.
12. Через регулярные промежутки времени команда должна проводить анализ того, как стать более эффективной и улучшать свой процесс работы.
 Таким образом, методология является ориентированной на итеративную разработку и минимальную формализацию процесса.
Число методологий, относящихся к этой группе, велико. Самые известные из них eXtreme Programming (XP)  - экстремальное программирование, Crystal Clear и Feature Driven Development (FDD) - функционально-ориентированная разработка.
Экстремальное программирование - пожалуй, наиболее известная из гибких методологий. Состоит из 12 основных принципов: игра в планирование, переработки кода (refactoring),  короткие релизы, метафоры, простой дизайн, разработка «тестами вперед», коллективное владение кодом, парное программирование, 40-часовая рабочая неделя, постоянное присутствие заказчика и стандарты кода. При использовании XP тщательное планирование разработки ПО заменяется на постоянной присутствие заказчика, готового ответить на любые вопросы разработчиков и постоянную переработку (рефакторинг) кода. Низкая формализация разработки обычно не идет дальше хорошего комментирования кода, что позволяет сократить большое количество времени разработки, а следовательно, снизить общую стоимость разработки. При этом существенное внимание уделяется тестированию. Зачастую для каждого модуля системы сначала пишется тест, который продолжает выполняться на протяжении всей разработки после любого изменения кода. Впрочем, не все принципы являются строго обязательными. Например 40-часовая рабочая неделя и парное программирование носят второстепенный характер.
Crystal Clear - методология, позволяющая менять  степень формализации процесса разработки в зависимости от критичности задач и количества участников разработки. Основные особенности: итеративная инкрементная разработка, автоматическое регрессионное тестирование, пользователи привлекаются к активному участию в проекте, состав документации определяется участниками проекта, как правило, используются средства контроля версий кода. Ориентирована на поддержание естественных привычек разработчиков. Считается, что если в организации не используется какая-то определенная методология, то достаточно квалифицированный коллектив рано или поздно сам естественным образом придёт к этой Crystal Clear.
Feature Driven Development (FDD) - функционально-ориентированная разработка. Разработка состоит из 5 основных этапов: разработка общей модели, составление списка необходимых функций системы, планирование работы над каждой функцией, проектирование функций, конструирование функций. Работа над проектом происходит итеративно, частый выпуск версий, каждая из которых реализует определенный набор функций.
SCRUM - методология, предназначенная для небольших команд (до 10 человек). Весь проект делится на итерации (спринты) продолжительностью 30 дней каждый. Выбирается список функций системы, которые планируется реализовать в течении следующего спринта. Самые важные условия - неизменность выбранных функций во время выполнения одной итерации и строгое соблюдение сроков выпуска очередного релиза, даже если к его выпуску не удастся реализовать весь запланированный функционал. Руководитель разработки проводит ежедневные 20 минутные совещания, которые так и называют - scrum, результатом которых является определение какие функции системы были реализованы за предыдущий день, с какими сложностями столкнулись и что планируется сделать за следующий день. Такие совещания позволяют постоянно отслеживать ход проекта, быстро выявлять возникшие проблемы и оперативно на них реагировать.
Разработка по ГОСТ не является методологией разработки ПО. ГОСТы не описывают сам процесс разработки, а только формулируют предъявляемые к нему требования. В настоящее время используются немного устаревшие, но все еще актуальные ГОСТы 19 и 34 серии, а так же более новый ГОСТ 12207. Следуя ГОСТам разработку следует разделить на несколько строго определенных этапов, по завершении каждого из которых составляется достаточно большая по объему и строго форматизированная документация. Таким образом, разработка программного обеспечения по ГОСТам приводит к каскадному подходу и высокому уровню формализации формализованной разработки. В последнее время такой подход имеет все меньшую популярность и используется в основном для государственных заказчиков.
Rational Unified Process (RUP) — методология разработки программного обеспечения, созданная компанией Rational Software. В основе методологии лежат 6 основных принципов:
Компонентная архитектура, реализуемая и тестируемая на ранних стадиях проекта.
Работа над проектом в сплочённой команде, ключевая роль в которой принадлежит архитекторам.
Ранняя идентификация и непрерывное устранение возможных рисков.
Концентрация на выполнении требований заказчиков к исполняемой программе.
Ожидание изменений в требованиях, проектных решениях и реализации в процессе разработки.
Постоянное обеспечение качества на всех этапах разработки проекта.
Использование методологии RUP направлено на итеративную модель разработки. Полных жизненный цикл программы состоит из 4 фаз:
Inception (начало)
Elaboration (проектирование)
Construction (построение)
Transition (внедрение)
Особенность методологии состоит в том, что степень формализации может меняться в зависимости от потребностей проекта. Можно по окончании каждого этапа и каждой итерации создавать все требуемые документы и достигнуть максимального уровня формализации, а можно создавать только необходимые для работы документы, вплоть до полного их отсутствия. За счет такого подхода к формализации процессов методология является достаточно гибкой и широко популярной. Применима как в небольших и быстрых проектах, где за счет отсутствия формализации требуется сократить время выполнения проекта и расходы, так и в больших и сложных проектах, где требуется высокий уровень формализма, например, с целью дальнейшей сертификации продукта. Это преимущество дает возможность использовать одну и ту же команду разработчиков для реализации различных по объему и требованиям проектов без необходимости освоения новой методологии.

Технологии разработки программного обеспечения
Существует множество платформ для разработки Web-приложений (.Net Framework, Java, PHP, Python и многие другие). Большая часть выполненных нами проектов работают со следующей связкой:
Web-сервер IIS 7.0, установленный на  Windows Server 2008 RC2 – новейшая разработка компании Microsoft, сочетающая в себе простоту настройки, легкость управления, высокую производительность и безопасность.
Среда разработки MS Visual Studio 2008, Framework 3.5 – мощное и простое в использовании средство для быстрой и эффективной разработки приложений с использованием всех передовых технологий. Платформа позволяет, при необходимости, легко перенести часть функционала или превратить всю систему в обычное приложение Windows.
Язык программирования C# + JavaScript для клиентских скриптов. C# - популярный и мощный язык программирования, позволяющий разработать сложные приложения. JavaScript – скриптовый язык, выполняемый браузером пользователя. Существенно повышает удобство использования системы, позволяет производить оперативные подсчеты и использовать красивые эффекты.
Сервер баз данных MSSQL Server 2005 (2008) – одна из самых популярных систем управления базами данных. Имеет высокую производительность, позволяет работать с большими объемами данных, есть бесплатный вариант для небольших приложений, множество дополнительных функций, удобная среда разработки.
Большинство разрабатынных приложений это веб-приложения, т.е. приложения, к которым можно получить доступ из любой точки мира посредством сети Интернет.  Приложения представляют собой сайт, войдя в защищенную область которого пользователь получает весь необходимый ему функционал.
Почему же именно эта технологическая платформа была выбрана нами приоритетной в разработке программного обеспечения? Давай оценим ее достоинства и недостатки.
Достоинства:
•    Получить доступ к системе может любой человек из любой точки мира с практически любого устройства, подключенного к интернет. Это может быть компьютер, ноутбук или даже мобильный телефон. Единственное требование – подключение к Интернет и возможность запустить браузер для просмотра сайтов.
•    Доступность системы 24 часа в сутки 7 дней в неделю 365 дней в году.
•    Любые данные или изменения, внесенные пользователем в систему, тут же становятся доступны всем остальным пользователям системы.
•    Существенно снижаются требования, предъявляемые к аппаратному обеспечению пользователей. Это может быть старенький, маломощный компьютер покажет высокую производительность, ведь все вычисления происходят на сервере, а клиенту передаются только обработанные данные.
•    Повышенная надежность и сохранность данных. Все данные хранятся на сервере, следовательно, легко создавать резервные копии. Данные никуда не пропадут и не потеряются. 
•    Безопасность доступа к данным не ниже, чем при работе с обычными, десктопными, приложениями. При необходимости, безопасность может быть легко повышена за счет создания защищенного соединения и дополнительной идентификации пользователе с помощью аппаратных или программных ключей.
•    Защита данных. Все данные находятся на удаленном сервере, защищенном от взломов, вирусов, троянов и прочего вредоносного ПО.
•    Дешевизна обслуживания системы обусловлена тем, что не требуется никакой дополнительной защиты, не нужно создавать дополнительные серверные или аппаратные комнаты и мощными и дорогими серверами. Достаточно лишь найти подходящего провайдера, который позаботиться об этом сам, либо разместить сайт на одной из наших площадок. Подробнее он услуге читайте на станице размещение и поддержка сайтов.
•    Легкая масштабируемость. Если вам нужно предоставить доступ к системе новому пользователю или группе то, все что вам нужно – просто предоставить им учетные данные для входа в систему.
•    Если нагрузка на сервер слишком возросла  - Вам нужно просто поставить более мощный сервер или, если сервер находится у хостинг-провайдера, договориться о другом тарифном плане.
•    Нет необходимости покупать дорогое программное обеспечения для серверов и рабочих станций. Его можно взять в аренду у хостера вместе с сервером.

Недостатки:
•    Требуется доступ в Интернет. Некоторые приложения могут требовать хороший канал связи.
•    Иногда невозможно реализовать некоторые функции, доступные десктопному приложению.
Описанная платформа является основной, но не единственной. Каждая зада уникальна и для каждого случая может быть подобрано индивидуальное решение. При необходимости проект может быть разработан, например, с использование только Open Source решений, для мобильной платформы или для других операционных систем (Linux, MacOS).

Этапы разработки программного обеспечения
Обычно, говоря о разработке программного обеспечения (ПО), выделяют 6 основных этапов:
1.    Планирование
2.    Составление требований
3.    Проектирование
4.    Разработка
5.    Тестирование
6.    Сопровождение
Последовательность и длительность этапов зависит от выбранной методологии разработки ПО и может существенно отличаться.
Планирование программного проекта - в зависимости от потребностей и выбранной методологии разработки может либо вообще отсутствовать, либо занимать достаточно большую часть разработки. На этом этапе определяются основные задачи, которые должны быть решены в рамках разработки ПО, производится оценка необходимого функционала, техническое обследование объекта автоматизации, оценка финансовых, временных, человеческих, технических и других ресурсов, необходимых для осуществления разработки. Так же определятся, какие будут использованы методы разработки и тестирования. Могут быть построены временные графики, составлен бюджет, план работ и прочие документы.
Составление требований заказчика - на этом этапе происходит сбор, анализ и формализация требований к разрабатываемому ПО со стороны заказчика. Этап служит для выработки максимального взаимопонимания между заказчиком и исполнителем. Обсуждаются форма предоставления информации, необходимый функционал, проблемы и ограничения, которые могут возникнуть при разработке. Составленные требования могут быть протестированы.
Проектирование программного продукта - на этом этапе происходит разработка и детализация модели разрабатываемого программного продукта. На основании построенной модели определяется структура и архитектура ПО, организация и взаимодействие модулей и интерфейсов, структура базы данных, строится диаграмма классов и т.д.. Процесс проектирования проводится с учетом методологии, выбранной на этапе планирования. Может быть составлен прототип разматываемого ПО.
Разработка программного обеспечения - единственный этап, которые не может быть пропущен, вне зависимости от выбранной методологии. На этом этапе происходит преобразования результатов проектирования системы в программный код на используемом языке программирования в соответствии с используемыми стандартами кодирования. На этом же этапе разработчики предоставляют информацию инженерам по тестированию для разработки комплекса тестов, разрабатывают техническую документацию и производят планирование интеграции ПО.
Тестирование программного обеспечения - этап, не имеющий четко определенного начала. Может начаться еще на этапе составления требований. Чем раньше начнется тестирование тем выше вероятность, что программное обеспечение будет в точности соответствовать требованиям и потребностям заказчика, тем раньше будут выявлены критические ошибки проектирования и разработки и тем дешевле обойдется их исправление. Тестирование может проводиться в ручном или автоматическом режиме. По результатам тестов составляется отчет. Методы и виды тестирования подробно описаны на странице тестирование программного обеспечения.
Сопровождение программного обеспечения - на этом этапе основное внимание уделяется внесению изменений в программное обеспечение. Изменения могут быть связаны с доработками по желанию заказчика, устранением ошибок, изменением функционала или среды окружения. Так же осуществляется консультация, обучение и поддержка пользователей.
Перечисленные этапы, в зависимости от выбранной методологии и модели жизненного цикла, могут следовать друг за другом (в каскадной модели), проходить параллельно либо периодически (в итерационной модели). Под моделью жизненного цикла разработки программного обеспечения подразумевается последовательность процессов, задач и действий, выполняемые при разработке программного обеспечения. Выбор модели зависит от требований, предъявляемых к разработке, выбранной методологии, сложности проекта и прочих условий.
 
Наибольшей популярность пользуются:
1.    Каскадная модель (водопад)
2.    V-образная модель
3.    Прототипирование
4.    Быстрая разработка (RAD-модель)
5.    Многопроходная модель
6.    Спиральная модель
Каскадная модель (водопад) - все этапы разработки следуют друг за другом в строгой последовательности. Переход к следующему этапу происходит только после окончания предыдущего. Возвращение к пройденным этапам и внесение изменений не предусмотрено. По завершении каждого этапа создается полный комплект документации. Качество разработанного программного обеспечения оценивается по точности соответствования требованиям технического задания. Каскадный подход обычно применяют, если в начале разработки удается достаточно точно сформулировать все требования. В током случае разработка идет выполняется в логичной последовательности, что позволяет достаточно точно оценить сроки выполнения работ и их стоимость. К недостаткам модели относится отсутствие гибкости, сложность и дороговизна внесения изменений в разрабатываемый проект.
V-образная модель - является одной из разновидностей каскадной модели. Особое внимание уделяется тестированию продукта. Выполнение всех этапов разработки происходит, как и в каскадной модели, последовательно. Отличие состоит в том, что каждому из этапов проектирования и разработки соответствует определенный этап тестирования. Так, после кодирования выполняется Модульное и Интеграционное тестирование, проверяющее качество проектирования и реализации системы, затем выполняется Системное тестирование, проверяющее соответствие и правильность требований к программному продукту. Затем начинает этап эксплуатации и сопровождения, на котором проверяется работоспособность проекта в целом и его соответствие поставленным задачам. По сравнению с Каскадной моделью имеет преимущество в высоком качестве тестирования и контроля разработки. Модель, чаще всего, использует если предъявляются особо высокие требования к надежности программного обеспечения.
Модель прототипирования - отличается от предыдущих моделей тем, что на ранних этапах проектирования и разработки программного продукта создается его прототип. Потенциальные пользователи начинают использовать созданный прототип, выявляют его сильные и слабые стороны. За счет этого обеспечивается обратная связь между пользователями и разработчиками, позволяющая вносить изменения в проект на ранних этапах его разработки и проектирования, что существенно снижает стоимость вносимых изменений и максимально приближает готовый продукт к потребностям заказчика. Данная модель, обычно, применяется в случаях, когда требования к разрабатываемому программному обеспечению заранее не известны, неполны или требуют уточнения. Так же эта модель хорошо использовать, если производится новая разработка, не имеющая аналогов.
Модель быстрой разработки (RAD-модель) - как понятно из названия, модель направленна на быструю разработку приложений. Особенность модели состоит в постоянном привлечении к работе заказчика, что существенно снижает риски внесения изменений в проект на поздних стадиях, укоряет выработку требований и апробацию прототипов разрабатываемого программного обеспечения. Разработка ориентирована на автоматизацию программирование, повторное использование кода и использование уже готовых сторонних модулей.
Многопроходная модель (Итерационная) -  отличается тем, что этапы проектирования, кодирования и тестирования программного продукта за все время разработки проводятся насколько раз (проходят насколько итераций).
Спиральная модель - очень похожа на многопроходную модель. Особенность модели состоит в том, что ПО создается не сразу целиком, а по частям. Создается прототип, который можно начинать использовать. При этом производится постепенное наращивание функционала, улучшение и переработка интерфейса, доработки и исправление ошибок. При выборе спиральной модели не требуется раннее формулирование всех требований к программному обеспечению, поскольку они уточняются в процессе разработки. Модель заключает все достоинства каскадной и интеграционной модели, позволяет заказчику увидеть программный продукт на более ранних этапах и вовремя внести корректировки в разработку. Особенность модели состоит в том, что она может не иметь четко ограниченных по времени этапов и продолжать до бесконечности, поскольку любая реакция заказчика может вызвать новый цикл разработки. Является одной из самых гибких моделей. Подходит для больших и очень сложных проектов, а так же для проектов, требования к которым заранее не известны.

Тестирование (системы качества)
Вопрос качества разрабатываемого программного обеспечения становиться все более актуальным, особенно если речь идет о продуктах, обеспечивающих выполнение основного бизнес-процесса компании, о фронт-офисных продуктах, которые используют клиенты, или о продуктах к надежности которых предъявляются повышенные требования.
Основная задача тестирования – проверка,с оответствует ли работа программы предъявляемым требованиям. По другому, выполняет ли программа то, что от нее ожидает заказчик. 
Тестирование может начать еще на этапе согласования с заказчиком требований к програмному продукту. Чем раньше начнется тестировани и чем раньши будут выявлены ошибки тем дешевле обойдется их исправлени.
В зависимых от предъявляемых тербований к програмному обеспечению тестироватся могут сами требования, на полноту и непротиворечивость, крограмный код, на наличие ошибок, функционал системы, на соответствие требованиям и документация на полноту, соответствие требованиям и работе системы.
Можно выделить  пять уровней тестирования: модульное, интеграционное, системное, выходное и приемочное.
Модульное тестирование – этот этап тестирования является частью разработки. Проводится непосредственно разработчиками  и представляет собой проверку отдальных частей системы (модулей), отдлельных процедур или функций системы. На этом этапе производится проверка правильности работы функционала, организации данных каждого модуля, производится синтаксическая проверка программного кода, соответствие стандартам кодирования и производится технических обзор кода.
Интеграционное тестирование – в ходе этапа производится проверка совместной работы отдельных модулей, связь между модулями, корректность обмена данными, проверка функциональности, проверка промежуточных результатов работы модулей и проверка интерграции. Осущаствляется тестировщками. По результатам тестирования составлется отчет.
Системное тестирование – производится проверка программного продукта вцелом, проверка фунциональности, соответствования трбованиям, тестирование работы системы в граничных условиях, проверка документации. Если удается – производится целевое тестирвоание – проверка работы системы на целевой платформе. Выполняется тестироващиком после завершения интерграционного тестирования. По результатам тестов составляется отчет.
Выходное тестирование – производится на завершающем этапе разработки. Проверяется готовность системы к запуску в эксплуатацию. Производится конечное тестирование системы, проверка  подсистмы инсталяции (если такая система предусмотрена функцоналом), проверки документации пользователем. Может осуществляться проверка совместимости с предыдущими версиями, сторонним ПО и прочее. По редультатам тестирования составляется отчет, поторый предоставляется заказчику всесте с готовым программным продуктом.
По желанию заказчика может производиться приемочное тестирование. Обычно проводится, если програмное обеспечения будет поддерживать и обслуживать не огранизация-разработчик, а сторонняя обслуживающая организация.
Основными задачами тестирования обычно считают выявление программных ошибок и проверка соответствия работы системы техническим требованиям. Програмные ошибки деляться на функциональные недостатки, недостатки интерфейса, недостатки производительности, некорректная обработка ошибок, некорректная обработка входных данных, в частности, пограничных данных, ошибки вычисланий, ошибки управления потоком, ошибки «гонок», перегрузки, некорректная работа а аппаратным обеспечением.
Функциональные недостатки – ситуации, когда программа на выполняет одну или часть своих функций либо выполняет их не верно и не полностью. Функционал программы должен быть подробно описан в спецификации. Именно  на основании расхождения спецификации и фуктической работы системы принимается решение о функциональных недостатках программы.
Недостатки интерфейса могут быть выявлены в процессе работы с программным продуктом. Это можно сделать либо в результате эксплуатации готового программного обеспечения либо по средством создания прототипа, на котором производится проверка, уточнение и согласование требований. Создание прототипа является более предпочительнам, т.к. позволяет внести изменения в интерфейс и функционал программы до полного его завершения и ввода в эксплуатацию. Это может существенно удешевляет разработку и позволяет сделать программу более удобной для пользователей и более точно соответствующею выполняемым задачам.
Недостаточная производительность – может являться существенным недостатком, особенно если в спецификации на разработку указаны строгие требования к производительности.  Даже если четки требований нет, слишком медленная работа программы будет создавать у пользователей негативное впечатление и требует оптимизации.
Некорректная обработка ошибок – программа не должна аварийно завершать работу или продолжать работать не правильно при ошибочных действиях пользователя или не корректных входных данных. Все возникающие ошибки должны быть обратотаны, а пользователь должен получить корректное и понятно сообщение.
Некоррекная обработка граничных условий – часто бывает так, что программа хорошо работает на большом диапазоне входных данных. Однако, можеть оказать, что программа не верно обрабатывает какой-то специфичный набор входных данных. Такие ситуации должны быть рассмотрены и описаны аналитиком на этапе проектирования системы и проверены тестеровщиком при ее тестировании.
Ошибки вычисления – обычно носят математический характер. Могут быть связаны с неправильным выбором алгоритма расчета, не правильной формулой, недостаточной точностью вычислений, ощибкой округления и другими факторами.
Ошибки управления потоком и ошибки гонок - чаще всего связаны с не правильным проектирование системы. Типичны для многопользовательский распределенных систем. Возникают,если порядок выполнений определенных действий в системе не соответствует проэктируемому и ожидаемому результату. Являются очень сложными для тестирования и воспроизведения. 
Перегрузки – могут быть связаны как с нехваткой системы резурсов для работы программы, например памяти, мощности процессора, мест на диске, так и со слишком большой нагрузкой на программу – большое число одновременно работающих пользователей, слишком большой объем обрабатываемых данных и т.д. Работы программы в таких ситуация должна быть продуманна заранее и описани в требованиях к программному обеспечению.
Некорректная работа с  аппаратным обеспечением – могут возникать, если программа пытается использовать некорректно работающее устройство, либо устройство, на работу с которым программа не расчитана. Такие ситуации должны корректно обрабатываться и не приводить к сбоям или зависания программы. Ошибка, наиболее характерна для компьютерных игр.
Помимо тестирования самого програмного продукта производится тестирование документации. Документация тестируется на соответствие тербования, полноту, понятность для пользователя и точность соответствия разрабатываемому програмному обеспечению. Часто бывает так, что в процессе разработки было принято решение изменить, добавить или удалить часть функционала или, например, был изменен интерфейс. По завершении проекта необходимо убедиться что окончательная версия документации точно соответствует окончательной версии програмного обеспечения. В противном случае, внести соответствующие изменения.

Документирование разработки ПО
 Согласно государственным и международным стандартам, при разработке программного обеспечения могут быть составлены следующие документы:

•    Техническое задание
•    Эскизный проект
•    Технический проект
•    Рабочий проект
•    Программная документация
   -    Спецификация
   -    Ведомость держателей подлинников
   -    Текст программы
   -    Описание программы
   -    Программа и методика испытаний
   -    Пояснительная записка
•    Эксплуатационные документы
   -    Ведомость эксплуатационных документов
   -    Формуляр
   -    Описание применения
   -    Руководство системного программиста
   -    Руководство программиста
   -    Руководство оператора (пользователя)
   -    Описание языка
   -    Руководство по обслуживанию (руководство администратора)
Содержание этих документов строго регламентировано  ГОСТ 19 (Единая система программной документации (ЕСПД)), с которыми Вы можете ознакомиться на странице нормативные документы. 
Не в каждом проекте требуется создавать весь перечень документов. Мы не тратим Ваши деньги на создание тонн макулатуры, которая в результате Вам не понадобиться.  Для большинства проектов бывает достаточно 2-3х документов. Обычно это техническое задание и документация пользователя и администратора системы. Однако, по требованию заказчика, для любого из проектов может быть предоставлен полный перечень документов, соответствующий государственным или международным стандартам или стандартам, разработанным заказчиком.
Документация может быть разработана как для всего программного комплекса, так и для отдельных его компонентов.",1
26,Методологии разработки программного обеспечения.docx,"Методологии разработки программного обеспечения
Введение
Вначале сформулируем цели, без которых невозможен ни один проект. Основная задача любого успешного проекта заключается в том, чтобы на момент запуска системы и в течение всего срока ее эксплуатации можно было обеспечить:
• требуемую функциональность системы и степень адаптации к изменяющимся условиям ее функционирования;
• требуемую пропускную способность системы;
• требуемое время реакции системы на запрос;
• безотказную работу системы в требуемом режиме, то есть: готовность и доступность системы для обработки запросов пользователей;
• простоту эксплуатации и поддержки системы;
• требуемую безопасность.
Производительность является главным фактором, который определяет эффективность системы. Хорошее проектное решение — основа высокопроизводительной системы.
Проектирование информационных систем охватывает три основные области:
• проектирование объектов данных, которые будут реализованы в базе данных;
• проектирование программ, экранных форм, отчетов, которые будут обеспечивать выполнение запросов к данным;
• учет конкретной среды или технологии: топологии сети, конфигурации аппаратных средств, использования архитектур «файл-сервер», «клиент-сервер», параллельной обработки, распределенной обработки данных и т.п.
В реальных условиях проектирование информационных систем — это поиск способа, который обеспечивает необходимую функциональность системы средствами имеющихся технологий с учетом заданных ограничений.
Под методологией разработки подразумевается набор методов и критериев оценки, которые используются для постановки задачи, планирования, контроля и в конечном итоге — для достижения поставленной цели. Сам процесс разработки описывается моделью, которая определяет последовательность наиболее общих этапов и получаемых результатов.
Долгое время процесс разработки ПО осуществлялся в соответствии с методиками, наработанными в инженерной области, — стандартная практика поэтапного создания продукта, начиная с составления спецификаций и заканчивая поставкой заказчику. Существуют стандарты ГОСТ (Россия) и ISO (Европа, Россия), CMM (Capability Maturity Model — распространен в США), регламентирующие данный процесс.
Известны несколько основных моделей жизненного цикла ПО.
Каскадная модель — переход на следующий этап означает полное завершение работ на предыдущем этапе.
Поэтапная модель с промежуточным контролем — разработка ПО ведется итерациями с циклами обратной связи между этапами. Межэтапные корректировки позволяют уменьшить трудоемкость процесса разработки по сравнению с каскадной моделью, но время жизни каждого из этапов растягивается на весь период разработки.
Спиральная модель — особое внимание уделяется начальным этапам разработки: выработке стратегии, анализу и проектированию, где реализуемость тех или иных технических решений проверяется и обосновывается посредством создания прототипов (макетирования). Каждый виток спирали предполагает создание некой версии продукта или какого-либо его компонента; при этом уточняются характеристики и цели проекта, определяется его качество и планируются работы следующего витка спирали.
Активное программирование и его клоны — наиболее популярным для данной модели стало экстремальное программирование (extreme Programming, XP). Отцом-идеологом XP считают Кента Бека (Kent Beck). XP является довольно молодой методологией, оценки которой весьма противоречивы: от восторженных до резко негативных. Основными принципами являются простота решений и интенсивная разработка малыми группами, активное общение в группе и обратная связь с клиентом, фактически вовлеченным в процесс разработки, а также известная доля куража.
Ниже мы рассмотрим классические модели, а об экстремальном программировании расскажем в отдельной части данной статьи.
Жизненный цикл программного обеспечения (ПО) представляет собой модель его создания и использования. Данная модель отражает его различные состояния, начиная с момента возникновения потребности в данном ПО и заканчивая моментом его полного выхода из употребления у всех пользователей. Модели различаются способом взаимосвязи этапов жизненного цикла, но каждый из этих этапов в том или ином виде присутствует в каждой модели. Ниже мы последовательно рассмотрим все эти этапы.

Стратегия
Определение стратегии предполагает обследование системы. Основная задача обследования — это оценка реального объема проекта, его целей и задач, а также получение определений сущностей и функций на высоком уровне. На этом этапе привлекаются высококвалифицированные бизнес-аналитики, которые имеют постоянный доступ к руководству фирмы; также предполагается тесное взаимодействие с основными пользователями системы и бизнес-экспертами. Основная задача такого взаимодействия — получить как можно более полную информацию о системе, однозначно понять требования заказчика и передать данную информацию в формализованном виде системным аналитикам. Как правило, информация о системе может быть получена на основании ряда бесед (или семинаров) с руководством, экспертами и пользователями.
Итогом этапа определения стратегии становится документ, где четко сформулировано следующее: что именно причитается заказчику, если он согласится финансировать проект; когда он сможет получить готовый продукт (график выполнения работ); во сколько это ему обойдется (график финансирования этапов работ для крупных проектов). В документе должны быть отражены не только затраты, но и выгода, например время окупаемости проекта, ожидаемый экономический эффект (если его удается оценить).
Определение стратегии — это принципиальный ответ на вопросы типа: «Будем ли мы делать этот проект за такие-то деньги или нет?» или «Делаем ли мы в принципе этот проект с данным разработчиком?» Иными словами, в результате определения стратегии разработчик и заказчик принимают решение о продолжении работ на определенных условиях с определенными обязанностями сторон.
Следует выделить набор фактов, которые должны быть обязательно отражены в заключительном документе после проведения обследования и анализа деятельности предприятия:
• ограничения, риски, критические факторы, влияющие на проект;
• совокупность условий эксплуатации будущей системы: архитектура, аппаратные и программные ресурсы, внешние условия ее функционирования; состав исполнителей и работ, обеспечивающих функционирование системы;
• критические сроки завершения этапов, форма сдачи работ, защита коммерческой информации;
• описание выполняемых системой функций;
• интерфейсы и распределение функций между человеком и системой;
• требования к программным и информационным компонентам ПО;
• наличие потенциального развития системы в будущем;
• то, что не будет реализовано в рамках проекта.
Данный этап жизненного цикла ПО может быть представлен в модели только один раз, особенно если модель имеет циклическую структуру, однако это не означает, что в циклических моделях стратегическое планирование производится раз и навсегда. Циклические модели предназначены для решения проблем ПО, которое развивается по времени; анализ текущего состояния ПО и предприятия, его использующего, производится на этапе анализа. Таким образом, в циклических моделях этапы определения стратегии и анализа как бы склеиваются, а вероятность их разделения существует лишь на самом первом витке, когда руководство предприятия принимает принципиальное решение о старте проекта. В целом этап анализа посвящен разработке документа уровня руководства предприятия.

Анализ
Этап анализа предполагает подробное исследование бизнес-процессов (функций, определенных на предыдущем этапе) и информации, необходимой для их выполнения (сущностей, их атрибутов и связей (отношений)). Этот этап дает информационную модель, а следующий за ним этап проектирования — модель данных.
Вся информация о системе, собранная на этапе определения стратегии, формализуется и уточняется на этапе анализа. Особое внимание следует уделить полноте переданной информации, анализу информации на непротиворечивость, а также поиску неиспользуемой или дублирующейся информации. Как правило, заказчик вначале формирует требования не к системе в целом, а к отдельным ее компонентам. И в этом конкретном случае циклические модели жизненного цикла ПО имеют преимущество, поскольку с течением времени с большой вероятностью потребуется повторный анализ, так как у заказчика зачастую аппетит приходит во время еды. На этом же этапе определяются необходимые компоненты плана тестирования.
Аналитики собирают и фиксируют информацию в двух взаимосвязанных формах:
• функции — информация о событиях и процессах, которые происходят в бизнесе;
• сущности — информация о вещах, которые имеют значение для организации и о которых что-либо известно.
Ранее двумя классическими результатами анализа были: иерархия функций, которая разбивает процесс обработки на компоненты («что делается и из чего это состоит»), и модель «сущность-связь» (Entry Relationship model, ER-модель), которая описывает сущности, их атрибуты и связи (отношения) между ними. Эти результаты являются необходимыми, но не достаточными. К достаточным результатам следует отнести диаграммы потоков данных и диаграммы жизненных циклов сущностей, которые описывают динамику системы. В настоящее время существует способ формализации проекта — Unified Modelling Language (UML), позволяющий формально описать различные стороны жизнедеятельности разрабатываемого проекта. Существует достаточно большое количество ПО, реализующего UML, например Rational Rose, Microsoft Visio. О UML мы расскажем в отдельной части данной статьи.

Проектирование
На этапе проектирования формируется модель данных. Проектировщики получают входные данные анализа. Конечным продуктом этапа проектирования являются схема базы данных (если таковая существует в проекте) или схема хранилища данных (ER-модель) и набор спецификаций модулей системы (модель функций).
В случае небольшого проекта одни и те же люди могут выступать в роли и аналитиков, и проектировщиков, и разработчиков. Возникает вопрос, насколько актуальна передача результатов самому себе. В принципе, достаточно актуальна, поскольку часто помогает найти, например, не описанные вообще, нечетко описанные, противоречиво описанные компоненты системы и прочие недостатки, способствует предотвращению потенциальных ошибок, а также даст возможность еще раз подумать.
Все спецификации должны быть предельно точными. План тестирования системы также дорабатывается на этом этапе разработки. Во многих проектах результаты этапа проектирования оформляются в виде единого документа — так называемой технической спецификации. Здесь стоит упомянуть о преимуществах способа UML, который позволяет получить одновременно как документы анализа, которые отличаются меньшей детализацией (их потребители — менеджеры производства), так и документы проектирования (их потребители — менеджеры групп разработки и тестирования). Кроме того, ПО, реализующее UML, позволяет осуществить генерацию кода — как минимум иерархию классов, а также некоторые части кода самих методов.
Задачами проектирования являются:
• рассмотрение результатов анализа и проверка их полноты;
• семинары с заказчиком;
• определение критических участков проекта и оценка ограничений проекта;
• определение архитектуры системы;
• принятие решения об использовании продуктов сторонних разработчиков, а также о способах интеграции и механизмах обмена информации с этими продуктами;
• проектирование хранилища данных: модель базы данных, бета-версия базы данных;
• проектирование процессов и кода: окончательный выбор средств разработки, определение интерфейсов программ, отображение функций системы на ее модули и определение спецификаций модулей;
• определение требований к процессу тестирования;
• определение требований безопасности системы.

Реализация
При реализации проекта важно координировать группу (группы) разработчиков. Все разработчики должны подчиняться жестким правилам контроля исходных тестов. Группа разработчиков, получив технический проект, начинает писать код модулей. Основная их задача состоит в том, чтобы уяснить спецификацию: проектировщик написал, что надо сделать, разработчик определяет, как это сделать.
На этапе разработки осуществляется тесное взаимодействие проектировщиков, разработчиков и групп тестировщиков. В случае интенсивной разработки тестировщик буквально неразлучен с разработчиком, фактически становясь членом группы разработки.
Проектировщик на этапе разработки выполняет функцию «ходячего справочника», поскольку должен постоянно отвечать на вопросы разработчиков, касающиеся технической спецификации.
Чаще всего на этапе разработки меняются интерфейсы пользователя. Это обусловлено, наряду с прочим, периодической демонстрацией модулей заказчику. Также могут существенно изменяться запросы к данным.
Следует отметить необходимость существования выделенного рабочего места, где происходит сборка всего проекта. Именно эти модули передаются на тестирование. Взаимодействие тестировщика и разработчика без централизованной передачи допустимо только в том случае, если срочно требуется проверить какую-то правку. Очень часто этап разработки сопряжен с этапом тестирования, и оба процесса идут параллельно. Синхронизирует действия тестеров и разработчиков система bug tracking.
Кроме того, должны быть организованы хранилища готовых модулей проекта и библиотек, которые используются при сборке модулей. Это хранилище постоянно обновляется. Контролировать процесс обновления должен один человек. Одно хранилище создается для модулей, прошедших функциональное тестирование, второе — для модулей, прошедших тестирование связей. Первое — это черновики, второе — то, из чего уже можно собирать дистрибутив системы и демонстрировать его заказчику для проведения контрольных испытаний или для сдачи каких-либо этапов работ.
Следует отметить исключительную важность обмена информацией между проектировщиками, разработчиками, тестировщиками: ошибки должны быть классифицированы согласно приоритетам; для каждого класса ошибок должна быть определена четкая структура действий: «что делать», «как срочно», «кто ответственен за результат»; каждая проблема должна отслеживаться проектировщиком/разработчиком/тестировщиком, отвечающим за ее устранение. То же самое касается ситуаций, когда нарушаются запланированные сроки разработки, передачи модулей на тестирование. Все проблемы при взаимодействии между группами могут стоить достаточно дорого.

Тестирование
Группы тестирования могут привлекаться к сотрудничеству уже на ранних стадиях разработки проекта. Строго говоря, комплексное тестирование следует выделить в отдельный этап разработки. В зависимости от сложности проекта тестирование и исправление ошибок может занимать треть, половину общего времени работы над проектом и даже больше.
Чем сложнее проект, тем больше будет потребность в автоматизации системы хранения ошибок — bug tracking, которая обеспечивает следующие функции:
• хранение сообщения об ошибке (к какому компоненту системы относится ошибка, кто ее нашел, как ее воспроизвести, кто отвечает за ее исправление, когда она должна быть исправлена);
• система уведомления о появлении новых ошибок, об изменении статуса известных в системе ошибок (уведомления по электронной почте);
• отчеты об актуальных ошибках по компонентам системы;
• информация об ошибке и ее история;
• правила доступа к ошибкам тех или иных категорий;
• интерфейс ограниченного доступа к системе bug tracking для конечного пользователя.
Подобные системы берут на себя множество организационных проблем, в частности вопросы автоматического уведомления об ошибках.
Собственно тесты систем можно разделить на несколько категорий:
• автономные тесты модулей; они используются уже на этапе разработки компонентов системы и позволяют отслеживать ошибки отдельных компонентов;
• тесты связей компонентов системы; эти тесты также используются и на этапе разработки, и на этапе тестирования, они позволяют отслеживать правильность взаимодействия и обмена информацией компонентов системы;
• системный тест; он является основным критерием приемки системы; как правило, это группа тестов, включающая и автономные тесты, и тесты связей и модели; данный тест должен воспроизводить работу всех компонентов и функций системы; основная цель данного теста — внутренняя приемка системы и оценка ее качества;
• приемосдаточный тест; основное его назначение — сдать систему заказчику; здесь разработчики часто занижают требования к системе по сравнению с системным тестом, и причины этого вполне очевидны;
• тесты производительности и нагрузки; данная группа тестов входит в системный тест, но достойна отдельного упоминания, поскольку именно эта группа тестов является основной для оценки надежности системы.
В тесты каждой группы обязательно входят тесты моделирования отказов. Здесь проверяется реакция компонента, группы компонентов, системы в целом на отказы вида:
• отказ отдельного компонента информационной системы;
• отказ группы компонентов информационной системы;
• отказ основных модулей информационной системы;
• отказ операционной системы;
• жесткий сбой (отказ питания, жестких дисков).
Эти тесты позволяют оценить качество подсистемы восстановления корректного состояния информационной системы и служат основным источником информации для разработки стратегий предотвращения негативных последствий сбоев при промышленной эксплуатации. Как правило, этим классом тестов разработчики традиционно пренебрегают, а затем вынуждены «лечить» последствия сбоев на промышленной системе.
Еще одним важным аспектом программы тестирования информационных систем является наличие генераторов тестовых данных. Они используются для проведения тестов функциональности системы, тестов надежности системы и тестов производительности системы. Задачу оценки характеристик зависимости производительности информационной системы от роста объемов обрабатываемой информации без генераторов данных решить невозможно.

Внедрение
Опытная эксплуатация перекрывает процесс тестирования. Система редко вводится полностью. Как правило, это процесс постепенный или итерационный — в случае циклического жизненного цикла.
Ввод в эксплуатацию проходит как минимум три стадии:
• первоначальная загрузка информации;
• накопление информации;
• выход на проектную мощность (то есть собственно переход к этапу эксплуатации).
Первоначальная загрузка информации инициирует довольно узкий спектр ошибок: в основном речь идет о проблемах рассогласования данных при загрузке и о собственных ошибках загрузчиков. Здесь требуется применить методы контроля качества данных (в противном случае в дальнейшем наведенные ошибки обойдутся намного дороже). Это то, чего не было или не могло быть отслежено на тестовых данных. Такие ошибки должны быть исправлены как можно быстрее. Не поленитесь поставить отладочную версию системы (если, конечно, вам позволят развернуть весь комплекс сопровождающего отладку информационной системы ПО на месте). Если отладку «на живых» данных произвести невозможно, вам придется моделировать ситуацию, и как можно быстрее. В этом случае требуются очень квалифицированные тестировщики.
В период накопления информации из информационной системы выявляется наибольшее количество ошибок, связанных с многопользовательским доступом. Часто на этапе тестирования им не уделяется должного внимания — из-за сложности моделирования и дороговизны средств автоматизации процесса. Вторая категория исправлений связана с тем, что пользователя не устраивает интерфейс. Здесь не всегда нужно выполнять абсолютно все пожелания пользователя, иначе процесс ввода в эксплуатацию будет бесконечным. В данный момент циклические модели и модели с обратной связью этапов также позволяют снизить затраты.
Этот этап является также наиболее серьезным тестом — тестом одобрения пользователем (customer acceptance tests). Если этого не было сделано на этапе тестирования, то на этапе внедрения это непременно произойдет, и вашим тестировщиком фактически будет ваш собственный заказчик, что не всегда приемлемо, особенно если для последнего это будет несколько неожиданно.
Выход системы на проектную мощность в хорошем варианте — это доводка мелких ошибок и редкие серьезные ошибки.

Эксплуатация и техническая поддержка
Здесь последним документом, от которого зависят разработчики, является документ технической приемки. Итак, проект сдан, разработка завершена, ошибки, с которыми заказчик согласился, описаны в документации, и в идеале стороны довольны друг другом. Документ также определяет необходимый персонал и требуемое оборудование для поддержки работоспособности системы, а также условия нарушения эксплуатации продукта и ответственность сторон. Помимо этого, если документ заключается между сторонами, он содержит условия технической поддержки.
Условия технической поддержки и ситуации, которые подпадают под понятие «техническая поддержка», а также условия оплаты определяются, как правило, в отдельном документе. Иногда в рекламных целях менеджеры разработки пытаются включить в документы обязательства гарантии исправления ошибок на условиях технической поддержки за «икс» дней. Такой подход, возможно, и хорош с рекламной точки зрения, но следует отдавать себе отчет в том, что невыполнение обязательств по техническим причинам намного хуже, чем отсутствие «вкусной» рекламы.

Каскадная модель
Данная модель также носит название «водопад». Классическими представителями реализации данной методологии являются стандарты ISO и CMM.
Модель предполагает следующие свойства взаимодействия этапов:
• модель состоит из последовательно расположенных этапов;
• каждый этап полностью заканчивается до того, как начнется следующий;
• этапы не перекрываются во времени: следующий этап не начинается до тех пор, пока не завершится предыдущий;
• возврат к предыдущим этапам не предусмотрен либо всячески ограничен;
• исправление ошибок происходит лишь на стадии тестирования;
• результат появляется только в конце разработки.
Критерием появления результата является отсутствие ошибок и точное соответствие продукта первоначальной спецификации.

Поэтапная модель с промежуточным контролем
Данная модель еще известна как итерационная модель или «водоворот».
Модель характеризуется следующими свойствами взаимодействия этапов:
• модель состоит из последовательно расположенных этапов (точно так же, как и «водопад»);
• каждый этап имеет обратную связь с предыдущими этапами;
• исправление ошибок происходит на каждом из этапов, сразу при выявлении проблемы — это промежуточный контроль;
• этапы перекрываются во времени по причине наличия обратной связи: следующий этап не начинается, пока не завершится предыдущий; при первом проходе по модели вниз, как только обнаружена ошибка, осуществляется возврат снизу вверх к предыдущим этапам, которые повлекли ошибку; таким образом, фактически этапы оказываются растянутыми во времени;
• результат появляется только в конце разработки, как и в модели «водопад».
Критерием появления результата является приемлемое качество продукта, то есть такое состояние продукта, когда наиболее критические для клиента ошибки устранены, а с наличием непринципиальных для жизнедеятельности системы ошибок клиент согласилcя — данные ошибки описаны в документации и фактически переведены таким образом в разряд особенностей системы.

Спиральная модель
Коммерческими представителями данной методологии являются RUP (Rational Unified Process), MSF (Microsoft Consulting Services), и об этом будет рассказано в следующих частях данной публикации.
Результат появляется фактически на каждом витке спирали. Этот результат, который является промежуточным, анализируется, а затем выявленные недостатки продукта становятся поводом для инициирования следующего витка спирали. Таким образом углубляются и последовательно конкретизируются детали проекта и в итоге выбирается обоснованный вариант, который доводится до реализации. Спираль завершается тогда, когда клиент и разработчик приходят к согласию относительно результата.
Модель предполагает также свойства взаимодействия этапов:
• модель состоит из последовательно расположенных этапов (как и «водопад») в пределах одного витка спирали;
• внутри витка спирали этапы не имеют обратной связи; анализ результата осуществляется в конце витка и инициирует новый виток спирали;
• исправление ошибок происходит на этапе тестирования на каждом из витков спирали; фактически часть ошибок исправляется в пределах одного витка посредством связи этапов кодирования и тестирования; ошибки, которые не могут быть исправлены и требуют более глубоких структурных изменений, инициируют новый виток спирали;
• этапы могут перекрываться во времени в пределах одного витка спирали;
• результат появляется в конце каждого витка спирали и подвергается подробному анализу, анализируются новые требования заказчика и инициируется новый виток спирали;
• при переходе от витка к витку происходит накопление и повторное использование программных средств, моделей и прототипов;
• процесс ориентирован на развитие и модификацию системы в процессе ее проектирования, на анализ рисков и издержек в процессе проектирования.
Отметим, что основная особенность данной методологии состоит в концентрации сложности на начальных этапах жизненного цикла ПО (анализ, проектирование); при этом сложность и трудоемкость последующих этапов в пределах одного витка спирали относительно невысокие. По этой методологии предлагается способ снижения затрат в целом при разработке ПО за счет предотвращения потенциальных ошибок на этапах анализа и проектирования. Этап определения стратегии присутствует на первом витке спирали либо «склеен» с этапом анализа первого витка спирали. ",1
14,Методы композиции и декомпозиции.docx,"Методы композиции и декомпозиции исполняемых UML моделей
1. Введение
Известны три интеллектуальные возможности человека, используемые при разработке программных средств: способность к перебору, способность к абстракции и способность к математической индукции. Однако способность человека к перебору, необходимая при создании и модификации сложных систем, в том числе и программных комплексов, весьма ограничена - в среднем человек может уверенно, не сбиваясь, перебирать в пределах 1000 элементов. Средством преодоления этой ограниченности является способность человека к абстракции, благодаря которой человек может объединять разные предметы или экземпляры в одно понятие, заменять множество элементов одним элементом другого рода, упрощая, тем самым, восприятие. Абстракция лежит в основе моделирования, которое в последнее время получило широчайшее распространение и активно используется в процессе создания программных систем. 
Наиболее популярным языком моделирования в области разработки программного обеспечения на данный момент является графический язык UML (Unified Modeling Language - унифицированный язык моделировании) - язык, предназначенный для визуализации, специфицирования, конструирования и документирования программных систем. Выразительных средств этого языка в совокупности с мощными механизмами расширения достаточно для того, чтобы описать любую программную систему со всех точек зрения, актуальных на различных этапах жизненного цикла. Более того, все шире становится область применения концепций модельно-ориентированной разработки (MDD - Model Drive Development), отводящих моделям главную роль в процессе создания и поддержки системы. 
В рамках таких подходов собственно разработка сводится к последовательному уточнению модели системы, начинающемуся с абстрактной модели и заканчивающемуся готовой программной системой. Таким образом, при использовании MDD сложность создаваемых моделей будет напрямую отражать сложность системы, а работа с моделью может создавать такие же трудности, как те, которые возникают при чтении и понимании большого количества исходного кода на традиционных языках программирования. 
Перечисленные выше факторы обуславливают потребность в методах, позволяющих упрощать восприятие сложных моделей и облегчать работу с ними. В то же время применение таких методов не должно затрагивать важных для пользователей и разработчиков модели свойств системы, например, поведенческих, которые в UML задаются при помощи диаграмм конечных автоматов (statemachine diagrams), диаграмм последовательностей (sequence diagrams) и диаграмм деятельности (activity diagrams). Данное свойство сближает такие методы трансформации моделей с известными приемами рефакторинга объектно-ориентированного программного обеспечения. Однако графическая природа языка UML накладывает свой отпечаток на возникающие проблемы и методы их решения. Кроме того, язык UML продолжает развиваться, и последняя на сегодняшний день версия стандарта UML 2.0 включает в себя множество новых элементов, многие из которых могут быть использованы для упрощения восприятия моделей. 

2. Конечные автоматы UML
Конечные автоматы UML могут описывать поведение следующих элементов исполняемых моделей: активный класс (active class), операция (operation), составное состояние (composite state). В [19] было проведено количественное исследование моделей, используемых в реальных коммерческих проектах. Была составлена представительная выборка таких моделей, анализ которой показал, что, несмотря на наличие достаточно легко понимаемой структуры, почти у 90% исследованных элементов модели (диаграмм, автоматов), оставшиеся 10 % элементов, как правило, весьма сложны и, более того, именно они специфицируют основную логику работы системы. Таким образом, любые попытки понять и проанализировать поведенческие стороны сложной системы будут наталкиваться на необходимость изучения сложных конечных автоматов, описанных посредством громоздких диаграмм состояний. А так как для любой относительно нетривиальной модификации, количество которых за время жизни программной системы может исчисляться сотнями тысяч, требуется понимание логики работы системы, возникает потребность в методах, упрощающих восприятие системы и облегчающих ее понимание. 
Суть предлагаемого подхода состоит в том, что исходная модель сложной системы посредством описываемых преобразований трансформируется и дополняется элементами, образуя иерархическое представление, удобное как в случаях, когда нужно получить представление об общих принципах работы системы, так и в случаях, когда необходим детальный анализ конкретных аспектов. Такие преобразования могут быть классифицированы как методы композиции и декомпозиции автоматных моделей. 
Под композицией в данной работе понимается такое преобразование модели, результатом которого является создание единой новой целостной сущности из нескольких имеющихся сущностей. Например, объединение в одной диаграмме элементов всех диаграмм, описывающих конкретный автомат, есть примитивное преобразование-композиция. Следует отметить, что такая трансформация является примером графической композиции, так как затрагивает только элементы, описывающие графические сущности модели. Как правило, применение композиции способствует получению целостного представления о каком-либо элементе системы; при этом должны быть приняты меры, предотвращающие чрезмерное усложнение создаваемого элемента. 
Под декомпозицией следует понимать преобразование, обратное композиции, то есть такое преобразование, результатом которого является создание нескольких новых сущностей на основе единственной исходной сущности. Для приведенного примера графической композиции обратным будет преобразование, в результате которого элементы одной диаграммы распределяются между несколькими другими диаграммами. 
Применяя композицию и декомпозицию, можно построить иерархическое описание сложных элементов системы, облегчающее ее восприятие. При этом понимание работы системы будет происходить сверху вниз по иерархии описания. Сначала пользователь знакомится с основными компонентами описываемой части модели и принципами их взаимодействия, и далее по необходимости углубляется, переходя к более детальному описанию интересующего его компонента. На практике даже для достаточно сложных конечных автоматов редко требуется больше 4-5 уровней детализации. 
Помимо упомянутого объединения и разбиения на диаграммы, другие способы композиции-декомпозиции автоматов могут быть основаны на использовании такого элемента языка UML, как метки. Их использование позволяет графически отделить участки диаграммы состояний, чтобы, например, перенести их на другую диаграмму или расположить отдельно на исходной диаграмме. Кроме того, введение меток способствует повторному использованию фрагментов диаграмм, так как переход на единожды описанную метку может быть выполнен многократно из различных частей автомата. Однако, так же, как и при написании программ на традиционных языках программирования, использование меток при спецификации автоматов заметно усложняет понимание принципов работы автомата. Особенно затруднительным становится анализ отдельного перехода в автомате, например, с целью выяснения того, в какие состояния автомат может перейти при срабатывании этого перехода, если в последовательности действий этого перехода встречаются команды перехода на метки, а описания этих меток распределены по многочисленным диаграммам. Поэтому, по нашему мнению, использование меток при описании конечных автоматов оправдано лишь в тех исключительно редких случаях, когда действия, выполняемые при срабатывании перехода, настолько сложны, что требуются отдельные диаграммы даже для описания их частей. 

3. Методы композиции и декомпозиции для конечных автоматов UML
В результате проведённого исследования разработано несколько методов композиции (декомпозиции) конечных автоматов UML. Предложенные методы базируются на двух основных идеях: объединение части состояний конечного автомата в структурную единицу конечного автомата - метод, и формирование иерархической единицы конечного автомата - составного состояния. 

3.1. Трансформация «Выделение метода» для конечных автоматов UML
Идея трансформации «Выделение метода» состоит в создании нового метода и переносе части исходного автомата в добавленный метод. Данная трансформация во многом аналогична известному рефакторингу «Выделение метода» для объектно-ориентированных языков программирования, описанному в каталоге Фаулера [6]. Суть традиционной трансформации состоит в выделении участка кода и перемещении его в другой метод. Это позволяет сделать код исходного метода более понятным и повышает вероятность повторного использования выделенного метода. 
Для корректного выполнения традиционного рефакторинга «Выделение метода» требуется тщательный анализ потока данных в выделяемом участке кода, так как все используемые переменные должны быть переданы в метод в качестве параметров, а все изменения переменных должны быть тем или иным образом возвращены исходному методу, если измененные переменные используются в нем далее. 
Для первичного рассмотрения проблемы выделения метода в автомате эту проблему можно обойти следующим образом. Если используемая переменная является атрибутом автомата или сущности, содержащей автомат, то она будет видна и в выделенном методе и, следовательно, ее не нужно передавать в качестве параметра. Если же используемая переменная является локальной для действий, выполняемых в переходе, то при перенесении всех действий перехода в выделяемый метод определение локальной переменной и все ее использования будут также перенесены. Для выделения метода, в который помещаются не все действия, выполняемые в переходе, требуется дополнительный анализ потока данных. 
Следует подчеркнуть исключительную важность автоматизированной поддержки рефакторинга при проведении подобных преобразований, ибо сложность проводимого анализа будет способствовать ошибкам. 
Идея, лежащая в основе традиционного рефакторинга ""Выделение метода"", может быть применена к конечным автоматам несколькими способами. 
Для конечных автоматов UML можно применить традиционную трансформацию «выделение метода», которая состоит из выделения в метод подпоследовательности действий одного из переходов конечного автомата. 
В рамках описываемого исследования был разработан новый вариант трансформации «выделение метода», специфичный только для конечных автоматов UML, - «выделение в метод части конечного автомата», который подразумевает перенос в выделяемый метод не только действий, связанных с переходом, но и самих переходов и состояний. 

3.2. Выделение в метод возвратной части конечного автомата
Назовём возвратной частью конечного автомата для состояния X группу состояний конечного автомата, в которую есть только один вход из некоторого состояния X, и все переходы, выходящие за пределы группы, попадают обратно в X. Между состояниями, входящими в группу, возможны любые переходы, но существует ровно одно состояние, из которого выполняется переход в группу, и куда попадают все переходы, ведущие за пределы выбранной группы состояний. 
Согласно исследованию, проведённому в [19], многие конечные автоматы, используемые в промышленных системах, содержат в себе несколько возвратных частей для различных состояний. Многие из них состоят из 1-3 состояний, однако в каждом третьем конечном автомате с большим количеством состояний встречаются возвратные части из 4 и более состояний. 
Большое количество состояний затрудняет восприятие общей схемы работы конечного автомата. Зачастую такой конечный автомат приходится описывать на нескольких диаграммах, что нарушает целостность картины. Однако все состояния, входящие в возвратную часть конечного автомата, можно перенести в отдельный метод, что сократит общее количество состояний автомата. Назовём такую трансформацию «выделением в метод возвратной части конечного автомата». 
Рассмотрим определение части модельного конечного автомата, представленное на Рис. 1. Это автомат допускает выделение метода, так как для состояния X существует возвратная часть конечного автомата, состоящая из одного состояния Y. 
В результате применения трансформации «выделение метода», создаётся метод Proc () с реализацией в виде конечного автомата. Все состояния из возвратной части конечного автомата (в данном примере только Y ) переносятся в выделенный метод. Действия, приписанные переходу в Y, становятся действиями, приписанными начальному переходу конечного автомата метода Proc (). Вместо них в исходный конечный автомат вставляются вызов метода Proc () и команда перехода в исходное состояние X (Рис. 2). 
Все команды перехода в состояние X в созданном конечном автомате заменяются командами возврата из метода (return) (Рис. 3). 
Часть автомата, выделенная в метод, обладает следующей семантикой: получив сигнал sig3 (), автомат выполняет некоторые действия, начиная с состояния Y, по завершении которых возвращается в состояние X. Подобная логика близка по смыслу к вызову метода - выполнение задачи с последующим возвратом в исходное состояние. Именно это и служит основанием для выделения метода. 
В результате преобразования выделяется структурная единица автомата - метод, а диаграмма, описывающая конечный автомат, уменьшается, что упрощает его понимание. Выделенный метод можно использовать повторно для уменьшения дублирования кода. 
Существует частный случай трансформации - выделение в метод группы состояний автомата, все переходы из которых завершают работу автомата, то есть ведут в символ stop. В этом случае выделение метода корректно, если все команды завершения работы автомата в выделенном методе (stop) заменяются командами возврата из метода (return), а вместо действий, приписанных исходному переходу, добавляются вызов метода Proc () и команда завершения работы автомата (stop). 
В таком случае преобразованный автомат будет выглядеть так, как показано на Рис. 4: 

3.3. Выделение в метод последовательной части конечного автомата
Во многих конечных автоматах встречаются последовательные части - несколько состояний, вытянутых в цепочку, с одним входом и одним выходом для каждого состояния (Рис. 5). Согласно исследованию, проведённому в [19], 25 % рассмотренных крупных автоматов содержат последовательные цепочки длинной 3 и более состояний. 
 В таких ситуациях все состояния, входящие в цепочку, можно перенести в метод. Это позволит упростить общий вид конечного автомата, уменьшить количество состояний и переходов и скрыть детали поведения автомата при последовательном прохождении нескольких состояний. Назовём такую трансформацию «выделением в метод последовательной части конечного автомата». 
В результате применения трансформации «Выделение метода», создаётся метод Proc () с реализацией в виде конечного автомата (Рис. 6). 
Все состояния из последовательной цепочки состояний (в данном примере X, Y и Z) переносятся в выделенный метод. Последний переход цепочки состояний, перенесённый в метод, завершается возвратом из метода (return). Действия, приписанные началу цепочки переходов, становятся действиями, приписанными начальному переходу конечного автомата метода Proc (). Вместо них в исходный конечный автомат вставляются вызов метода Proc () и команда перехода в состояние, следующее за цепочкой (Q) (Рис. 7) 
Последовательные цепочки состояний, используемые в конечных автоматах, являются неким многошаговым переходом, определяющим последовательность действий и состояний, которые необходимо пройти, чтобы попасть в очередную часть автомата. Таким образом, все состояния и переходы, формирующие цепочку, являются логически связанными и допускают группировку в отдельную структурную единицу автомата - метод. 

3.4. Необходимые условия для выделения части конечного автомата в метод
Автоматизация проведения преобразований для крупных конечных автоматов является исключительно важной задачей, ибо сложность проводимого анализа способствует возникновению ошибок. Одним из этапов процесса автоматизации является возможность автоматического поиска частей конечного автомата, которые можно поместить в отдельный метод согласно описанным выше подходам. После выделения одного метода могут появляться новые группы состояний, удовлетворяющие условиям выделения метода; поэтому необходимо иметь возможность автоматически выполнять итеративный поиск с возвращением для выявления наиболее оптимальной последовательности трансформаций. 
Всё сказанное выше подтверждает актуальность и востребованность следующей задачи: сформулировать достаточно формальные необходимые условия для выделения части конечного автомата в метод, общие для всех предложенных трансформаций. Ниже приводятся такие условия. 
Обозначим переход из состояния а в состояние b по событию sig, выполняющий действия act, через t (a?>b; sig; act). Обозначим конечное состояние автомата через stop, ветвление по условию cond через decision (cond), а конечное состояние процедуры (возврат из процедуры) через return. Тогда, например, переход из ветвления по условию cond в конечное состояние автомата будет обозначаться как t ( decision (cond)?> stop; sig; act). 
На диаграмме конечного автомата, записанной в нотации UML, кроме стрелок, обозначающих переходы, могут присутствовать следующие элементы: состояния автомата, символы ветвления по условию (decision), начальное состояние, конечное состояние (stop) и символы возврата из процедуры (return). Назовём все эти элементы узлами конечного автомата. 
Рассмотрим множество узлов N конечного автомата. Назовём узел s  N входным для множества узлов N, если существует переход t (a->s; sig; act) и a  N. Назовём узел b  N выходным для множества узлов N, если существует переход t (s->b; sig; act) и s  N. 
Сформулируем необходимые условия для выделения части конечного автомата в метод: 
Множество узлов N, не содержащее stop, и все переходы между ними можно перенести в отдельный метод, если для множества узлов N существует ровно один входной узел и не более одного выходного узла. 
Для поиска частей автомата, которые можно перенести в отдельный метод, должно использоваться то же самое условие. Необходимо искать множества узлов с одним входным и одним выходным узлом. На Рис. 8.  приведён пример автомата, удовлетворяющего заданному условию. Данное условие не ограничивает количество переходов, по которым можно попасть во входной или выходной узел, и, как видно на рисунке, для входного узла decision (x) и для выходного узла Q существует по два перехода, ведущие в них. 
Все узлы из выделенного множества, decision (x), s1, s2, s3 перемещаются в новый метод Proc (). Переходы, ведущие во входное состояние, после трансформации напрямую направляются в выходное состояние Q. К действиям, выполняемым в этих переходах, добавляется вызов метода Proc () (Рис. 9). 
Переходы, ведущие в выходное состояние, переносятся в метод и направляются в символ возврата из процедуры (Рис. 10). 
В основе необходимого свойства для выделения части конечного автомата в метод лежит следующая идея. Состояния, переносимые в выделяемый метод, перестают принадлежать исходному автомату, и, следовательно, некорректны команды перехода, которые приводят из состояний исходного автомата в состояния, перенесенные в выделенный автомат. Такие команды перехода (смены состояния) должны быть заменены командами вызова выделяемого метода. Однако у автомата, реализующего метод, может быть только одна входная точка, поэтому все такие команды должны осуществлять переход в одно и то же состояние. Аналогичные рассуждения касаются и обратных переходов из состояний выделенного метода в состояния исходного автомата. 
Трансформации «выделение метода для конечного автомата», описанные в предыдущих двух параграфах, являются частными случаями трансформации общего вида, базирующейся на необходимом условии. В случае, когда входной узел совпадает с выходным, получаем возвратную часть конечного автомата, которую можно выделить в метод. Последовательные части конечного автомата, очевидно, также удовлетворяют необходимому условию для выделения части конечного автомата в метод. 
Существуют и другие частные случаи приведённого необходимого условия: 
Множество узлов не имеет ни одного выходного узла (и по необходимому условию не содержит stop), то есть возврат из созданного метода невозможен. Это значит, что в конечном автомате найден бесконечный цикл, который, возможно, представляет собой «серверную составляющую» исходного автомата. 
В случае, когда выходной узел - это stop, выделенный метод выполняет действия, после которых автомат завершает свою работу, так что, возможно, новый метод является неким аналогом деструктора в объектно-ориентированном программировании. 

3.5. Трансформация «выделение составного состояния» для конечных автоматов UML
Автоматы, содержащие составные состояния, составляют менее 2 % от всех исследованных в [19] автоматов, что позволяет сделать вывод об их достаточно редком использовании, несмотря на их выразительную мощность. Причиной тому может служить тот факт, что составные состояния не являлись частью языка SDL до его версии SDL-2000. Таким образом, можно предположить, что многим разработчикам моделей, работавшим ранее на языке SDL, недостаточно известна эта конструкция. 
Тем не менее, введение «составных» или «иерархических» состояний является достаточно важным методом композиции, используемым для создания легко воспринимаемого описания автомата. 
В следующих параграфах описываются способы выделения составных состояний в конечных автоматах UML. 

3.6. Выделение составного состояния для скрытия деталей реализации
В промышленных моделях для спецификации поведения объектов достаточно часто используются автоматы, имеющие одно состояние. Такая структура характерна для классов, не обладающих сложной внутренней логикой, а реализующих некоторый сервис для других компонентов системы. В единственном имеющемся состоянии, которое очень часто носит имя ""Idle"" или ""Wait"", объект ожидает запрос на выполнение какой-либо операции. Получение запроса инициирует срабатывание перехода, в процессе которого выполняются необходимые действия. По завершении обработки объект вновь возвращается в исходное состояние. Частота использования подобного приема позволила даже выделить на его основе типичный образец проектирования, получивший название «Ромашка», за счет визуальной схожести описания автомата с цветком. Однако даже в тех случаях, когда автомат, описывающий сложный компонент системы, не удовлетворяет целиком описанному образцу, зачастую удается выделить некоторые элементы, описание которых ему соответствует. Обособить такие части можно за счет использования описанной в этом параграфе трансформации. 
При наличии нескольких «основных» состояний детали, описания каждого из них могут значительно усложнять диаграмму, как это показано на Рис. 11. Перегруженные символами диаграммы затрудняют понимание и должны быть преобразованы к более простому виду. 
Для выполнения трансформации выбирается состояние, имеющее возвратные переходы, например Z. Далее это состояние заменяется составным состоянием Z, содержащим одно состояние Z_internals. Для спецификации внутренностей составного состояния Z создается новая диаграмма, на которой определяется начальный переход, ведущий в Z_internals. Все возвратные переходы состояния Z переносятся внутрь этого составного состояния и приписываются состоянию Z_internals. Результаты применения трансформации представлены на Рис. 12 и Рис. 13. 
 
Рис. 13. Результат трансформации 
В результате применения данного преобразования описание автомата становится более иерархичным и поэтому более удобным для восприятия; структурируются и упрощаются диаграммы, специфицирующие автомат. Выполнение трансформации оправдывается в том случае, когда имеется состояние с большим количеством переходов в само себя. Как правило, наличие многих переходов из некоторого состояния в него же говорит о наличии особой семантической роли у функциональности, реализуемой автоматом только в этом состоянии. Выделение составного состояния позволит в данном случае подчеркнуть эту функциональность не только семантически, но и графически посредством переноса ее описания на новую диаграмму. 
Данное преобразование может быть применено к любому состоянию автомата, если это оправдывается с точки зрения семантики. 

3.7. Метод текстового сравнения переходов
Как и при написании программ на традиционных языках программирования, при создании UML-моделей крайне желательно избегать дублирования элементов модели, повторно используя вместо этого существующие элементы, так как наличие нескольких копий каких-либо элементов модели может осложнять понимание и модификацию. В контексте исполняемых моделей, специфицированных посредством конечных автоматов, на практике наиболее часто встречаются дублирование общей архитектуры автомата и дублирование переходов. В первом случае в модели будет встречаться несколько похожих на вид, но необязательно эквивалентных автоматов. Избежать дублирования в данной ситуации весьма затруднительно, можно лишь описать повторяющуюся часть автомата как типичный прием проектирования автоматов (pattern), сохранив информацию об использовании этого образца в комментарии к автомату. 
В случае наличия в автомате эквивалентных переходов дублирование можно устранить за счет применения трансформаций, описанных в следующих параграфах. Однако задача автоматического обнаружения эквивалентных переходов оказывается достаточно сложной и весьма актуальной для больших автоматных моделей. 
Эквивалентность переходов в автомате означает совпадение списка стимулов, инициирующих эти переходы, а также эквивалентность действий, выполняемых при срабатывании заданного перехода. Если автоматическая проверка эквивалентности списков сигналов, инициирующих сравниваемые переходы, не представляет никакой трудности, то проблема определения эквивалентности двух программ, к которой сводится проверка эквивалентности последовательности действий, выполняемых в переходах, алгоритмически неразрешима. Кроме того, сложно определить критерии эквивалентности двух автоматов. 
Несмотря на это, для конечных автоматов весьма хорошо зарекомендовал себя простой подход, суть которого состоит в сравнении текстовых строк, описывающих переход. При очевидной простоте реализации этот способ позволяет достаточно эффективно находить в автомате эквивалентные переходы. Эквивалентность текстуально совпадающих действий, приписанных переходам, практически очевидна. Достаточно учесть, что оба перехода описаны в контексте одного конечного автомата, и поэтому все использованные при их описании идентификаторы, например, имена функций и переменных, означают в обоих переходах одни и те же объекты. Действительно, каждое имя в переходе либо относится к объекту, объявленному локально, и тогда его определения текстуально совпадают в обоих переходах, и для них можно повторить это рассуждение; либо относится к объекту, определенному в контексте автомата и выше, но в этом случае правила, по которым идентификатору сопоставляется элемент модели, дадут одинаковый результат для обоих переходов, так как их применение в обоих случаях можно начинать с автомата, содержащего оба рассматриваемых перехода, поскольку сами переходы не содержат подходящего объекта. Отсюда следует, что текстуальное совпадение переходов гарантирует их эквивалентность. 
Тем не менее, отсутствие текстуального совпадения отнюдь не обязательно означает отсутствие эквивалентности: к примеру, если в одном из переходов выполняются действия {a++; b++}, а в другом - {b++; a++}, где и a и b являются атрибутами класса, содержащего автомат, то эти переходы можно считать эквивалентными, хотя текстуально они различны. Однако текстуальное сравнение может быть использовано и позволяет получать приемлемые результаты. 
Метод текстуального сравнения может быть усовершенствован следующим образом: перед сравнением из строк, описывающих переходы, удаляются фрагменты, не имеющие отношения к выполняемым действиям, например, комментарии. Кроме того, все локальные идентификаторы (в случае, если их количество в обоих переходах одинаково) следует переименовать так, чтобы они имели одни и те же имена в порядке их объявления. 
Автоматизация поиска эквивалентных переходов позволяет упростить процесс применения трансформаций, устраняющих дублирование переходов. 

3.8. Выделение составного состояния по общему переходу
Рассматриваемую здесь трансформацию следует применять, когда в исходном автомате достаточно много состояний, и при этом можно выделить группу семантически связанных состояний, для каждого из которых существует переход, эквивалентный некоторому заданному переходу. 
Достаточно часто при создании промышленных моделей возникают ситуации, когда невозможно знать заранее точные время и условия осуществления какого-либо события, например, прихода сигнала от окружения системы. Если событие достаточно важно и не допускает отложенной обработки, то разработчик конечного автомата будет вынужден описать реакцию на это событие сразу в нескольких возможных состояниях, поскольку он не может знать, в каком именно состоянии будет находиться автомат в момент осуществления события. 
Такие описания затрудняют понимание и приводят к ненужному дублированию кода, что повышает вероятность возникновения ошибок в случае изменения реакции на это событие или добавления в автомат новых состояний. 
Данная трансформация состоит из двух этапов, каждый из которых является композиционным преобразованием. Перед проведением преобразований должен быть выбран переход, копии которого определены сразу для нескольких состояний в исходном автомате. На первом этапе создается новое иерархическое состояние, в которое включаются все состояния, имеющие переход, эквивалентный выбранному. На втором этапе для всех состояний удаляются переходы, эквивалентные выбранному, а для вновь созданного иерархического состояния такой переход добавляется. 
Применение данной трансформации к автомату, изображенному на рис. 14, позволяет выделить составное состояние On, содержащее состояния X, Y, Q, Z, если в качестве выделенного перехода использовать переход по сигналу TurnOff (). Для спецификации внутренностей составного состояния создается диаграмма, приведенная на рис. 15, а модифицированный исходный автомат показан на рис. 16. Введение иерархического состояния позволило упростить исходную диаграмму за счет удаления дублировавшихся переходов и сделать ее более наглядной и понятной. Кроме того, замена множества одинаковых переходов одним помогает избежать ошибок при изменении спецификации действий, выполняемых при срабатывании перехода. 
 
Рис. 15. Результат трансформации: спецификация составного состояния On 
Создание в автомате S нового составного состояния B, явно содержащего состояния A1…An, корректно в том и только том случае, когда это добавление не нарушает строгую иерархию состояний по включению. Иными словами, новое состояние, будучи изображенным на любой диаграмме состояний, описывающей автомат, не должно пересекать границы уже существующих состояний. Перенос перехода T из состояний D1…Dn в состояние E корректен только в том случае, если E является составным состоянием и не содержит явно никаких состояний, кроме D1…Dn, а в каждом из состояний D1…Dn есть либо переход, эквивалентный T, либо переход, срабатывающий при тех же условиях, что и T. 

3.9. Выделение составного состояния по общему возвратному переходу
По причине описанного ранее негативного влияния дублирования переходов желательно устранять эквивалентные действия, даже если они находятся на неэквивалентных переходах. В этом параграфе будет описана трансформация, позволяющая устранить дублирование действий в переходах отличающихся лишь состоянием, в которое они переводят автомат. 
Для сложных автоматов достаточно типична ситуация, когда какое-либо событие должно быть одинаковым образом обработано в нескольких состояниях, при этом его обработка не должна прерывать основной ход событий, то есть по его окончании автомат должен возвратиться в исходное состояние. Примером таких событий может быть протоколирование какой-либо активности либо другие «фоновые» для автомата задачи. Моделирование такого поведения вынуждает разработчиков определять для каждого из состояний, в котором должна быть обработана «фоновая» активность, переход, содержащий эквивалентную последовательность действий и возвращающий автомат в исходное состояние. Такие переходы избыточны, загромождают описание автомата и мешают его восприятию, как, например, на Рис. 17. 
Предлагаемая трансформация выполняется во многом аналогично предыдущей. На первом шаге выделяется множество состояний A1…An автомата S, для каждого из которых существует переход Ti, обладающий следующими свойствами: он срабатывает при условии t, в нем выполняются действия act, и после его завершения автомат возвращается в исходное состояние Ai. К автомату S добавляется новое составное состояние B, содержащее состояния A1…An, а для спецификации состояния В создается отдельная диаграмма D. К автомату S добавляется переход T из состояния B по стимулу t, выполняющий действия act и завершающийся оператором перехода в состояние истории (deep history state). Если у множества состояний A1…An имеется только одна входная точка A1, то возможно дальнейшее преобразование автомата. Все операторы перехода в состояние A1 заменяются операторами перехода в состояние В, а к состоянию В добавляется стартовый переход, ведущий в состояние A1. После этого становится возможным переместить состояния A1…An с исходной диаграммы на диаграмму D (Рис. 19), добавив вместо них состояние В и переход Т к исходной диаграмме (Рис. 18). 
Данная декомпозиция позволяет упростить описание исходного автомата, сделав его более удобным, а также улучшает структуру автомата, устраняя дублирование действий, выполняемых при срабатывании переходов. «Выделение составного состояния по общему возвратному переходу» может быть применено, если в автомате можно выделить такую группу состояний с единственной входной точкой, что для каждого состояния группы определен возвратный переход по одинаковому для всех состояний стимулу и с эквивалентными для всех состояний действиями. 

3.10. Выделение составного состояния для моделей, импортированных из SDL
Несмотря на то, что сейчас язык UML де-факто является стандартным языком моделирования, среди используемых сегодня в реальных промышленных проектах моделей можно выделить класс систем, которые изначально были описаны на других языках моделирования - преимущественно SDL. В основном, язык SDL использовался для спецификации телекоммуникационных систем. Однако преимущества UML подтолкнули многих разработчиков к преобразованию их моделей в UML. При этом, если описание статической структуры системы на SDL достаточно легко моделируется в UML, то для некоторых элементы SDL, используемые для спецификации конечных автоматов, отсутствуют UML-аналоги, например, понятие «мультисостояния» (multistate). 
В SDL в символе состояния можно перечислить несколько имен состояний, и тогда все переходы, изображенные выходящими из этого символа, будут относиться ко всем перечисленным состояниям. Кроме того, если в качестве имени состояния указать символ «*», то переходы, выходящие из этого символа, будут относиться ко всем состояниям автомата. Также имеется возможность исключить определенные состояния из множества состояний, описываемого символом «*». Умелое использование этих возможностей позволяет значительно упростить описание переходов, применимых более чем к одному состоянию. Результаты статистического исследования показывают, что символ «*» присутствует в 12 % символов состояния, что свидетельствует о достаточно активном использовании этой подстановки и необходимости ее более детального изучения [19]. 
Отсутствие методов трансформации таких конструкций заставило разработчиков инструментальных средств моделирования пойти по пути внедрения в свои продукты для работы с UML недостающих элементов языка SDL. Так, например, в среде моделирования Telelogic Tau 3.0 поддерживаются «мультисостояния», в том числе, и «*-состояния». Однако для создания моделей, соответствующих стандартному языку UML, необходимо преобразовать подобные состояния в другие элементы, сохранив при этом функциональность автомата. 
Предлагаемая трансформация упрощает мультисостояния следующим образом. Для каждого символа мультисостояния к исходному автомату добавляется новое составное состояние B, которое содержит в точности все состояния A1…An, перечисленные в символе мультисостояния. Все переходы, приписанные мультисостоянию, переносятся в созданное составное состояние. После этого мультисостояние может быть безболезненно удалено из автомата. Кроме того, если у множества состояний A1…An имеется всего одна входная точка A1, то можно определить отдельную диаграмму для спецификации внутренностей созданного составного состояния B, переместив на нее все описания, касающиеся множества состояний A1…An, заменив при этом в исходной диаграмме все операторы перехода в A1 операторами перехода в состояния В. 
Пример исходной диаграммы приведен на Рис. 20, а результат преобразования - на Рис. 21. Выделение иерархического состояния также возможно, когда в качестве символа мультисостояния указан «*», то есть определяется переход для всех состояний автомата. 

3.11. Пример «Мобильный телефон»
Продемонстрируем применение предложенных трансформаций на одном из конечных автоматов системы Mobile, моделирующей работу мобильного телефона. 
В исходной системе конечный автомат представлен на 28 диаграммах, каждая из которых описывает ровно один переход (Рис. 22). 
Такое представление, в котором используется нотация SDL для описания переходов, не позволяет понять цельную структуру конечного автомата. Для упрощения понимания была сгенерирована дополнительная OVERVIEW-диаграмма, описывающая весь конечный автомат в нотации UML (Рис. 23). 
Приведённый алгоритм позволяет найти и выделить из данного конечного автомата три метода. На первом шаге в метод Initialize () выделяются четыре последовательных состояния. На втором шаге выделяется метод Talking (), после чего становится возможным выделить ещё один метод, который назовём Working (). 
Обратим внимание на то, что выделение метода Working () возможно только после выделения метода Talking (). Процесс применения трансформации итеративный. Поиск частей конечного автомата, которые можно вынести в отдельный метод, можно автоматизировать. 
В результате применения трансформаций исходный конечный автомат сильно упростился и свободно помещается на одной диаграмме (Рис. 24). Теперь он содержит только одно состояние (вместо четырнадцати состояний в исходном автомате) и вызов двух методов. 
Выделены три метода Initialize (), Talking () (Рис. 25) и Working () (Рис. 28), содержащие 4, 5 и 4 состояния соответственно. 
В методе Talking () три состояния из пяти содержат пары одинаковых возвратных переходов, а остальные два состояния определяют реакцию (defer) на те сигналы, которые инициируют возвратные переходы. Таким образом, к данному методу можно применить трансформацию «выделение составного состояния по общему возвратному переходу». В результате пара общих переходов будет вынесена с основной диаграммы и применена к внешнему составному состоянию (Рис. 26). 
После данной трансформации конечный автомат, описывающий поведение метода Talking (), будет перенесён в составное состояние Talking, и из него будут удалены три пары возвратных переходов, что повысит наглядность (Рис. 27). 
Применив трансформацию «выделение составного состояния для скрытия деталей реализации» для метода Working () и выделив три составных состояния, получим более компактную диаграмму с меньшим количеством переходов (Рис. 29). 

4. Заключение
В статье были предложены 6 новых методов трансформации исполняемых моделей на языке UML, основанных на композиции и декомпозиции. Была продемонстрирована практическая применимость предлагаемых методов как средства упрощения восприятия и улучшения структуры сложных автоматов. 
Каждый из предложенных методов допускает как автоматизацию выполнения преобразования, так и автоматический поиск частей модели, к которым это преобразование применимо и, вероятно, его применение целесообразно. Приоритетными направлениями дальнейшей работы являются реализация модуля автоматического поиска и применения трансформаций в среде моделирования, наряду с продолжением работ по разработке и исследованию новых методов трансформации. ",1
29,Модели представления данных в СУБД.docx,"2.3.1. Исследование моделей информационного представления данных в современных СУБД.
Исследование различным методов ис средств представления и управления данными в информационных системах проведем на примере интерактивной базы данных патентного обеспечения (ПО) конструкторско-технологического проектирования (КТП). Патент - это документ, свидетельствующий о праве изобретателя на его изобретение. Для стандартизации и облегчения поиска информации были введены различные классификации патентов: (Национальная Классификация Патентов (НКИ), Универсальная Десятичная Классификация (УДК), Международная Классификация Изобретений (МКИ)). Все эти классификации призваны служить инструментом для упорядоченного хранения патентных документов, что облегчает доступ к содержащейся в них информации, быть основой для избирательного распределения информации среди потребителей патентной информации и для получения систематических данных в области промышленного соответствия, что в свою очередь, определяет уровень развития различных областей техники. 
Классификации патентов имеют сложную структуру, и для поиска необходимой информации может потребоваться много времени. Возможна организация поиска по всем имеющимся классификациям изобретений, но пока, в качестве примера, мы рассмотрим только Международную Классификацию Изобретений, которая являясь средством для единообразного в международном масштабе классифицирования патентных документов, представляет собой эффективный инструмент для патентных ведомств и других потребителей, осуществляющих поиск патентных документов с целью установления новизны и оценки вклада изобретения в заявленное техническое решение (включая оценку технической прогрессивности и полезности или результата). 
Международная Классификация Изобретений (МКИ) имеет иерархическую структуру (представленную на рис.1) и состоит из следующих отделов: 1 - Раздел, 2 - Класс, 3 - Подкласс, 4 - Группа, 5 - Подгруппа. Иерархическая структура классификации МКИ представлена на рис.31. 

Логическая модель 
Переход от функциональной модели к логической осуществляется с помощью реляционных методов, при этом иерархическая структура функциональной модели реализуется с использованием отношений один - ко -многим и рекурсивных рис. 27. Реализацией данной логической модели является совокупностью таблиц, объединенных в единый модуль - патентную информационную базу данных ( PIB - Patent Information dateBase). 
Ядром логической модели является таблица PIB_MKI (МКИ), связывающая таблицы PIB_PART (Раздел), PIB_CLASS (Класс), PIB_SUBCLASS (Подкласс), PIB_GROUP (Группа), PIB_SUB-GROUP (Подгруппа) в единую структуру, определяющую реализацию Международной Классификации Изобретений (МКИ) винформационной системе патентного обеспечения технологического проектирования. Таблица PIB_MKI (МКИ) в свою очередь связана с таблицей PIB_PATENT (Патент), отвечающей за связь с таблицами PIB_GRATHDOC (Графические документы) и PIB_UDK (УДК).Таблица PIB_UDK (УДК) реализует Универсальную Десятичную Классификацию (УДК). Структура таблиц модуля PIB представлена в таблице1. 
Таблица 1. Информационно-логическая Структура модуля Международной Классификации Изобретений. 

Исследование архитектур программно-технологической реализации АИС 
В настоящее время существует множество архитектур, служащих для разработки информационных систем, ядром которых является СУБД. Клиент в типичной конфигурации клиент/сервер - это автоматизированное рабочее место, использующее графический интерфейс (Graphical User Interface - GUI), обычно Microsoft Windows, Macintosh. 
Сервер же, в основном, предназначен для хранения, передачи и распределения информации между клиентами. В клиент/серверной конфигурации программные средства имеют разделение на клиентскую и серверную часть, однако, частые обращения клиента к серверу снижают производительность работы сети и обуславливают сложность настройки системы. 
Рассмотрим варианты распределения функций СУБД в клиент/серверной системы. СУБД выполняет три основные функции: 
доступ к данным; 
предоставление данных; 
бизнес - функции. 
Сервер СУБД может быть реализован на различных платформах, под управлением операционных систем UNIX, NetWare, Windows NT, OS/2 и др. 
До появления технологии клиент/сервер большинство приложений функционировало на одной ЭВМ. Одна система отвечала не только за всю обработку данных, но также и за выполнение логики приложения. Кроме того, та же система обрабатывала весь обмен с каждым терминалом; все нажатия клавиш и элементы отображения обслуживались тем же процессором, который обрабатывал запросы к базе данных и логику приложения. 
Oracle предоставляет такие возможности, как хранимые процедуры, поддержка ограничений целостности, функции, определяемые пользователем, триггеры базы данных и ряд других. Все это позволяет приложению хранить большое количество бизнес-правил (или семантику модели данных) на уровне базы данных. В результате приложение освобождается для выполнения более тонких задач обработки. Как показано на рис.28, такая СУБД намного более устойчива. 
Программные продукты Oracle охватывают все основные компоненты архитектуры клиент/сервер, показанной на рис. 29: 
1)полнофункциональный высокопроизводительный сервер RDBMS (система управления реляционной базой данных), масштабируемый от портативных ЭВМ до мэйнфреймов; 
средства для разработки и запуска клиентских приложений, поддерживающие несколько сред GUI; 
программный компонент для организации связи между БД на различных ЭВМ, который обеспечивает эффективную и безопасную связь с помощью широкого набора сетевых протоколов.
Oracle использует память системы (как реальную, так и виртуальную) для выполнения пользовательских процессов и самого программного обеспечения СУБД, и для кэширования объектов данных. В простой конфигурации Oracle файлы базы данных, структуры памяти, фоновые и пользовательские процессы располагаются на одной машине без использования сети. Однако, намного чаще встречается конфигурация, когда БД расположена на машине-сервере, а инструментальные средства Oracle - на другой машине (например, РС с Microsoft Windows). При такой клиент/серверной конфигурации машины связываются посредством некоторого сетевого программного обеспечения, которое позволяет двум машинам поддерживать связь. Для организации взаимодействия клиент/сервер или сервер-сервер необходимо использовать программный продукт Oracle SQL*Net, который позволяет СУБД Oracle взаимодействовать с сетевым протоколом. SQL*Net и поддерживает большинство сетевых протоколов для локальных вычислительных сетей (таких как TCP/IP, IPX/SPX) и для мэйнфреймов (например, SNA). По существу, SQL*Net является промежуточной программной прослойкой между Oracle и сетевым ПО, обеспечивающей связь между клиентской машиной Oracle (на которой работает, например, SQL*Plus) и сервером базы данных или между серверами баз данных. Опции SQL*Net позволяют одной машине работать с одним сетевым протоколом, сообщаясь с другой машиной, работающей с другим протоколом. 
В зависимости от размеров, таблицы (и других объектов) всех учетных разделов пользователей могут, очевидно, размещаться в одном файле базы данных, но это - не лучшее решение, так как оно не способствует гибкости структуры базы данных для управления доступом к различным пользовательским разделам, размещения базы данных на различных дисководах или резервного копирования и восстановления части базы данных. В СУБД Oracle предусмотрены привилегии системного уровня, резервное копирование и поддержка национальных языков. Все это позволяет сделать вывод о целесообразности разработки интерактивной информационной системы патентного обеспечения технологического проектирования на основе СУБД Oracle. 

2.3.2 Компоненты системы управления реляционной базой данных (RDBMS).
2.3.2.1 Ядро системы управления реляционной базой данных (RDBMS).
Две важные части архитектуры RDBMS - ядро, которое является программным обеспечением, и словарь данных, который состоит из структур данных системного уровня, используемых ядром, управляющим базой данных. 
RDBMS можно рассматривать как операционную систему (или подсистему), разработанную специально для управления доступом к данным; ее основные функции - хранение, выборка и обеспечение безопасности данных. Подобно операционной системе, СУБД Oracle управляет доступом одновременно работающих пользователей базы данных к некоторому набору ресурсов. Подсистемы RDBMS очень схожи с соответствующими подсистемами ОС и сильно интегрированы с предоставляемыми базовой ОС сервисными функциями доступа на машинном уровне к таким ресурсам, как память, центральный процессор, устройства и файловые структуры. 
RDBMS поддерживают собственный список авторизованных пользователей и их привилегий; управляют кэшем памяти и страничным обменом; управляют блокировкой разделяемых ресурсов; принимают и планируют выполнение запросов пользователя; управляют использованием табличного пространства. 
На рис.31. показаны основные подсистемы ядра Oracle, управляющего базой данных. 
Итак, база данных - собрание данных, между которыми существуют (смысловые) связи. Физическое расположение и реализация базы данных прозрачны для прикладных программ; физическую базу данных можно перемещать и реорганизовывать и это не окажет влияния на работоспособность программ. 
Физически база данных Oracle - не более чем набор файлов где-то на диске. Расположение этих файлов несущественно для функционирования (хотя важно для производительности) базы данных. 
Логически база данных - это множество пользовательских разделов Oracle, каждый из которых идентифицируется именем пользователя (с паролем), уникальным в данной БД. На рис.29. показана архитектура Oracle. 
Существуют три основные группы файлов на диске, составляющие базу данных. 
Файлы базы данных 
Управляющие файлы 
Журнальные файлы 
Наиболее важные из них - файлы базы данных, где располагаются собственно данные. Управляющие и журнальные файлы поддерживают функционирование архитектуры. Для доступа к данным БД все три набора файлов должны присутствовать, быть открытыми и доступными Oracle. Если эти файлы отсутствуют, обратиться к базе данных нельзя, и администратор базы данных должен будет восстанавливать часть или всю БД, используя файлы резервных копий (если их сделали!). Все эти файлы двоичные. 
После инсталляции СУБД (об этапах установки подробно написано в [ ]) администратор имеет возможность войти в СУБД используя учетные записи SYS или SYSTEM, с парролем: master или manager, для создание учетных записей других пользовтаелей, при этом пароли учетных записей SYS и SYSTEM необходимо сразу же изменить. 
Для работы с файлами базы данных на машине должны существовать системные процессы Oracle и один (или больше) пользовательский процесс. 
Системные процессы Oracle (их называют фоновыми) обеспечивают функционирование пользовательских процессов - выполняют функции, которые иначе пришлось бы выполнять пользовательским процессам непосредственно. 
Дополнительно к фоновым процессам Oracle в простейшем случае на одно подключение к базе данных должен существовать один пользовательский процесс. Пользователь должен подключиться к базе данных прежде чем он сможет обратиться к какому-либо объекту. Если один пользователь регистрируется в Oracle, используя SQL*Plus, другой пользователь выбирает Oracle Forms, а еще один пользователь открывает электронную таблицу Excel, значит имеется три пользовательских процесса для работы с этой базой данных - по одному для каждого подключения. 
Oracle использует память системы (как реальную, так и виртуальную) для выполнения пользовательских процессов и самого программного обеспечения СУБД, и для кэширования объектов данных. Существуют две главные области памяти Oracle: 
разделяемая память, которая используется всеми процессами, работающими с базой данных, 
локальная память для каждого пользовательского процесса.
Системная память. 
Системная память. Oracle для всей базы данных называется SGA (system global агеа - системная глобальная область или shared global агеа - разделяемая глобальная область). Данные и управляющие структуры в SGA являются разделяемыми, и все фоновые процессы Oracle и пользовательские процессы могут к ним обращаться. 
Память пользовательского процесса. Для каждого подключения к базе данных Oracle выделяет PGA (process global агеа - глобальную область процесса или program global агеа - глобальную область программы) в памяти машины и, кроме того, - PGA для фоновых процессов. Эта область памяти содержит данные и управляющую информацию одного процесса и между процессами не разделяется. 

2.3.2.2 Типы обрабатываемых данных
Типы данных обрабатываемых СУБД Oracle представлены в таблице. 
Таблица 2. Типы обрабатываемых данных. 
Извлекать данные можно также и из псевдостолбцов (табл.3), которые похожи на столбцы таблиц, но их значения нельзя изменять при помощи операторов DML. 
Таблица 3. Псевдостолбцы. 
Требования к именам объектов базы данных 
должны иметь длину от 1 до 30 бант, за исключением имен баз данных, длина которых ограничена 8 байтами; 
не могут содержать кавычек; 
не могут совпадать с именами других объектов. 
Имена, которые всегда заключены в двойные кавычки, могут нарушать, приведенные ниже правила. В противном случае, имена 
должны начинаться с букв A-Z; 
могут содержать только символы A-Z, 0-9, _, $ и #; 
не могут дублировать зарезервированные слова SQL. 
Различие между прописными и строчными буквами учитывается только в именах, заключенных о двойные кавычки. 
Операции и их приоритеты 
",1
3,Некоторые особенности проектирования.docx,"Некоторые особенности проектирования под конкретные архитектуры
Архитектура «клиент-сервер» 
Архитектура «клиент-сервер» предоставляет пользователю одно основное преимущество - возможность получить графический пользовательский интерфейс, не модернизируя сервер. По сравнению с файл-серверными архитектурами в данном случае резко снижается трафик (правда, только при правильном проектировании).
Существует два ключевых момента любой архитектуры:
Число пар операций обмена (запрос, ответ), прежде всего там, где используются медленные и неустойчивые каналы связи. 
Строгое разделение задачи управления пользовательским интерфейсом и задачи управления данными. Нарушение этого принципа - одна из главных причин высокого сетевого трафика. 
В случае архитектуры «клиент-сервер» обработка данных производится централизованно на сервере. Клиент посылает запрос к данным, сервер обрабатывает этот запрос и передает клиенту ответ. Казалось бы, все очень просто: ПО на сервере одно и то же, равно как и набор клиентских приложений один и тот же, так что все должно замечательно работать в любом случае.
Клиентское приложение должно идентифицировать по имени целевой сервер, к которому оно посылает запрос, а поиск физического сервера осуществляется на основании правил разрешения имен. Эти функции берут на себя серверный и клиентский компоненты СУБД, которые обеспечивают сетевой сервис. Все вопросы разрешения имен находятся в компетенции настроек этого ПО, а не собственно приложения-клиента. По сути, приложение-клиент общается непосредственно с клиентским ПО сетевого драйвера СУБД, а не с ядром СУБД. При этом:
Клиентский и серверный процессы могут находиться как на одной, так и на разных машинах. 
Клиентский и серверный процессы могут работать в разном окружении (аппаратное обеспечение, операционная система). Архитектура обеспечивает независимость клиентского ПО от серверного ПО СУБД. Независимость достигается за счет строго определенного интерфейса обмена, который, в свою очередь, осуществляется посредством посылки сообщений строго определенного формата. 
Клиентский процесс не знает, какой сервер в итоге будет обрабатывать его запрос. Средства передачи запросов от сервиса к сервису контролируются как СУБД, так и другими серверными процессами (например, запрос был обработан Web-сервером, преобразовавшим его в запрос для монитора транзакций, который обратился непосредственно к СУБД, а передача ответа идет в обратном порядке - в результате клиентский запрос последовательно обработан тремя серверами). 
Все эти положения, по сути, описывают инкапсуляцию, которая является необходимым условием успешного проектирования в этой архитектуре.
Проектируя любое приложение в архитектуре «клиент-сервер», следует обратить внимание на минимизацию операций обмена между клиентом и сервером. Вынесение части бизнес-логики на сервер в виде хранимых процедур позволяет снизить количество операций обмена.
Еще одним фактором является количество соединений одного приложения с сервером баз данных. СУБД на каждое соединение выделяет определенный ресурс. Если приложение открыло 10 соединений, а работает только одно из них, то СУБД реально резервирует все 10 ресурсов. Большинство интерактивных приложений характеризуются тем, что более 90% времени по открытым этими приложениями соединениям не ведется никакой работы. Для некоторых СУБД большое количество неактивных соединений серьезно снижает эффективность работы сервера, например для Oracle (поскольку при открытии соединения системные ресурсы под него выделяются сразу). Лучше пусть соединений будет меньше, но они будут работать.
Важным фактором является пропускная способность сети, а также пропускная способность выбранного протокола обмена данными. Большинство СУБД поддерживают протоколы Named Pipes, TCP/IP, NetBIOS, IPX/SPX. Все эти протоколы изначально не предназначались для обмена с базами данных. Некоторые производители реализуют собственные протоколы обмена - например, APPC, предоставляемый IBM DB2, специально оптимизирован для операций обмена, характерных для баз данных. Полоса пропускания протокола становится критичной только в том случае, когда передаваемые пакеты являются большими, например при передаче изображений и звука. Полоса пропускания протокола - один из возможных параметров, которые следует оптимизировать для повышения скорости передачи информации.
Основная задача проектирования в архитектуре «клиент-сервер» - реализовать на клиенте качественный прикладной интерфейс (экранные формы и, может быть, небольшое число проверок корректности ввода данных) и осуществить на сервере обработку разделяемых данных.
Модель, представленная на рис. 1, показывает типы распределения нагрузки между клиентом и сервером. Эту же модель можно распространить и на трехуровневые архитектуры, где уровнями являются клиент, ПО промежуточного слоя, сервер. Чем более жестко вы примените инкапсуляцию при проектировании, тем меньше будет вероятность того, что маленькие фрагменты управления логикой представления данных окажутся спрятанными в коде управления данными. Если этого не сделать, вы получите очень чувствительный к изменениям прикладной код, а значит, создадите трудности как при разработке кода, так и при поддержке приложения.
Наличие тонкого клиента также важно в современных информационных системах. Большинство серверов баз данных оптимизировано для селективной выборки данных, серверное ПО рассчитано на прием и передачу данных за минимальное время. Не следует злоупотреблять на разделяемых ресурсах сервера прикладными программами, используемыми клиентами. Это, конечно, гарантирует факт запуска одного и того же ПО с любой из клиентских машин, но нужно правильно оценивать стоимость этих операций с точки зрения сетевого трафика.
Если одни и те же данные часто запрашиваются с сервера, то их можно кэшировать на клиенте. Это, как правило, небольшие, редко обновляемые справочники. Такой подход снижает количество запросов к данным с сервера, а следовательно, понижает нагрузку не только на сеть, но и на сам сервер. Приложение-клиент должно уметь работать с таким кэшем данных. Организация его - скорее компетенция разработчиков, чем проектировщиков. Более серьезная задача - это обеспечение непротиворечивости и актуальности данных в кэше. Если в СУБД реализован механизм событий (event), который позволяет по факту модификации данных в справочнике послать клиенту уведомление об этом событии, последнее обрабатывается приложением-клиентом и вызывается функция, которая инициирует новое считывание справочника и обновление данных в кэше. Такие вызовы могут быть асинхронными.
Если же справочники велики, упорядочены всегда одинаково и изменяются мало, можно хранить их на клиенте не в кэше, а в обычных файлах. Это может расцениваться как некий упрощенный вариант распределенной базы данных, когда часть считанных данных хранится на клиенте в течение всего времени его работы. Таким образом можно хранить изображение и звук, а также другую информацию большого объема. Актуализация указанных данных также может быть реализована посредством механизма событий.

Трехуровневая архитектура
Сейчас часто употребляют термин «ПО промежуточного слоя». Некоторые авторы определяют этим понятием даже драйверы ODBC, иными словами, считают, что все, что работает между интерфейсом native-вызовов сервера и интерфейсом вызовов клиента, является ПО промежуточного слоя. Если допустить, что такое ПО обеспечивает только независимость клиента и сервера, то подобный термин имеет право на существование.
К ПО промежуточного слоя относят мониторы транзакций. В этом случае правила обработки данных, правила процессов определяются на языке монитора транзакций. Клиентское ПО обращается только к монитору транзакций. Вся обработка данных находится в компетенции монитора транзакций.
ПО промежуточного слоя обладает всеми системными функциями, например функциями сервера печати. Большинство проектировщиков мотивируют использование трехуровневой архитектуры необходимостью сконцентрировать логику обработки данных, системные функции в одном месте и убрать эти функции из состава ПО клиента.
ПО промежуточного слоя актуально в тех случаях, когда требуется обеспечить прозрачность доступа к данным, управляемым разными СУБД; здесь проблемы общения с СУБД берет на себя сервер приложений.
Часто ПО промежуточного слоя обеспечивает дополнительную защиту данных от несанкционированного доступа, например когда требуется уровень защиты B2 и выше. Некоторые СУБД обеспечивают такой уровень защиты собственными средствами - речь идет о Trusted-версиях, например Oracle, Sybase, Informix. Функции защиты данных обеспечиваются не только СУБД, но и специальными версиями операционных систем. Функции Trusted-сервера выполняет также IBM DB2 на архитектурах S/390, AS/400 в соответствующем окружении. К Trusted-серверам также относится Linter SQL Server производства российской компании РЕЛЭКС - защита данных здесь полностью обеспечивается ядром СУБД. В России эта СУБД сертифицирована по 2-му классу защищенности и может быть использована для построения защищенных информационных систем (сертификат действителен для версий СУБД, функционирующих в Windows NT, UNIX, Novell NetWare).

Распределенная база данных, параллельный сервер баз данных 
Есть много причин, которые могут подтолкнуть проектировщика к принятию решения о построении распределенной базы данных. Приведем некоторые из них:
Размещение часто используемых данных ближе к клиенту, что позволяет минимизировать сетевой трафик. 
Расположение часто меняющихся данных в одном месте, обеспечивающее минимизацию затрат по синхронизации копий данных. 
Увеличение надежности комплекса к единичным отказам серверов (горячее резервирование). 
Понижение стоимости системы за счет использования группы небольших серверов вместо одного мощного центрального сервера. 
Если в информационной системе наличествуют все перечисленные факторы, то распределенная база данных может оказаться хорошим решением. Часто распределение базы данных изначально определяется требованиями бизнеса, например когда объединяется информация нескольких крупных подразделений одной компании и требуется постоянный обмен данными между филиалами.
Решение о распределенной базе данных оправданно и для систем, где есть четко выраженные группа меняющихся данных и группа устойчивых данных, по которым выполняются отчеты. Тогда в самом простом варианте работают два сервера: один обслуживает часто меняющиеся данные - это, как правило, OLTP (On-Line Transaction Processing. - Прим. ред.), второй - отчеты, то есть DSS (Decision Support System. - Прим. ред.). Ряд СУБД не очень хорошо совмещает обработку OLTP- и DSS-потоков запросов, поскольку для этих двух типов потоков запросов оптимальные параметры конфигурации серверов будут различаться. Решение такой базы данных как распределенной может оказаться более выгодным.
Преимущества распределенной базы данных имеют свою цену - должны быть обеспечены:
Непротиворечивость данных, независимо от того, какой клиент к какому серверу обратился. 
Производительность распределенной базы данных должна удовлетворять требованиям заказчика, а это может оказаться более сложной задачей, чем в случае централизованной базы данных. 
Надежность распределенной базы данных не должна уступать надежности централизованной базы данных. 
Современные СУБД позволяют осуществлять запрос данных, находящихся на разных узлах распределенной сети в одном SQL-запросе. Прозрачность доступа СУБД также обеспечивают - в каких-то реализациях хуже, в каких-то лучше. Одна из самых распространенных проблем - более сложная обработка транзакций. Практически все промышленные реализации поддерживают только двухфазную фиксацию транзакций, а в этом режиме не все типы отказов разрешимы. Распределенный deadlock (взаимоблокировка. - Прим. ред.) также может представлять значительную проблему, и большинство реализаций используют только таймауты для его детектирования.
Как бы то ни было, стратегия распределения данных должна определяться не политикой предприятия (что обычно пытается навязать руководство), а требованиями надежности и производительности системы. При построении распределенной базы данных следует уделить особое внимание проектированию топологии сети. Узлы распределенной базы данных должны быть соединены скоростными надежными линями связи. Это же касается линий соединения узлов базы данных и серверов приложений. Наличие низкоскоростного и ненадежного канала связи между узлами распределенной базы данных резко повышает количество детектируемых отказов сети.
В распределенной базе данных могут быть использованы следующие типы вызовов:
Удаленные DDL- и DML- операции, а также выборка данных. 
Синхронные удаленные вызовы процедур. 
Асинхронные удаленные вызовы процедур. 
Непротиворечивые снимки. 
Асинхронная симметричная репликация. 
Синхронная симметричная репликация. 
Вызов распределенного запроса (запрашивает данные на чтение и модификацию с нескольких узлов). 
Распределенная база данных может обеспечить горизонтальную фрагментацию; например, в филиале чаще всего используют данные о клиентах, находящихся в городе N (CLIENT_PLACE = ‘N’). В этом случае на узле распределенной базы данных этого филиала может быть расположен фрагмент таблицы данных, выделенный согласно условию CLIENT_PLACE = ‘N’.
Стратегия распределения данных для каждой СУБД определяется по-своему и достойна отдельной книги. Определение стратегии преследует две цели: сократить нагрузку на сеть и сервер и/или повысить уровень готовности данных.
Следует отметить, что проектировщики должны четко представлять себе особенности реализации распределенной базы данных используемой СУБД. Не владеющий этой информацией проектировщик рискует создать нерабочую или плохо работающую схему, причем проявится это даже не на моделях, а в реальной эксплуатации. Если вы решили строить распределенную базу данных, позаботьтесь о наличии в штате квалифицированного администратора. Есть одно простое правило: проектировщик не может принять окончательного решения об определении стратегии распределения данных без администратора баз данных. Редко встречаются проектировщики, которые имеют практический опыт администрирования 2-3 серверов баз данных и которые реально работали на них с распределенными базами данных. Для каждой СУБД принципы, влияющие на детали распределения базы данных, индивидуальны.
Особый интерес представляет неоднородная распределенная база данных. Это то, что постоянно, но безуспешно пытаются изживать и проектировщики, и администраторы баз данных. Никто не любит иметь дело со шлюзами данных. Но если неоднородной распределенной базы избежать не удалось, уделите особое внимание выбору шлюзов данных, а также ПО, обеспечивающему синхронизацию информации базах данных под управлением разных СУБД. Если синхронизация данных на узлах под управлением одной СУБД может быть обеспечена самой СУБД (что реализуется большинством производителей), то синхронизация данных на узлах под управлением разных СУБД обеспечивается, как правило, специальным ПО. Тщательно оцените, что будет дешевле: использовать это ПО или импортировать данные и схему и сделать распределенную базу данных однородной.
Следует также отметить, что в подавляющем большинстве реализаций каждый из узлов распределенной базы данных может обслуживаться параллельным сервером баз данных, и это является важным критерием повышения производительности системы. Промышленные СУБД также используют параллельный доступ к хранилищам данных; RAID, например, могут размещать данные, используя не файловую систему операционной системы, а свою файловую систему. Реализация всех этих возможностей существенно различается у различных СУБД. Это означает, что выбор параллельного сервера баз данных должен осуществляться только после серьезных консультаций с администраторами тех СУБД, которые рассматриваются как возможные претенденты на роль сервера баз данных в проекте.
Метод распределения данных по дискам для поддержки параллельных вычислений во многом зависит и от особенностей реализации СУБД. Администратор базы данных не может выбрать такой метод в отрыве от особенностей конкретной информационной системы. Еще одна возможность параллельной обработки данных, предоставляемая СУБД: обработка одного запроса несколькими менеджерами ресурсов. В реализациях также имеется возможность использования одного хранилища данных несколькими серверами баз данных (Parallel Server). Такая архитектура может быть эффективно использована на кластерах.

Хранилище данных 
Информационные системы такого вида сегодня одни из самых актуальных. Хранилище данных характеризуется большим объемом редко изменяемой информации. Хранилище данных обменивается информацией с другими хранилищами; как правило, речь идет о пакетной загрузке. Здесь решаются задачи обработки и хранения больших объемов информации (VLDB, Very Large Databases). Хранилище данных формирует сводное представление обо всех данных информационной системы.
В проектировании хранилищ данных важное место занимают интерфейсы обмена данными и интерфейсы конвертации данных. Следует четко выделить те системы, которые поставляют данные в хранилище, и те, что забирают данные из хранилища.
Внутренняя структура хранилища рассчитана на выполнение сложных запросов. Как правило, хранилище данных обслуживается выделенным сервером, а нередко - параллельным сервером баз данных. Хранилища данных используются для прогнозирования развития бизнеса. Они оснащаются средствами аналитической обработки данных (OLAP, On-Line Analytical Processing). На данный момент существуют специально ориентированные на OLAP версии серверов баз данных.
ПО хранилища баз данных состоит из следующих компонентов (рис. 2):
ПО источников данных. 
Здесь формируются входные пакеты данных, которые в состоянии интерпретировать конвертор и загрузчик данных. Это ПО входит в состав внешних систем (если повезло) или разрабатывается специально; в последнем случае основная его задача - достать данные из внешней системы.
Загрузочная секция (отвечает и за трансформацию данных). 
ПО принимает входные пакеты данных в необработанном формате, проверяет целостность пакета (например, контрольную сумму и т.п.), выполняет первичную обработку пакета (например, расшифровку), а также переводит данные во внутренний формат. Теперь они готовы для передачи в хранилище. Данные загрузочной секции хранятся во внутреннем формате системы, обеспечивающей пересылку данных.
ПО трансформации данных. 
Здесь обеспечиваются пересылка данных в хранилище и логика обработки данных. Данные проходит проверку на корректность, переводятся в нужный формат и интегрируются в хранилище.
Собственно хранилище данных. 
Преимущественно это один или несколько мощных параллельных серверов баз данных, которые обеспечивают обработку информации в хранилище. Само хранилище может быть распределенной среды (распределенная база данных) или трехуровневой среды (централизованная или распределенная база данных и сервер приложений). Собственно база данных хранилища редко представляет собой объединение рабочих баз данных. База данных не обязательно должна быть реляционной. Здесь могут с успехом использоваться расширения, предоставляемые современными СУБД, например Spatial Data-расширения, которые поддерживают многомерные данные.
Интерфейс клиента. 
ПО этого уровня обеспечивает взаимодействие приложений-клиентов, запрашивающих информацию из хранилища. Здесь запрещены операции модификации данных.
Рассмотрим один из приемов проектирования хранилищ данных.
Звездообразная схема (она же многомерная схема, соединение по схеме «звезда», куб данных) состоит из центральной таблицы фактов и нескольких таблиц измерений (рис. 3).
Факты представляют собой основные виды деятельности и факторы, влияющие на бизнес. В таблице измерений хранятся данные, способные оказывать определенное влияние либо порождать те или иные пути развития фактов.
Часто таблица фактов разбивается на секции для повышения скорости доступа к хранящимся в ней записям в зависимости от запроса, поскольку оптимизатор в этом случае сканирует только часть таблицы/индекса (определенную секцию), а не весь объем данных. Отношение между таблицей фактов и таблицей измерения должно быть как можно более простым, так как должен существовать единственно возможный путь их соединения.",1
31,Непроцедурный доступ к данным.docx,"2.3.2.3 Непроцедурный доступ к данным (SQL).
Характерной чертой RDBMS является способность обработки данных как множества; файловые системы и СУБД с другими моделями обрабатывают данные способом ""запись-за-записью"". С RDBMS можно общаться, используя структурированный язык запросов (Structured Query Language - SQL). SQL - непроцедурный язык, который разработан специально для операций доступа к нормализованным структурам реляционных баз данных. Основное различие между SQL и традиционными языками программирования состоит в том, что операторы SQL указывают, какие операции с данными должны выполниться, а не способ их выполнения. 

Список, зарезервированных слов SQL 
Язык SQL включает зарезервированные слова, имеющие определенное значение в операторах SQL. Эти слова нельзя использовать в качестве имен объектов базы данных. 

Комментарии 
Комментарии, заданные ограничителями '/*' и '*/', могут стоять в любом месте оператора SQL: 
ALTER USER petrov /* Это комментарий */ IDENTIFIED BY petr; 
Можно использовать стандартные комментарии ANSI. Все символы после двух дефисов до конца строки игнорируются. 
ALTER USER petrov /* Это комментарий продолжен до конца строки IDENTIFIED BY petr; 

Приоритеты операций 
При вычислении выражения, содержащего несколько операций, ORACLE сначала выполняет операции с более высоким приоритетом. Операции, приведенные на одной и тойже строке, имеют одинаковые приоритеты. 
Замечание: В выражениях можно использовать круглые скобки, чтобы изменять последовательность выполнения операций, предписываемую приоритетом. Выражения, заключенные в скобки, ORACLE вычесляет в первую очередь. Без скобок операции с одинаковым приоритетом ORACLE выполняет слева направо. 

Приоритеты операций SQL 
Унарные арифметические операции + - операция PRIOR 
Арифметические операции * / 
Бинарные арифметические операции + - символьная операция | | 
Все операции сравнения 
Логическая операция NOT 
Логическая операция AND 
Логическая операция OR 

Приоритеты арифметических операций 
Унарные арифметические операции + - 
Арифметические операции * / 
Бинарные арифметические операции + - ",1
34,Процедурное расширение языка SQL.docx,"Процедурное расширение языка SQL - PL/SQL.
Oracle Server - полнофункциональная реляционная СУБД, которая идеально подходит для архитектур клиент/сервер и интернет/интранет. Особенности внутренней архитектуры Oracle ориентированы на обеспечение готовности, максимальной пропускной способности, безопасности и эффективного использования ресурсов. 
Oracle также присущи черты, связанные с используемым языком программирования, которые способствуют ускорению разработки и улучшению эффективности серверной части приложений: 
Один из основных компонентов Oracle Server - его процессор PL/SQL. (PL - Procedural Language - процедурный язык.) 
PL/SQL - язык Oracle четвертого поколения, объединяющий структурированные элементы процедурного языка программирования с языком SQL, разработанный специально для организации вычислений в среде клиент/сервер. Он позволяет передать на сервер программный блок PL/SQL, содержаший логику приложения, как оператор SQL, одним запросом. Используя PL/SQL, можно значительно уменьшить объем обработки в клиентской части приложения и нагрузку на сеть. Например, может понадобиться выполнить различные наборы операторов SQL в зависимости от результата некоторого запроса. Запрос, последующие операторы SQL и операторы условного управления могут быть включены в один блок PL/SQL и пересланы серверу за одно обращение к сети. 
При этом вся логика приложений делится на клиентскую и серверную части. Серверная часть может быть релаизована в виде функций, хранимых процедур и пакетов. 
Функции. Часть логики приложения ориентированной на выполнение конкретного комплекса операций на сервере, результат которых возвращается в виде значения функции. Откомпилированные функции и их исходные тексты содержатся в базе данных. 
Хранимые процедуры. Часть логики приложения, особенно нуждающаяся в доступе к базе данных, может храниться там, где она обрабатывается (на сервере). Хранимые процедуры не возвращают значения результата, обеспечивают удобный и эффективный механизм безопасности. Откомпилированные хранимые процедуры и их исходные тексты содержатся в базе данных. 
Пакеты. Часть логики приложений: фукций и пакетов, предназначеных для решениях задач в рамках одного модуля (подсистемы) АИС. 
Триггеры базы данных. Можно использовать триггеры, чтобы организовать сложный контроль целостности, выполнять протоколирование (аудит) и другие функции безопасности, реализовать в приложениях выдачу предупреждений и мониторинг. 
Декларативная целостность. Ограничения активизируются сервером всякий раз, когда записи вставляются, обновляются или удаляются. В дополнение к ограничениям ссылочной целостности, которые проверяют соответствие первичного и внешнего ключей, можно также накладывать ограничения на значения, содержащиеся в столбцах таблицы. Поддержка целостности на сервере уменьшает размер кода клиентской части, необходимого для проверки допустимости данных, и увеличивает устойчивость бизнес- модели, определенной в базе данных. 

Список, зарезервированных слов PL/SQL 
Язык PL/SQL также включает зарезервированные слова, имеющие определенное значение в операторах PL/SQL. 
",1
12,Системные объекты базы данных.docx,"Системные объекты базы данных.
Словарь данных. Первыми таблицами, создаваемыми в любой базе данных, являются системные таблицы, или словарь данных Oracle. Системные таблицы хранят информацию о структуре базы данных и объектов внутри нее, и Oracle обращается к ним, когда нуждается в информации о базе данных или когда выполняет оператор DDL (Data Definition Language - язык определения данных) либо оператор DML (Data Manipulation Language - язык манипулирования данными). Эти таблицы никогда непосредственно не обновляются, однако обновление в них происходит в фоновом режиме всякий раз, когда выполняется оператор DDL. Главные таблицы словаря данных содержат нормализованную информацию, которая является довольно трудной для восприятия человеком, так что в Oracle предусмотрен набор представлений, выдающих информацию главных системных таблиц в более понятном виде. Oracle запрашивает информацию из таблиц словаря данных для синтаксического разбора любого оператора SQL. Информация кэшируется в области словаря данных разделяемого пула в SGA. 
Сегменты отката. Когда данные в Oracle изменяются, изменение должно быть или подтверждено, или отменено. Если изменение отменяется (""откатывается назад""), содержимое блоков данных восстанавливается в исходное состояние, существовавшее до изменения. Сегменты отката - это системные объекты, которые поддерживают этот процесс. Всякий раз, когда осуществляются какие-либо изменения в таблицах приложения или в системных таблицах, в сегмент отката автоматически помещается предыдущая версия изменяемых данных, так что старая версия данных всегда доступна, если требуется отказ. Другие пользователи при необходимости чтения данных, в то время как изменение не завершено, всегда имеют доступ к прежней версии из сегмента отката. Им предоставляется непротиворечивая по чтению версия данных. После того как изменение фиксируется, доступной становится измененная версия данных. Сегменты отката получают внешнюю память таким же образом, как другие сегменты - экстентами. Сегменту отката, однако, нужно первоначально распределить минимум два экстента. 
Временные сегменты используют пространство в файлах базы данных, чтобы создать временную рабочую область для промежуточных стадий обработки SQL и для больших операций сортировки. Oracle создает временные сегменты в процессе работы и они автоматически удаляются, когда фоновый процесс SMON больше в них не нуждается. Если требуется только небольшая рабочая область, Oracle не создает временного сегмента, но вместо этого как временная рабочая область используется часть памяти PGA (глобальная область программы). Администратор базы данных может определять, в каких табличных пространствах будут располагаться временные сегменты для различных пользователей. 
Сегмент начальной загрузки (или кэш-сегмент) - специальный тип объекта в базе данных, выполняющий начальную загрузку кэша словаря данных в область разделяемого пула SGA. Oracle использует кэш-сегмент только при запуске экземпляра и не обращается к нему вплоть до рестарта экземпляра. Сегмент необходим, чтобы выполнить начальную загрузку кэша словаря данных, после чего занимаемая им память освобождается. 

Словарь данных. 
Фундаментальное различие между RDBMS и другими БД и файловыми системами заключается в способе доступа к данным. RDBMS позволяет обращаться к физическим данным в более абстрактной, логической форме, обеспечивая легкость и гибкость при разработке кода приложения. Программы, использующие RDBMS, обращаются к данным через ""машину"" базы данных без непосредственной зависимости от фактического источника данных, изолируя приложение от деталей ""нижележащих"" физических структур данных. RDBMS сама заботится о том, где поле хранится в базе данных. Такая независимость данных возможна благодаря словарю данных RDBMS, который хранит метаданные (данные о данных) для всех объектов, расположенных в базе данных. 
Словарь данных Oracle - множество таблиц и объектов базы данных, которое хранится в специальной области базы данных и ведется исключительно ядром Oracle. Словарь данных содержит информацию об объектах базы данных, пользователях и событиях. К этой информации можно обратиться с помощью представлений словаря данных. Как показано на рис.31, запросы чтения или обновления базы данных обрабатываются ядром Oracle с использованием информации из словаря данных. 
Информация в словаре данных предназначена для подтверждения существования объектов, обеспечения доступа к ним и описания фактического физического расположения в памяти. 
RDBMS не только обеспечивает размещение данных, но также определяет оптимальный путь доступа для хранения или выборки данных. Oracle использует сложные алгоритмы, которые позволяют выбирать информацию с наибольшей производительностью, исходя из критерия скорейшего получения первых строк результата или критерия минимального времени выполнения запроса в целом. 
Представления словаря данных 
Словарь данных содержит информацию об объектах базы данных, пользователях и событиях. К этой информации можно обратиться с помощью представления словаря данных: 
Динамические таблицы производительности, доступные пользователю SYS, позволяют управлять производительностью работы сервера СУБД. 
Специальные таблицы 
Таблица CHAINED_ROWS 
Список сцепленных строк таблицы или кластера, использованного в команде ANALYZE. 
Таблица EXCEPTIONS 
Эта таблица используется для определения строк, нарушающих правила целостности, если правила целостности включены. 
PLAN_TABLE 
Эта таблица может заполняться командой EXPLAIN PLAN для того, чтобы описать план выполнения оператора SQL. 

2.3.3 Защита данных.
Транзакции, фиксация и откат. Изменения в базе данных не сохраняются, пока пользователь явно не укажет, что результаты вставки, модификации и удаления должны быть зафиксированы окончательно. Вплоть до этого момента изменения находятся в отложенном состоянии, и какие-либо сбои, подобные аварийному отказу машины, аннулируют изменения. 
Транзакция - элементарная единица работы, состоящая из одного или нескольких операторов SQL; 
Все результаты транзакции или целиком сохраняются (фиксируются), или.целиком отменяются (откатываются назад). Фиксация транзакции делает изменения окончательными, занося их в базу данных, и после того как транзакция фиксируется, изменения не могут быть отменены. Откат отменяет все вставки, модификации и удаления, сделанные в транзакции; после отката транзакции ее изменения не могут быть зафиксированы. Процесс фиксации транзакции подразумевает запись изменений, занесенных в журнальный кэш SGA, в оперативные журнальные файлы на диске. Если этот дисковый ввод/вывод успешен, приложение получает сообщение об успешной фиксации транзакции. (Текст сообшения изменяется в зависимости от инструментального средства.) Фоновый процесс DBWR может записывать блоки актуальных данных Oracle в буферный кэш SGA базы данных позже. В случае сбоя системы Oracle может автоматически повторить изменения из журнальных файлов, даже если блоки данных Oracle не были перед сбоем записаны в файлы базы данных. 
Oracle также реализует идею отката на уровне оператора. Если произойдет единственный сбой при выполнении оператора, весь оператор завершится неудачей. Если оператор терпит неудачу в пределах транзакции, остальные операторы транзакции будут находиться в отложенном состоянии и должны либо фиксироваться, либо откатываться. 
Все блокировки, захваченные транзакцией, автоматически освобождаются, когда транзакция фиксируется или откатывается, или когда фоновый процесс PMON отменяет транзакцию. Кроме того, другие ресурсы системы (такие как сегменты отката) освобождаются для использования другими транзакциями. 
Точки сохранения позволяют устанавливать маркеры внутри транзакции таким образом, чтобы имелась возможность отмены только части работы, проделанной в транзакции. Целесообразно использовать точки сохранения в длинных и сложных транзакциях, чтобы обеспечить возможность отмены изменения для определенных операторов. Однако это обусловливает дополнительные затраты ресурсов системы - оператор выполняет работу, а изменения затем отменяются; обычно усовершенствование в логике обработки могут оказаться более оптимальным решением. Oracle освобождает блокировки, захваченные отмененными операторами. 
Целостность данных связана с определением правил проверки достоверности данных гарантирующих, что недействительные данные не попадут в ваши таблицы. Oracle позволяет определять и хранить эти правила для объектов базы данных, которых они касаются, таким образом, чтобы кодировать их только однажды. При этом они активируются всякий раз, когда какой-либо вид изменения проводится в таблице, независимо от того, какая программа выполняет вставки, модификации или удаления. Этот контроль осуществляется в форме ограничений целостности и триггеров базы данных. 
Ограничения целостности устанавливают бизнес-правила на уровне базы данных, определяя набор проверок для таблиц системы, Эти проверки автоматически выполняются всякий раз, когда вызываются оператор вставки, модификации или удаления данных в таблице. Если какие-либо ограничения нарушены, операторы отменяются. Другие операторы транзакции остаются в отложенном состоянии и могут фиксироваться или отменяться согласно логике приложения. 

2.3.4 Привилегии системного уровня
Каждый пользователь Oracle, определяемый в базе данных, может иметь одну или несколько из более чем 80 привилегий системного уровня. Эти привилегии очень тонко управляют правами выполнения команд SQL. Администратор базы данных назначает системные привилегии или непосредственно пользовательским учетным разделам Oracle, или ролям. Роли затем назначаются учетным разделам Oracle. 
Например, прежде чем создать триггер для таблицы (даже если вы владелец таблицы как пользователь Oracle), нужно иметь системную привилегию, называемую CREATE TRIGGER, назначенную вашему учетному разделу пользователя Oracle, или роли, присвоенной учетному разделу. 
Привилегия CREATE SESSION - другая часто используемая привилегия системного уровня. Чтобы выполнить соединение с базой данных, учетный раздел Oracle должен иметь привилегию системного уровня CREATE SESSION. 
Привилегии объектного уровня. Привилегии объектного уровня обеспечивают возможность выполнить определенный тип действия (выбрать, вставить, модифицировать, удалить и т.д.) с указанным объектом. Владелец объекта имеет полный контроль над объектом и может выполнять любые действия с ним; он не обязан иметь привилегии объектного уровня. Фактически владелец объекта - пользователь Oracle, который может предоставлять привилегии объектного уровня другим пользователям. 
Например, если пользователь, который владеет таблицей, желает, чтобы другой пользователя вставлял и выбирал строки из его таблицы (но не модифицировал или удалял), он предоставляет другому пользователю привилегии (объектного уровня) отбора и вставки для этой таблицы. Вы можете предоставлять привилегии объектного уровня непосредственно пользователям или ролям, которые затем назначаются учетным разделам пользователей Oracle. 
Привилегии выдаются пользователям и ролям командой GRANT и отбираются командой REVOKE. Все привелегии можно разделить на системные и объектные. Системные привилегии относятся ко всему классу объектов, а объектные относятся к заданным объектам. ",1
7,Технология создания распр ИС.docx,"2. ТЕХНОЛОГИИ СОЗДАНИЯ РАСПРЕДЕЛЕННЫХ ИНФОРМАЦИОННЫХ СИСТЕМ
Построение современных распределенных информационных систем сегодня на прямую связано с реаляционными и объектно-ориентированными СУБД, которые в последнее время утвердились как основные средства для обработки данных в информационных системах различного масштаба - от больших приложений обработки транзакций в банковских системах до персональных систем на РС. В настоящее время существует множество систем управления базами данных (СУБД) и других программ выполняющих сходные функции. Инструментальные средства Oracle - одни из лучших и наиболее мощных имеющихся инструментов разработки профессионального класса. 

2.1 Базы данных и их сравнительные характеристики.
2.1.1 Классификация моделей построения баз данных
В зависимости от архитектуры СУБД делятся на локальные и распределенные СУБД. Все части локальной СУБД размещаются на одном компьютере, а распределенной на нескольких. За несколько десятилетий последовательно появлялись системы (СУБД), основанные на трех базовых моделях данных: иерархической, сетевой и реляционной. Основные определения теории баз знаний и баз данных представлены в таблице 1. 
База данных (БД)  Базами данных называют электронные хранилища информации, доступ к которым осуществляется с помощью одного или нескольких компьютеров.
Системы управления базами данных (СУБД)  это программные средства для создания, наполнения, обновления и удаления баз данных.
База знаний  Базы знаний это хранилища знаний, представленных в формализованном виде.
Система управления базами знаний СУБЗ  это программные средства для создания, наполнения, обновления и удаления баз знаний.
Виды знаний: 
Процедурные  Знания, отвечающие на вопрос ""Как решать поставленную задачу?"" 
Декларативные  Знания, не содержащие в явном виде процедуры решения задач. 
Каузальные  Знания о причинно-следственных связях между объектами предметной области 
Неточные  Знания отличающиеся неполнотой или противоречивостью.
Парадигмы решения задач:
В СУБД  Данные + Алгоритм = Программа решения задачи.
В СУБЗ  Знания + Стратегия вывода = Решение проблемы.
Модели знаний:
Продукционная  Знания представленные в формате ""ЕСЛИ-ТО"".
Фреймовая  Знания представленные в виде набора взаимосвязанный фреймов. 
Семантическая сеть  Граф, вершины которого соответствуют объектам или понятиям, а дуги определяют отношения между вершинами.
Фрейм  Структурированное описание объекта предметной области состоящее из наименования объекта (имя фрейма), атрибутов объекта (свойств, характеристик) - слоты фрейма. 
Фрейм прототип  Это фрейм у которого значения слотов не определены. 
Конкретный фрейм  Это фрейм прототип с конкретными значениями.
Enterprise JavaBeans  Стандарт для создания средствами языка Java пригодных для многократного использования компонентов, из которых формируются прикладные программы. Компоненты Enterprise JavaBeans облегчают разработку программ, обеспечивающих доступ к хранимой в базе данных информации.
Распараллеливание обработки запроса (Intraquery parallelism)  Использование нескольких ЦП для обработки одного запроса.
Параллельная обработка запросов (interquery parallelism) подразумевает параллельную обработку нескольких запросов (на разных ЦП).
Уровень изоляции (Isolation level).Установочный параметр БД, определяющий, в какой степени одновременно обратившиеся к базе данных пользователи могут оказывать влияние на работу друг друга. Как правило, используются три уровня изоляции: завершение чтения (read committed), характеризуется большим количеством одновременно обслуживаемых пользователей и низким уровнем изоляции каждого из них); в установленном порядке (serializable), небольшое число одновременно обслуживаемых пользователей, высокая степень изоляции и повторяющееся чтение (repeatable read), сочетание двух первых уровней.
Технология СОМ  COM - Component Object Model - Компонентная модель объектов, предложена корпорацией Микрософт.

2.1.1.1 Иерархическая модель
Первые иерархические и сетевые СУБД были созданы в начале 60-х годов. Причиной послужила необходимость управления миллионами записей (связанных друг с другом иерархическим образом), например при информационной поддержке лунного проекта Аполлон. Среди реализуемых на практике СУБД этого типа преобладает система IMS (Information Management System компании IBM) (На данный момент это самая распространенная СУБД из всех данного типа). Применяются и другие иерархические системы: TDMS (Time-Shared Date Management System) компании Development Corporation; Mark IV Multi - Access Retrieval System компании Control Data Corporation; System - 2000 разработки SAS-Institute. 
Отношения в иерархической модели данных организованы в виде совокупностей деревьев, где дерево - структура данных, в которой тип сегмента потомка связан только с одним типом сегмента предка. Графически: Предок - точка на конце стрелки, а Потомок - точка на острие стрелки. В базах данных определено, что точки - это типы записей, а стрелки представляют отношения один - к - одному или один - ко - многим. 
К ограничения иерархической модели данных можно отнести: 
Отсутствует явное разделение логических и физических характеристик модели; 
Для представления неиерархических отношений данных требуются дополнительные манипуляции; 
Непредвиденные запросы могут требовать реорганизации базы данных. 

2.1.1.2 Сетевая модель.
Сети - естественный способ представления отношений между объектами. Они широко применяются в математике, исследованиях операций, химии, физике, социологии и других областях знаний. Сети обычно могут быть представлены математической структурой, которая называется направленным графом. Направленный граф имеет простую структуру. Он состоит из точек или узлов,соединенных стрелками или ребрами. В контексте моделей данных узлы можно представлять как типы записей данных, а ребра представляют отношения один-к -одному или один-ко-многим. Структура графа делает возможными простые представления иерархических отношений (таких, как генеалогические данные) . 
Сетевая модель данных - это представление данных сетевыми структурами типов записей и связанных отношениями мощности один-к-одному или один-ко-многим. В конце 60-х конференция по языкам систем данных (Conference on Data Systems Languages, CODASYL) поручила подгруппе, названной Database Task Group (DTBG), разработать стандарты систем управления базами данных. На DTBG оказывала сильное влияние архитектура, использованная в одной из самых первых СУБД, Iategrated Data Store (IDS), созданной ранее компанией General Electric.Это привело к тому, что была рекомендована сетевая модель. 
Документы Database Task Group (DTBG) (группа для разработки стандартов систем управления базами данных) от 1971 года остается основной формулировкой сетевой модели, на него ссылаются как на модель CODASYL DTBG. Она послужила основой для разработки сетевых систем управления базами данных нескольких производителей. IDS (Honeywell) и IDMS (Computer Associates) - две наиболее известных коммерческих реализации. В сетевой модели существует две основные структуры данных: типы записей и наборы: 
Тип записей. Совокупность логически связанных элементов данных. 
Набор. В модели DTBG отношение один-ко-многим между двумя типами записей. 
Простая сеть. Структура данных, в которой все бинарные отношения имеют мощность один-ко-многим. 
Сложная сеть. Структура данных, в которой одно или несколько бинарных отношений имеют мощность многие-ко-многим. 
Тип записи связи. Формальная запись, созданная для того, чтобы преобразовать сложную сеть в эквивалентную ей простую сеть.
В модели DBTG возможны только простые сети, в которых все отношения имеют мощность один-к-одному или один-ко-многим. Сложные сети, включающие одно или несколько отношений многие-ко-многим, не могут быть напрямую реализованы в модели DBTG. Следствием возможности создания искусственных формальных записей является необходимость дополнительного объема памяти и обработки, однако при этом модель данных имеет простую сетевую форму и удовлетворяет требованиям DBTG. 

2.1.1.3 Реляционная модель.
В 1970-1971 годах Е.Ф.Кодд опубликовал две статьи, в которых ввел реляционную модель данных и реляционные языки обработки данных - реляционную алгебру и реляционное исчисление. 
Реляционная алгебра Процедурный язык обработки реляционных таблиц. 
Реляционное исчисление Непроцедурный язык создания запросов. 
Все существующие к тому времени подходы к связыванию записей из разных файлов использовали физические указатели или адреса на диске. В своей работе Кодд продемонстрировал, что такие базы данных существенно ограничивают число типов манипуляций данными. Более того, они очень чувствительны к изменениям в физическом окружении. Когда в компьютерной системе устанавливался новый накопитель или изменялись адреса хранения данных, требовалось дополнительное преобразование файлов. Если к формату записи в файле добавлялись новые поля, то физические адреса всех записей файла изменялись. То есть такие базы данных не позволяли манипулировать данными так, как это позволяла бы логическая структура. Все эти проблемы преодолела реляционная модель, основанная на логических отношениях данных. 
Существует два подхода к проектированию реляционной базы данных. 
Первый подход заключается в том, что на этапе концептуального проектирования создается не концептуальная модель данных, а непосредственно реляционная схема базы данных, состоящая из определений реляционных таблиц, подвергающихся нормализации. 
Второй подход основан на механическом преобразовании функциональной модели, созданной ранее, в нормализованную реляционную модель. Этот подход чаще всего используется при проектировании больших, сложных схем баз данных, необходимых для корпоративных информационных систем. 
Табл.1. Основные определения реляционных СУБД 
",1
13,Требования к проекту.docx,"Требования к проекту
Введение
Относительно свободная форма изложения, принятая авторами, допускает введение новых терминов и соответствующих им понятий, так сказать, по ходу изложения материала, не обременяя читателя отдельно вынесенными определениями или описаниями. Но это только там, где авторы надеются на опыт и интуицию читателя. Например, с самого начала используется термин требования к проекту (или, коротко, требования), обозначающий ""то, что под этим понимают компетентные люди"". 
Но есть термины, с которыми подобные вольности недопустимы. В статье вводится понятие область требований. В российских стандартах существует термин предметная область, а в украинских — предметна сфера, однако область требований обозначает нечто принципиально другое. 
Почему именно ""область"", а не класс, к примеру, или группа? Тут две причины: 
Часто необходимо учитывать не только актуально существующие требования, но и требования, которых сейчас нет, но которые потенциально могут возникнуть. Кроме того, иногда необходимо принимать во внимание именно факт отсутствия требований, обладающих определенными свойствами. В этих случаях термин пустая область воспринимается гораздо естественнее, чем, скажем, пустой класс или пустая группа. 
Для визуализации предлагается авторский тип диаграмм, где каждой области требований соответствует графическая область на диаграмме. 
Области требований могут частично перекрываться, равно как одна из них может полностью содержать другую, отражая тем самым какое-либо из свойств принадлежащих им требований. Области требований очень похожи на диаграммы Венна из теории множеств. И чем в большей степени каждое отдельное требование будет обладать свойствами атомарности и отличимости (обязательные свойства для элемента множества), тем больше математических результатов из теории множеств можно будет применить. 
Предлагаемый метод построения диаграмм областей является инструментом аналитика для процедуры начальной классификации требований. В процессе выделения существенных в данном конкретном случае областей, определения их взаимосвязей относительно включения-пересечения и распределения имеющихся требований по соответствующим областям аналитик приходит ко все более точному и глубокому пониманию сути самих требований. 
По ходу изложения материала диаграмма будет эволюционировать от вспомогательного и совсем не обязательного инструмента визуализации простых и очевидных понятий до самостоятельного, мощного механизма, несущего глубокую семантику и, при необходимости, являющегося прочной базой для дальнейшей формализации и применения математических методов. 

Диаграмма областей требований
Простейший случай диаграмм
Итак, в простейшем случае на диаграмме имеем область всех мыслимых и ""немыслимых"" требований — наш аналог универсального множества в математике. 
В рамках этого универсального множества всех требований выделяем две большие области: область компетенции и состоятельности Заказчика и область компетенции и состоятельности Разработчика. 
Таким образом, есть Заказчик и Разработчик, у каждого из них — своя область компетенции и состоятельности. Чем дальше в сторону информационных технологий смещаемся, тем шире область компетенции и состоятельности Разработчика. Соответственно, чем дальше в противоположную сторону (сторону технологий из предметной области) — тем меньше специалисты разработчика показывают сообразительности и готовых наработок. 
С другой стороны, чем более мощные информационные технологии предлагаются Заказчику, тем меньше у него находится соответствующих задач и тем меньше сотрудников, способных разобраться как в самих задачах, так и в предлагаемых методах автоматизации их решения. 
Диалог между представителями Заказчика и Разработчика становится конструктивным только тогда, когда области их компетентности и состоятельности начинают пересекаться. 
Другими словами, информационное образование экспертов Заказчика должно позволять им формулировать свои требования пусть на ломаном, но все-таки ""человеческом"" языке, с одной стороны. А с другой — иметь элементарные представления об автоматизации для необходимой оценки и критики предлагаемых Разработчиком методов. 
В свою очередь, опыт аналитиков Разработчика должен достичь такого уровня, чтобы они имели возможность разобраться в плохо структурированных лекциях экспертов Заказчика, состоящих на 80% из изложения частных случаев и исключений, каждый из которых просто ""вопиит гласом велиим"" о высочайшем уровне и исключительности данного эксперта в его области деятельности. 
Но серьезное сотрудничество начинается только тогда, когда на пересечении этих двух областей, которое можно назвать областью взаимопонимания, накапливается некая ""критическая масса"" требований. Именно эти требования и являются основным материалом для переговоров и обоснования целесообразности самых ранних этапов разработки проекта. 
Замечательно, что этими требованиями, как правило, не может пренебречь даже высшее руководство — как с одной, так и с другой стороны. Как правило, эти требования в обязательном порядке попадают в официальные документы и именно на них ""высокие договаривающиеся стороны"" своими широкими руководящими жестами ставят две черты: порог рациональной автоматизации и порог рациональной формализации предметной области Заказчика. 
Эти две руководящие директивные черты отрезают две небольшие, но очень интересные области: 
излишние требования к автоматизации от особо грамотных сотрудников Заказчика; 
излишняя формализация предметной области от особо рьяных аналитиков Разработчика. 
Примером требования из первой области может служить пожелание системного администратора Заказчика: получить систему автоматического архивирования базы данных корпорации на какое-нибудь нестандартное устройство со своим специфическим программным обеспечением по его управлению (какой-нибудь древний стример или новейший CD-RW, оборудованный механическим чейнджером). 
Пример для второй области — система автоматического ценообразования для работы дизайнеров или парикмахеров, основанная на эстетических признаках. 
Как всегда, сроки — сжаты, бюджет — ограничен. А потому от руководства дается однозначная установка: никаких новшеств, никаких изысканий, реализуем только четко очерченную область требований — просчитать сроки и бюджет. 
Итак, сроки и бюджет скрупулезно подсчитаны, скорректированы и утверждены на высшем уровне. 
Приступаем к воплощению… и с ужасом обнаруживаем: для реализации требования В необходима реализация требований, оставшихся за пределами внимания руководства,— А или C. 
В экстренном порядке собирается совещание, на котором руководство Разработчика (наконец-то) хоть немного прислушивается к мнению непосредственных исполнителей и на котором за бурными дебатами прячется основная цель: решить, кто же будет расплачиваться за промах. Руководство ли, вынужденное оплатить реализацию одного из требований A или C, — или же непосредственные исполнители, вынужденные реализовать все те же требования A или C, но (!) без дополнительных финансовых и человеческих ресурсов (в лучшем случае будет дана отсрочка по времени, потому что, как правило, все делается за счет ""авралов"" и ""переработок""). 
Итак, приходим к пониманию, что существует еще одна область (рис. 7). Область требований, удовлетворение которых обязательно для реализации проекта в целом и, в частности, для реализации задокументированных и утвержденных требований. Ограничение ресурсов на реализацию этих требований или попытка обойтись вообще без их реализации ведет прямиком к завалу проекта. 
Как только руководство принимает решение — требования из этой области не реализовывать — исполнители встают перед необходимостью делать это за свой счет. В результате наблюдается явление откачки средств и ресурсов из среды исполнителей. Это может выразиться в переработках, задействовании личных наработок или скрытого аутсорсинга исполнителей. 
В любом случае результатом будут напряженные отношения между высшим руководством и исполнителями, грозящие перерасти сначала в скрытый, а потом и в явный конфликт. В случае если трудовые отношения построены по принципу ""от конечного результата"", пострадавшей стороной (то есть стороной, несущей потери) окажется непосредственный исполнитель. В случае же отношений с повременной оплатой все финансовые потери ложатся на плечи руководства Разработчика. 
И в том, и в другом случае Заказчику извне ситуация с развитием проекта кажется неопределенной, но, тем не менее, не предвещающей больших тревог — хотя именно в это время закладывается мина замедленного действия под успех проекта в частности и сотрудничество вообще. Тогда как в случае проявления инициативы со стороны Заказчика в сторону переговоров с целью увеличения сметы проекта катастрофические процессы могут быть погашены. 
Проще говоря, рассчитывать на конструктивную деятельность со стороны своего руководства исполнителям Разработчика не приходится. Провести переговоры и добиться разумного и обоснованного увеличения бюджета — дело немыслимое, а проявление инициативы в этом направлении со стороны руководства Разработчика вообще принято считать дурным тоном. 
С другой стороны, предложение со стороны Заказчика — увеличить бюджет проекта — помимо того что дает возможность решить проблему, еще и работает в сторону повышения имиджа не только Заказчика, но и Разработчика. 
Однако на практике мы нередко наблюдаем весьма печальную и уродливую картину. Руководство Разработчика, зажатое реальными и весьма серьезными проблемами по реализации упущенных требований с одной стороны и мнимыми, но весьма болезненными проблемами по преодолению имиджевого стереотипа поведения с другой, все-таки вынуждено действовать. События развиваются по плану, который, может, и кажется счастливой находкой — но на деле лишь оттягивает момент кризиса, приводя к еще более тяжелой ситуации. 
На переговорах Руководство разработчика подает сложившуюся ситуацию в очень выгодном (но только при поверхностном взгляде) свете: во время работы над проектом оказалось, что в общем ключе работ, не изменяя идеологии, возможно получить намного более привлекательный для Заказчика продукт, чем предполагалось изначально. Для этого необходимо всего лишь незначительно увеличить бюджет, но (!) прямо на текущей стадии разработки проекта. 
Очевидными плодами такого подхода будут: 
получение дополнительного финансирования, едва достаточного для закрытия образовавшегося прорыва и относительно благополучного завершения проекта в его изначальной редакции; 
обнародование необходимых, но упущенных пунктов, под видом доработок, составляющих новизну и привлекательность проекта в его новой редакции; 
целый пакет новых и весьма амбициозных требований, главными свойствами которых будут повышенная туманность формулировок и, как следствие, повышенные риски в реализации; 
фактические затраты на реализацию этих новых требований окажутся, в лучшем случае, большими не на порядок, а лишь в несколько раз. 
Есть простой признак, позволяющий Заказчику распознать такую ситуацию. Предложения об улучшениях поступают от Разработчика в конце временной цепочки его состояний: спад активности — неопределенность — бурная внутренняя деятельность — предложение чего-то лучшего. Вот уж действительно, лучшее — враг хорошего. 
Напротив, если предложения об улучшении явились результатом ровной работы аналитиков Разработчика, да еще и при болезненном для Заказчика вскрытии его внутренних проблем,— тогда это может служить поводом к доверительной оценке таких предложений. 
Существует еще одна область требований, реализация которых необходима для поддержания естественной и полноценной работы системы в соответствии со взаимно понятными и задокументированными требованиями (рис. 8). Изначально, требования из этой области не были замечены аналитиками Разработчика и считались в равной мере как очевидными, так и обязательными, с точки зрения экспертов Заказчика. 
Если проигнорировать реализацию этих Требований, то Заказчик получит Систему, в которой функционирование автоматической части должно поддерживаться большим объемом окружающего ручного труда. Грубо говоря, придется заводить штат сотрудников, специалистов Предметной Области, работающих на Систему. 
Авторам пришлось внедрять сторонний продукт, в котором был реализован автоматический выбор варианта делопроизводства в зависимости от текущего состояния счета клиента. При этом велся строгий учет самих платежных документов и даты их прихода. Главным упущением аналитиков Разработчика оказалась реализация системы как автомата, реагирующего на наличие определенного платежного документа, а не на общий баланс по счету. Надо было видеть мучения делопроизводителей, вынужденных в угоду системе редактировать пересчитанные вручную суммы по соответствующим документам, а то и вводить дополнительные фиктивные документы… 
Да простит меня читатель за случившееся отступление от темы статьи: формальная модель для классификации требований. Прорвались наболевшие наработки по родственному, но все-таки другому направлению — ""Как гарантированно завалить проект"" (конструктивное название должно быть таким ""Риски ошибок в руководстве проектом: какими они бывают и как их избежать""). Возможно, это действительно станет названием следующей статьи, пока же приведенные язвительные примеры послужат лишь подтверждением тому, что за видимой сухостью и формальностью предлагаемой диаграммы кроются болезненные вопросы, сплошь и рядом возникающие в реальных, ""живых"" проектах. А для обсуждения подобных наболевших вопросов ой как нужна хорошая их визуализация! 
Но вернемся к нашей диаграмме и выделенной там области… и зададимся вопросом: ""А почему, собственно, область поддерживающих требований должна иметь именно такой вид?"" Почему не так, как на рис. 9? 
Другой интересный вопрос: а какой смысл в двух различных подобластях данной области? Чем, по сути, отличаются требования A и C? Но об этом чуть далее. 
А по перовому вопросу очевидно, что диаграмма на приведенном рисунке является просто проявлением более глубокого подхода и дает более интересные результаты, обсуждение которых следовало бы вынести за пределы данной ознакомительной статьи. Мы же ограничимся упрощенным вариантом (рис. 7) и пойдем далее. 
Итак, имеем две зеркальные — как по расположению на диаграмме, так и по своим проявлениям в процессе разработки,— области: 
область контекста реализации — область поддерживающих требований, необходимых для полноценной реализации Разработчиком задокументированной части проекта; 
область контекста использования — зеркальная предыдущей и включающая требования, которые остались за пределами документов, но обязательны для полноценной работы заказчика. 
Теперь настало время ""показать семантику второго измерения"". Проще говоря, ответить на поставленный ранее вопрос: а чем, собственно, отличается левая подобласть от симметричной ей правой? Если для полноценной работы Заказчика в соответствии с требованием E необходима реализация одного из поддерживающих требований D или F (рис. 9), то чем они между собой отличаются и что общего у них с зеркальными им требованиями A и C? 
Внимательный читатель уже заметил две стрелочки в верхней и нижней части рисунка, подписи которых имеют простой смысл: чем левее на рисунке расположена точка, обозначающая требования, тем больше это требование опирается на широко известные и общепринятые методы решения, стандартное и распространенное оборудование, соответствующее программное обеспечение и т.д. А чем правее — тем больше особенностей в методах решения (вплоть до ноу-хау и патентов), тем больше специального оборудования и\или специального ПО. 
И не случайно стрелочка, указывающая стремление использовать стандартные методы, расположена в верхней части, соответствующей стремлениям Разработчика. Именно от него зачастую звучат размашистые предложения в стиле: да, для решения задач такой серьезной и представительной организации, как Заказчик, ну просто необходимы: СУБД — не меньше и не дешевле Oracle 9, CRM-системы — не ниже самого ""Сибел-системз"", а для решения задач коммуникации без приобретения спутника с антеннами вообще не обойтись. 
В ответ на такие предложения со стороны Заказчика активно выдвигаются возражения, что подобная мощь (читай — такие большие расходы) ему абсолютно ни к чему, что вполне достаточно существующей базы и что сотрудники Заказчика успешно справляются со своими задачами чуть ли не с калькулятором и на бумаге … 
Существует лишь несколько задач, реально нуждающихся в автоматизации. Именно они являются особенностью деятельности Заказчика, их решение должно дать Заказчику конкурентные преимущества и т.д. 
Изюминкой оказывается комплекс из уникальности самих задач, методов их решения и бессмысленности автоматизации всего остального без автоматизации именно этого… 
В данном случае особенно к месту оказывается следующий пример из области делопроизводства. Существует обязательное требование E: система должна автоматически реагировать на состояние счета клиента и конфигурацию платежных документов. Существуют особые случаи, в которых необходим перерасчет сумм по платежным документам и реализация требования E нуждается в удовлетворении одного из требований D или F. Пример для требования F — наличие какого-то удобного и логичного механизма для перерасчета. Требование D — ужесточение (стандартизация) требований на платежные документы, исключающие возникновение запутанных ситуаций. 
Для зеркальных требований A, B, C можно привести такой пример. B — набор отчетов, генерируемых из БД. Особенность — один или несколько из них не реализуются в виде единственного, пусть и сложного, SQL-запроса. Необходимы хранимые процедуры. Для реализации этого требования следует реализовать либо требование A — использовать Т-SQL с соответствующими механизмами MS-SQL Server (стандартное решение — и никакой головной боли Разработчику) либо требование С — использовать ODBC-интерфейс к файлу MS Access, на чем настаивает Заказчик. Но тогда Разработчику придется засучить рукава — и разрабатывать собственный эмулятор хранимых процедур. Вот вам и уникальность, и специфичность разработки. 
Собственно, на этом ознакомительную статью можно и закончить. Заинтересованный читатель уже в состоянии самостоятельно развивать далее предложенный подход, что нас только порадует. ",1
17,Условия целостности БД.docx,"2.1.1.3.1. Ограничительные условия, поддерживающие целостность базы данных
Как следует из определения ссылочной целостности при наличии в ссылочных полях двух таблиц различного представления данных происходит нарушение ссылочной целостности, такое нарушение делает информацию в базе данных недостоверной. Чтобы предотвратить потерю ссылочной целостности, используется механизм каскадных изменений (который чаще врего реализуется специальными объектами СУБД - триггерами). Данный механизм состоит в следующей последовательсности действий: 
при изменении поля связи в записи родительской таблицы следует синхронно изменить значения полей связи в соответствующих записях дочерней таблицы; 
при удалении записи в родительской таблицы следует удалить соответствующие записи и в доцерней таблице. 

2.1.1.3.2 Поцесс нормализации
Нормализация - процесс приведения реляционных таблиц к стандартному виду. В базе данных могут присутствовать такие проблемы как: 
Избыточность данных.Повторение данных в базе данных. 
Аномалия обновления. Противоречивость данных, вызванная их избыточностью и частичным обновлением. 
Аномалия удаления. Непреднамеренная потеря данных, вызванная удалением других данных. 
Аномалия ввода. Невозможность ввести данные в таблицу, вызванная отсутствием других данных. 
Для решения этих проблем применяют разбиение таблиц - разделение таблицы на несколько таблиц. Для того чтобы это сделать пользуются нормальными формами или правилами структурирования таблиц. 

Первая нормальная форма 
Реляционная таблица находится в первой нормальной форме (1НФ), если значения в таблице являются атомарными для каждого атрибута таблицы, т.е. такими значениями, которые не являются множеством значений или повторяющейся группой. В определении Кодда реляционной модели уже заложено, что реляционные таблицы находились в 1НФ, 

Вторая нормальная форма. 
Реляционная таблица находится во второй нормальной форме (2НФ), если никакие неключевые атрибуты не являются функционально зависимыми лишь от части ключа. Таким образом, 2НФ может оказаться нарушена только в том случае, когда ключ составной. 
Функциональная зависимость.Значение атрибута в кортеже однозначно определяет значение другого атрибута в кортеже. 
Более формально можно определить функциональную зависимость следующим образом: если А и В - атрибуты в таблице В, то запись ФЗ (функциональную зависимость): А - "" В обозначает, что если два кортежа в таблице В имеют одно и то же значение атрибута А, то они имеют одно и то же значение атрибута В. Это определение такжеприменимо,если А и В - множества столбцов, а не просто отдельные столбцы. 
Атрибут в левой части ФЗ называется детерминантом, так как его значение определяет значение атрибута в правой части. Ключ таблицы является детерминантом, так как его значение однозначно определяет значение каждого атрибута таблицы. 
Процесс разбиения на две 2НФ-таблицы состоит из следующих шагов: 
Создается новая таблица, атрибутами которой будут атрибуты исходной таблицы, входящие в противоречащую правилу ФЗ. Детерминант ФЗ становится ключом новой таблицы. 
Атрибут, стоящий в правой части ФЗ, исключается из исходной таблицы. 
Если более одной ФЗ нарушают 2НФ, то шаги 1 и 2 повторяются для каждой такой ФЗ. 
Если один и тот же детерминант входит в несколько ФЗ, то все функционально зависящие от него атрибуты помещаются в качестве неключевых атрибутов в таблицу, ключом которой будет детерминант. 

Третья нормальная форма 
Реляционная таблица имеет третью нормальную форму (ЗНФ), если для любой ФЗ: Х - У Х является ключом. Заметим, что любая таблица, удовлетворяющая ЗНФ, также удовлетворяет и 2НФ. Однако обратное неверно. 
Критерийнормальной формы Бойса-Кодда (НФБК) утверждает, что таблица удовлетворяет ЗНФ, если в ней нет транзитивных зависимостей. Транзитивная зависимость возникает, если неключевой атрибут функционально зависит от одного или более неключевых атрибутов. То есть этот критерий учитывает следующие два случая: 
Неключевой атрибут зависит от ключевого атрибута, входящего в составной ключ (критерий нарушения 2НФ). 
Ключевой атрибут, входящий в составной ключ, зависит от неключевого атрибута. 
Таким образом, если таблица удовлетворяет НФБК, то она также удовлетворяет ЗНФ в смысле транзитивных зависимостей и 2НФ. 

Четвертая нормальная форма 
Таблица имеет четвертую нормальную форму (4НФ), если она имеет ЗНФ и не содержит многозначных зависимостей. Поскольку проблема многозначных зависимостей возникает в связи с многозначными атрибутами, то мы можем решить проблему, поместив каждый многозначный атрибут в свою собственную таблицу вместе с ключом, от которого атрибут зависит. 

Пятая нормальная форма. 
Пятая нормальная форма (5НФ) была предложена для того, чтобы исключить аномалии, связанные с особым типом ограничительных условий, называемых совместными зависимостями. Эти зависимости имеют в основном теоретический интерес и сомнительную практическую ценность. Следовательно, пятая нормальная форма в действительности не имеет практического применения. 

Нормальная форма область/ключ. 
Таблица имеет нормальную форму область/ключ (НФОК), если любое ограничительное условие в таблице является следствием определений областей и ключей. Однако не был дан общий метод приведения таблицы к НФОК. 
В качестве примера, рассмотрим структуру реляционной базы данных, описывающей ""отношения"" пациентов и докторов в произвольной клинике (область приложения примера выбрана из-за того, что в сертификационных тестах Oracle аналогичные примеры встречаются очень часто). Пусть существует некая клиника, основные характеристики которой описываются в таблице CLINICS, в данной клинике работают доктора, основные характеристики которых описывает таблица DOCTORS. Данные пациентов клиники хранятся в таблице PATIENTS. Взаимосвязи между таблицами представлены на рис.10. (Для упрощения предполагается, что у доктора может быть несколько пациентов, которые не являются пациентами других докторов, для реализации реальной картины, когда один пациент может относиться к нескольким разным докторам, между таблицами DOCTORS и PATIENTS необходимо включить дополнительную связывающую таблицу). 
Представленная структура, конечно, не обладает функциональной полнотой с точки зрения проектирования АИС клиники, с ее помощью мы лишь рассмотрим различные типы отношений в реляционных СУБД. 
Перед тем, как перейти к рассмотрению вопросов стандартизации и целостности данных в РСУБД несколько рекомендаций по выбору наименований таблиц и полей. Внимательно взглянув на описание таблиц можно заметить, что генерация наименований таблиц и столбцов подчиняется некоторой синтаксической конструкции, которая в общем виде может быть представлена следующим образом: 
Для таблиц: 
<Псевдоним АИС>_<Псевдоним модуля АИС>_:_<Псевдоним подмодуля>_<Имя таблицы>
Например, если бы мы разрабатывали АИС клиники c сокращенным названием CSL, то все таблицы входящие в данную систему было бы целесообразно называть 
CSL_<имя модуля>_<имя таблицы>.
Для столбцов: 
<Псевдоним таблицы>_<имя столбца>.
Например, как показано на рис.10. Регистрационный номер пациента храниться в поле PT_REG_NUMBER, таблицы PATIENTS, имеющий псевдоним PT. 
Конечно, использование этих не хитрых правил не является обязательным, но позволяет значительно облегчить читаемость разработанной информационной структуру. Предположите, как было бы все, если бы поля таблиц назывались P111, P112 и т.п., а ведь такие вещи встречаются практически очень часто, например в FoxPro 2.6. 
Перейдем к рассмотрению вопросов стандартизации и обеспечения ссылочной целостности реляционных таблиц. 

Преобразование отношений 
Поля таблиц могут находиться между собой в одном из следующих отношений: 
один-к-одному, один-ко-многим, многие-ко-многим и рекурсивных, определения которых приведены в табл.1. Рассмотрим преобразование отношений на примере АИС ""ДОКТОР-ПАЦИЕНТ"" (рис.10). 
Отношение один-к-одному представляет собой такое отношение, при котором каждой записи в таблице А соответствует единственная запись в таблице В (рис.11). Применение такого типа отношений встречается крайне редко и предназначено в основном для функционального разделения информации на несколько таблиц, т.е. когда не хотят, чтобы таблица БД ""распухала"" от второстепенной информации. На рис.10 представлено, как используя отношение один-к-одному таблица PATIENTS преобразована в две таблицы: PATIENTS_REG и PATIENTS_KART (на рисунке показаны только основные атрибуты таблиц). Также необходимо принимать во внимание, что БД использующие такие отношения не могут быть полностью нормализованы. 
Отношение один-ко-многим можно без преувеличения назвать основным типом отношений использующемся при проектировании современных БД, так как позволяет представлять иерархические структуры данных. Под данным отношение понимается такое отношение, когда одной записи в родительской таблице соответствуют записи в дочерней таблице (причем число соответствующих записей выражается рядом натуральных чисел 0,1,2,:N и т.п.) (рис.12). Отношения один-ко-многим могут быть жесткими и нежесткими. Для жестких отношений должно выполнять требование, что каждой записи в родительской таблице должна соответствовать хотя бы одна запись в дочерней таблице. 
Отношение многие-ко-многим представляет собой отношение при котором записям родительской таблицы соответствуют записи дочерней таблицы, а ряду записей дочерней таблицы соответствуют записи в родительской таблицы (рис.13). Использование такого типа отношений крайне ограничено, не только из-за того, что некоторые БД его вообще не поддерживают на уровне индексов и ссылочной целостности, но и потому, что практически любое отношение многие-ко-многим может быть заменено одним или более отношением один-ко-многим (посмотрите на пример на рис.13. и так не когда не делайте). 
Другим важным типом отношений - является рекурсивное отношение, т.е. такое отношение которое описывает связи между записями внутри одной таблицы БД, т.е. оно связывает объектное множество с ним самим. Пример рекурсивных отношений показан на рис.14., который иллюстрирует, что доктора Петров А.А. и Васин Н.Н. находятся в зависимости от доктора Сидорова В.Н.. В зависимости от функционального назначения этого отношения оно может иллюстрировать, например, что они являются пациентами доктора Сидорова В.Н., или Сидорова В.Н. является по отношению к ним начальником и т.п. Данный тип отношений позволят реализовать древовидную структуру функциональных отношений, например, структуру организации. 
Учитывая требования ссылочной целостности и нормализации на основе применения рассмотренных выше типов отношений осуществляется преобразование функциональной модели бизнес - процессов и реаляционную модель. Итогом этапа является диаграмма ""Сущность-связь"" (часто называемая CASE диаграмма, ER-диаграама, рис.10). 

Замечания 
Например: 
1)Что такое традиционная база данных ?
Бывают сетевые, иерархические и реляционные БД. Последние, в свою очередь делятся на СУБД для решения задач оперативного управления транзакциями (OLTP) и системы принятия решений (DSS).
Почему ""традиционная база данных""- это база в разделямых файлах? 2) ""Ведь в реляционной безе данных проблемы синхронизации данных не возникает вовсе"" - очень опасно так говорить. Если USER читает не с начала,- то он может спутать это с синхронизацией транзакций,- а это проблема ключевая в рел-ых СУБД.
3)Подсистемы RDBMS очень схожи с соответствующими подсистемами ОС и сильно
интегрированы с предоставляемыми базовой ОС сервисными функциями - я бы так
не говорил.
4) , и администратор базы данных должен будет восстанавливать часть или всю
БД, используя файлы резервных копий (если их сделали!) - кого-копии или
администраторов, когда они не делают копии?
5)SYS или SYSTEM, с парролем: master или manager - а также Amum13:). (на
самом деле - CHANGE_ON_INSTALL и MANAGER)
Что касаемо, сосбтвенно, описания конкретно Oracle, - то вроде ничего
странного я там не видел.

2.1.1.3.3 Преобразование функциональной модели в реляционную.
В разделе 1.3. нами были рассмотрены основные этапы разработки автоматизированной информационной системы, в разделе 1.3.1 мы разработали функциональную модель АИС, теперь, после того как мы рассмотрели основные оложения терии баз данных, пришло время заняться непосредственно формализацией выделенных бизнес-процессов, операций и т.п. Результатом первого этапа проектирования АИС является функциональная модель системы содержащая множество объектов (процессов, операций), их атрибутов. 
Объектное множество с атрибутами может быть преобразовано в реляционную таблицу с именем объектного множества в качестве имени таблицы и атрибутами объектного множества в качестве атрибутов таблицы. Если некоторый набор этих атрибутов может быть использован в качестве ключа таблицы, то он выбирается ключом таблицы. В противном случае мы добавляем к таблице атрибут, значения которого будут однозначно определять объекты-элементы исходного объектного множества, и который, таким образом, может служить ключом таблицы. 

Преобразование отношений 
Поля таблиц могут находиться между собой в обном из следующих отношений: один-к-одному, один-ко-многим, многие-ко-многим и рекурсивных, определения которых представлены в табл.1. Прежде чем рассмотреть реализацию и преобразование отношений более подробно, обсудим реторический вопрос о правилах именования таблиц и столбцов. Как мы уже ранее отмечали, что практически любая АИС имеет модульную структуру и соответствено, в каждый модель входит определенное число таблиц. Пусть имеется модуль ""Операционный День"", условно назовем его OPDAY, тогда удобно, что все таблицы данного модуля наименовались следующим образовам OPDAY_CUSTOMERS (ТАБЛИЦА КЛИЕНТОВ), OPDAY_ACCOUNT (таблица счетов) и т.п. При наменовании столбцов таблицы желательно придерживаться следующего подхода: <краткое наименование таблицы>_<наименование столбца>. Например, для таблицы OPDAY_CUSTOMERS наименование столбцов удобно реализовать следующим образом CUST_NNN (порядковый номер записи), CUST_FIO (фио клиента), CUST_ACCOUNT_NNN (ссылка на таблицу счетов) и т.п. Практически в каждой организации, занимающейся разработкой АИС существуют свои нормы к наименованию модулей, таблиц, столбцов и объектов базы данных, однако общие принципы во многом схожи с приведенным в данных примерах. Теперь рассмотрим основные принципы преобразования отношений: 

Отношение один-к-одному. 
Рассмотрим пример установки отношений клиентов и счетов в АБС (см. рис.6). 
Отношение ИМЕЕТ ТЕКУЩИЙ СЧЕТ представляет собой связь один-к-одному. Это означает, что клиент имеет не более одного текущего счета и каждым текущим счетом пользуется только один клиент. Если мы решим, что ключами являются №-КЛИЕНТА для CUSTOMER (КЛИЕНТ) и №-ТЕКУЩЕГО-СЧЕТА для ACCOUNT_NUMBER (ТЕКУЩИЙ СЧЕТ), то мы получим две реляционные таблицы, каждая из которых состоит из одного столбца. 
CUSTOMER (CUST_NNN) 
ACCOUNT (ACCOUNT_NUMBER) 
Для того чтобы показать связь между этими двумя таблицами, мы должны включить ссылку на ACCOUNT_NUMBER в таблицу CUSTOMER и и ссылку на СUST_NNN в таблицу ACCOUNT. Каждый из этих столбцов будет внешним ключом, указывающим на другую таблицу. 
CUSTOMER (CUST_NNN, CUST_ACCOUNT_NUMBER ) 
Внешний ключ: CUST_ACCOUNT_NUMBER ссылается на ACCOUNT_NUMBER. 
ACCOUNT (ACCOUNT_NUMBER, ACCOUNT_CUST_NNN) 
Внешний ключ: ACCOUNT_CUST_NNN ссылается на CUST_NNN. 
Резюме: отношение один-к-одному преобразуется путем помещения одного из объектных множеств в качестве атрибута в таблицу второго объектного множества. Его выбор определяется потребностями конкретного приложения. Во многих случаях оба варианта приемлемы. 

Отношение один-ко-многим. 
Предположим, что отношение ИМЕЕТ-ТЕКУЩИЙ-СЧЕТ имеет мощность ""много"" со стороны ACCOUNT. 
Это означает, что у клиента может быть несколько текущих счетов, но каждым текущим счетом по-прежнему пользуется только один клиент. Таким образом, в любом отношении один-ко-многим в. таблицу, описывающую объект, мощность со стороны которого равна ""многим"", включается столбец, являющийся внешним ключом, указывающим на другой объект. 

Отношение многие-ко-многим. 
Отношение ИМЕЕТ-ТЕКУЩИЙ-СЧЕТ имеет мощность многие-ко-многим. 
Таким образом, мы предполагаем, что у клиента может быть несколько текущих счетов, и что каждым текущим счетом могут пользоваться несколько клиентов. Для того чтобы преобразовать отношение многие-ко-многим целесообразно создать таблицу пересечения, представляющую элементы двух других таблиц, находящихся в отношении многие-ко-многим. 

Рекурсивные отношения 
 Объектное множество WORKER(РАБОЧИЙ), дважды встречающееся на диаграмме, и это одно и то же объектное множество в обоих случаях. Обе копии объектного множества WORKER(РАБОЧИЙ) имеют одни и те же атрибуты. В этой модели два экземпляра объектного множества WORKER(РАБОЧИЙ) использованы для удобства, чтобы показать отношение SUPERVISES(КОНТРОЛИРУЕТ), существующее между объектами WORKER(РАБОЧИЙ) и WORKER(РАБОЧИЙ). Это отношение называется рекурсивным, поскольку оно связывает объектное множество с ним самим. В данном случае отношение мощности один-ко-многим означает, что одному работнику подчиняются несколько других работников. 
WORKER (WORKER-ID, NAME, HOURLY-RATE, WORKER-ID) 
Чтобы преобразовать объектное множество WORKER вместе с его атрибутами и отношением SUPERVISES в реляционную таблицу нужно изменить имя второго атрибута WORKER-ID на имя, соответствующее отношению SUPERVISES, которое оно представляет. SUPV-ID. 
WORKER (WORKER-ID, NAME, HOURLY-RАТЕ, SUPV-ID) 
Внешний ключ: SUPV-ID ссылается на WORKER 
SUPV-ID - это рекурсивный внешний ключ, поскольку он ссылается на WORKER-ID, то есть ключ своей собственной таблицы. Таким образом, в результате преобразования рекурсивных отношений появляются рекурсивные внешние ключи. 
Функциональные зависимости, определенные для реляционной модели, являются атрибутами отношения один-к-одному или один-ко-многим. 
Описанный процесс преобразования каждой из этих конструкций в атрибуты реляционных таблиц гарантирует, что они будут зависеть только от ключевых атрибутов. Таким образом, каждая полученная реляционная таблица будет иметь ЗНФ. Многозначные атрибуты реляционной модели встречаются только в отношениях многие-ко-многим. Поскольку они преобразуются в реляционные таблицы, обладающие составными ключами из ключевых атрибутов отдельных объектных множеств, то они гарантированно имеют 4НФ. 

2.1.2. Понятие языка определения данных (ЯОД - DBTG)
Язык - средство, при помощи которого определяется структура данных или схема, а также происходит запоминание данных и манипуляция ими. Язык, которым определяется схема, называется языком определения данных (ЯОД),а язык, используемый для запоминания данных и манипуляции ими, называется языком манипуляции данными (ЯМД). 
Процедура применения ЯОД и определения схемы такова: 
Создается концептуальная модель данных. 
Концептуальная модель данных преобразуется в диаграмму сетевой структуры данных. 
Проверяется, существуют ли между типами записей отношения один-ко-многим. Они могут быть непосредственно реализованы в виде наборов DBTG. 
Если есть отношения мощности многие-ко-многим, то каждое из них преобразуется в два набора путем создания записи связи. 
Если есть n-арные отношения, то они преобразуются в бинарные отношения. 
Применяется ЯОД для реализации схемы.
Схема состоит из следующих частей: 
Раздел схемы. Раздел схемы DBTG, задающий имя схемы. 
Раздел записей. Раздел схемы DBTG, определяющий каждую запись: ее элементы данных и ее адрес. 
Раздел наборов. Раздел схемы DBTG, определяющий наборы, включая типы записей владельцев и членов.
Подсхемы - это в основном, подмножества схемы. В подсхеме могут быть сгруппированы элементы данных, которые не были сгруппированы в схеме; записи и наборы могут быть переименованы и порядок описаний может быть изменен. 
Принятого стандарта DBTG для подсхемы не существует; однако, обычно используются следующие отделы: 
Отдел заголовка, позволяющий присвоить имя подсхеме и указать связанную с ней схему. 
Отдел преобразования, в котором при желании производится замена имен из схемы на нужные в подсхеме. 
Структурный отдел, в котором задается, какие записи, элементы данных и наборы из схемы должны присутствовать в подсхеме. Этот отдел состоит из разделов записей и наборов. 
Раздел записей подсхемы. Раздел структурного отдела, в котором задаются записи, элементы данных и типы данных подсхемы. 
Раздел наборов подсхемы. Раздел структурного отдела, в котором задаются наборы, которые должны быть включены в подсхему. 
Подсхема позволяет пользователю строить из предопределенной схемы схему, соответствующую нуждам конкретного приложения. ",1
6,Характеристики СУБД.docx,"2.2.2 Сравнительные характеристики SQL СУБД.
Как было отмечено выше, выбор конкретной архитектуры построения информационной системы включает два основных компонента: выбор серверной платформы (выбор серверной ОС и СУБД) и выбор платформ для клиентских рабочих мест. В данном разделе более подробно остановимся на особенностях выбора конкретной СУБД. При выборе базы данных очень важно выбрать базу данных, которая в наибольшей степени соответствуют предъявляемым к информационной системе требованиям, т.е. необходимо определиться какая модель автоматизации реализуется (автоматизация документооборота или бизнес - процессов). В первую очередь при выборе СУБД необходимо принимать во внимание следующие факторы: 
максимальное число пользователей одновременно обращающихся к базе; 
характеристики клиентского ПО; 
аппаратные компоненты сервера; 
серверную операционную систему; 
уровень квалификации персонала. 
На сегодня известно большое число различных серверов баз данных SQL. Остановимся более подробнее на следующих четырех ведущих серверных СУБД - Oracle8i, IBM DB2, Microsoft SQL Server и Informix - и сравним их в работе на каждом из основных этапов функционирования: 
конфигурирование системы, 
мониторинг, 
настройка, 
обработка запросов, 
разработка серверных и клиентских модулей. 
Данный анализ проведем с учетом того, что число клиентских мест составляет от 50 до 500, а управление СУБД должно быть максимально эффективно. Исследования проводились на серверной платформе на базе Pentium II с 128 Мбайт ОЗУ, укомплектованном 13-Гбайт диском с интерфейсом EIDE в конфигурации RAID уровня 0 (конечно лучше было бы использовать HDD с интерфейсом SCSI). Управление системами было возложено на ОС Windows NT Server 4.0. и Linux. 

Oracle8i. 
Пакет Oracle8i, наделенный самым развитым набором функций для работы с языком Java и доступа к данным через Интернет, системой оптимизации одновременного доступа. Единственным недостатком данной СУБД является сложность администрирования, однако все затраты на ее внедрение и освоение в последствии окупятся эффективной и надежной работой. В нашей стране на протяжении уже многих лет целым рядом специалистов культивируется негативное отношение к СУБД Oracle, как к дорогой и сложной СУБД. Оба эти тезиса являются спорными. Во-первых, уровень сложности понятие относительное. При использовании СУБД Oracle на платформе NT, она потребует практически тех же усилий, что и при использовании MS SQL. В случае же работы на UNIX-платформе, можно с уверенностью отметить, что для профессиональных юниксоидов среда Oracle является простой, понятной и доступной. Что касается дороговизны, то и тут наметились положительные сдвиги. Кроме того, что компания Oracle предлагает ряд различных масштабируемых решений в зависимости от числа обслуживаемых клиентов, она также следуя общемировым тенденциям разработала версию своей популярнейшей СУБД под LINUX и выложила ее на своем WEB сервере (www.oracle.com) для свободного использования. Среди основных свойств СУБД Oracle следует отметить такие, как: 
Высочайшая надежность. 
Возможность разбиения крупных баз данных на разделы (large-database partition), что дает возможность эффективно управлять гигантскими гигабайтными базами; 
Наличие универсальных средств защиты информации; 
Эффективные методы максимального повышения скорости обработки запросов; 
Индексация по битовому отображению; 
Свободные таблицы (в других СУБД все таблицы заполняются сразу при создании); 
Распараллеливание операций в запросе. 
Наличие широкого спектра средств разработки, мониторинга и администрирования. 
Ориентация на интернет технологии.
Решения, не уступающие разработкам Oracle можно найти только в DB2 фирмы IBM. Ориентация на интернет технологии - основной девиз современных продуктов Oracle. В этой связи можно отметить пакеты interMedia, обеспечивающее обработку данных в мультимедийных форматах, и Jserver, встроенное средство для работы с языком Java, которое объединяет возможности языка Java с возможностями реляционных баз данных (возможность составлять на языке Java не только внутренние программы для баз данных (хранимые процедуры и триггеры), но и разрабатывать компоненты Enterprise JavaBeans и даже запустить их на сервере). Компоненты Enterprise JavaBeans представляют собой базовые модули из которых складываются Интернет-приложения на языке Java. 
Фирма Oracle придерживается принципа, что всеми важными функциями необходимо управлять из единого центра, поэтому предлагаемый модуль interMedia предоставляет в распоряжение пользователей самые передовые возможности для работы с мультимедийными объектами: 
Очень развитые средства для обработки аудио клипов; 
Неподвижных изображений; 
Видеофрагментов; 
Географических данных (с целым набором функций связанных с определением местонахождения входящих в состав модуля Locator ). 
В Oracle8i реализуются лучшие на сегодняшний день средства для объектно-ориентированного конструирования баз данных, в том числе табличные структуры, допускающие наследование свойств и методов других табличных объектов БД, что позволят избежать ошибок при построении БД и облегчает их обслуживание. 
Также необходимо отметить, что разработанная фирмой Oracle система оптимизации одновременного доступа (multiversioning concurrency) является одной из важнейших характеристик архитектуры Oracle (подобная функция есть лишь в СУБД InterBase компании InterBase компании Inprise). Данная функция позволяет исключить ситуацию, когда одному пользователю приходится ждать, пока другой завершит изменения в содержимое баз данных (т.е. в Oracle отсутствуют блокировки на чтение). Эта функция позволяет СУБД Oracle8i выполнять за секунду больше транзакций в расчете на одного пользователя, чем любая другая база данных. По уровню производительности при работе в WEB среде под LINUX Oracle занимает почетное второе место после СУБД MySQL, при этом значительно превосходя все другие СУБД по надежности и безопасности. 

СУБД Microsoft SQL Server 
Важнейшие характеристики данной СУБД - это: 
простота администрирования, 
возможность подключения к Web, 
быстродействие и функциональные возможности механизма сервера СУБД, 
наличие средств удаленного доступа, 
В комплект средств административного управления данной СУБД входит целый набор специальных мастеров и средств автоматической настройки параметров конфигурации. Также данная БД оснащена замечательными средствами тиражирования, позволяющими синхронизировать данные ПК с информацией БД и наоборот. Входящий в комплект поставки сервер OLAP дает возможность сохранять и анализировать все имеющиеся у пользователя данные. В принципе данная СУБД представляет собой современную полнофункциональную база данных, которая идеально подходит для малых и средних организаций. Необходимо заметить, что SQL Server уступает другим рассматриваемым СУБД по двум важным показателям: программируемость и средства работы. При разработке клиентских БД приложений на основе языков Java, HTML часто возникает проблема недостаточности программных средств SQL Server и пользоваться этой СУБД будет труднее, чем системами DB2, Informix, Oracle или Sybase. Общемировой тенденцией в XXI веке стал практически повсеместный переход на платформу LINUX, а SQL Server функционирует только в среде Windows. Поэтому использование SQL Server целесообразно, по нашему мнению, только если для доступа к содержимому БД используется исключительно стандарт ODBC, в противном случае лучше использовать другие СУБД. 

IBM DB2 
СУБД IBM DB2 - результат почти 30-х опытно-конструкторских и исследовательских работ фирмы IBM. Последнюю на сегодня версию данной СУБД (6.х) отличает один из наиболее продуманных наборов средств управления и оптимизации и механизм БД, допускающий наращивание от портативного ПК с Windows 95 до целого кластера больших ЭВМ S/390, работающих под управлением OS/390. 
Пакет DB2 выпускается в двух редакциях: DB2 Workgroup и DB2 Enterprise Edition. В данной СУБД реализованы все известные по предшествующим версиям DB2 новаторские технологии механизма БД, такие, как распараллеливание обработки запроса, полный набор средств тиражирования, сводные таблицы запросов для повышения производительности БД, возможности объектно-ориентированного конструирования баз данных и средства языка Java. К этому надо добавить, что система DB2 оснащена полым набором мультимедиа-расширений, позволяющих сохранять текст, звук и видео- фрагменты, изображения и географические данные и манипулировать ими. Можно говорить, что по возможностям масштабирования разработанная специалистами IBM технология кластеризации баз данных не имеет аналогов. Эти расширения существенно облегчают процесс разработки приложений для Web, а так же программ, содержащих фотоизображения и объемные текстовые отчеты. Система DB2 вполне конкурентоспособна и в качестве платформы для разработки приложжений т.к существует средство Stored Procedure Builder - автоматически преобразовывающее оператор SQL в соответствующий класс Java и включающее его в структуру базы данных. В версии DB2 6.1 значительно улучшена функциональная совместимость с другими СУБД: пакет позволяет использовать разработанную Microsoft спецификацию OLE DB, новый стандарт доступа к базам данных. Средства административного управления СУБД DB2, которые в новой версии переписаны на Java и могут быть получены из Web, заслуживают самой высокой оценки. 
Основными недостатками данной СУБД является относительная сложность администрирования и отсутствие (пока) реализаций под популярные серверные ОС, например LINUX. 
В данной СУБД благодаря Index Smart-Guide возможно осуществлять настройку, формируя оптимальные индексы для заданного числа обращений, характеризующего типичную нагрузку на БД. DB2- единственный пакет позволяющий генерировать сводные таблицы, что значительно эффективность работы СУБД в качестве хранилищ данных. Сводная таблица - это временная рабочая область, используемая базой данных для хранения ответов на часто поступающие запросы. Ну что ж, можно сказать, что оснащенная новыми функциональными возможностями, а также средствами распараллеливания и возможностями выбора практически любого типа соединения и индексов (кроме разве что растровых индексов), модель DB2 6.1 превращается в самую недорогую из высокопроизводительных систем. Средства административного управления этой СУБД вполне соответствуют уровню решаемых задач, кроме того, она предоставляет исключительно широкие возможности для работы с мультимедиа-данными и для программирования (чего явно недостает системе Microsoft SQL Server). 

СУБД от Informix. 
В последнее время наметился переход от реляционных СУБД к объектно-ориентированным (что явно прослеживается на примере Oracle). Informix также следуя данной концепции анонсировала новое решение СУБД Centaur базирующуюся на реляционной БД Informix Dynamic Server 7.3 и объектно-реляционной БД Informix Universal Data Option и сочетающую в себе высокое быстродействие Dynamic Server при работе с данными с универсальностью и мультимедиа функциями Universal Data Option. Данная реализация предназначена для разработки интернет систем. Предположительно данная СУБД будет обладать гибкой средой разработки, обладающей наращиваемостью, соответствующей характерным для Интернета интенсивным нагрузкам, и средствами работы с новыми типами данных, которые с развитием Web стали использоваться повсеместно. Реализованные в новой системе средства Java позволят разработчикам создавать на этом языке хранимые процедуры, пользовательские программы и компоненты DataBlades, которые в Informix называют заказными расширениями базы данных. 
С точки зрения клиентов Inforix, это станет большим шагом вперед, поскольку до настоящего времени при работе с DataBlades они могли пользоваться только языком Си и SPL, внутренним языком фирмы Informix для написания хранимых процедур. Кроме того, пакет Centaur будет оснащен встроенными средствами обработки объектов ActiveX. Это даст возможность, к примеру, создавать хранимые процедуры БД на языке Visual Basic; правда, для этого нужно, чтобы пакет Centaur выполнялся в среде Windows NT. 
Centaur будет представлять собой надстройку Informix Dynamic Server и работать с традиционным для этого пакета форматом БД, так что в распоряжении пользователей останутся все прежние функции, а модернизация системы до уровня новой версии не будет сопряжена с большими сложностями. Кроме того, в пакете Centaur будут сохранены все возможности конструирования и программирования, благодаря которым система Informix Universal Server признана выдающимся техническим достижением. Новая система будет оснащена средствами объектно-ориентированного конструирования баз данных, создания специализированных таблиц и программ индексирования; в ее состав войдет позволит пользователям встраивать в запросы собственные функции и не полагаться исключительно на стандартные средства SQL. 

Выводы. 
Рассмотрев основные характеристики архитектур построения АИС, серверных операционных систем и СУБД в дальнейшем в качестве архитектуры АИС мы выберем архитектуру интернет/интранет, в качестве серверной ОС Linux, в качестве СУБД Oracle 8i. В сводной таблице представлены сравнительные характеристики двух наиболее распространенных на сегодня решений на базе Microsoft SQL Server 7.0 (на NT) и Oracle8i (на Unix, Linux). 
Клиентские места при этом могут функционировать практически на любой платформе, средством доступа клиентов к СУБД является либо CGI (Perl) либо JAVA приложения. При этом к серверной части АИС предъявляются следующие требования: 

2.3. Реляционная модель, как платформа для разработки современных информационных систем на примере интерактивной системы патентного обеспечения технологического проектирования.
И так мы расссмотрели различные подходы к внутренней организации баз данных. И в результате пришли к выводу о необходимости использования реляционной модели, так как она решает одну из основных проблем - внесения изменений в базу данных в процессе ее использования. Ведь в реляционной безе данных проблемы синхронизации данных не возникает вовсе, так как данные хранятся в одном экземпляре. Для большей ясности этого вопроса приведем отличия традиционных и реляционных баз данных. 
Итак, основные черты реляционных баз данных: 
Структура реляционной базы данных определяется хранящимися в них данными и не фиксируется в момент завершения разработки (т.е. является гибкой и масштабируемой). 
Структурам данных можно давать весьма информативные названия. 
Данные хранятся в единственном экземпляре; все опции чтения и модификации данных производятся только с этим экземпляром данных, что качественно облегчает синхронизацию данных между многими приложениями и пользователями. 
Данные хранятся в соответствии с четко определенными и строго соблюдаемыми правилами. 
",1
11,Этапы разработки проекта1.docx,"Этапы разработки проекта: заключительные стадии проектирования, спецификации функций
Обработка иерархии функций 
На этапе анализа была создана иерархия функций, которая дополняется диаграммами потока данных и изменения состояний. Как проще всего проверить, является ли функция в иерархии атомарной? Ответьте на вопрос: имеет ли смысл выполнение только части этой функции. Поскольку мы имеем дело с иерархией, вероятно наличие одной и той же функции в нескольких местах иерархии. Здесь кроется ошибка анализа: аналитик перепутал функцию и механизм.
Хорошо, если при описании функции аналитик укажет в скобках тот объект в ER-модели (сущность и атрибут), о котором идет речь, например «выбрать товары в накладной из списка товаров (ITEMS), хранящихся на складе (STORE)». Если подобных указаний нет, это станет хорошим упражнением для приемки отчетов аналитиков; заодно и убедитесь, что вы правильно понимаете друг друга. Параллельно проверьте, есть ли сущности, которые не используются ни в одной функции, - это поможет сделать матрицу «функции-атрибуты», отражающую факт использования в функциях атрибутов сущностей.
Как правило, не бывает взаимно однозначного отображения функций на модули. Если однозначных соответствий много, то вероятнее всего был выполнен не анализ, а собственно проектирование. Зачастую схожие по выполняемым действиям функции объединяют, даже если у них разный контекст. Некоторые сложные функции разбивают на более простые модули. Некоторые функции преобразуют в ограничения базы данных (constraints, или триггеры и хранимые процедуры). Каких-то общих способов отображения функций на модули не существует. Требуется время, терпение, опыт. Проектировщики часто меняют количество, состав модулей в течение процесса проектирования, и это правило, а не исключение.
Некоторые группы модулей присутствуют в любом проекте:
работа с базой данных: 
обработка кодов возврата СУБД; 
установка соединения с СУБД и его параметры; 
выполнение некурсорного запроса (DDL- и DML-операции); 
выполнение выборки; 
вызов хранимой процедуры и обработка ее ответа; 
операции начала и завершения транзакции; 
функциональные модули: 
модули, реализующие бизнес-процессы; 
модули, изолирующие обработку запросов к базе данных и интерфейсы, предоставляемые пользователю; 
системные модули: 
средства управления приложениями; 
средства обмена данными с внешними системами; 
планировщик пакетных заданий; 
менеджер печати документов; 
модуль резервного копирования; 
модуль архивирования; 
модуль автоматического восстановления при сбоях; 
средства администрирования пользователей системы (регистрация, назначение прав, внешняя аутентификация); 
средства создания нерегламентированных запросов к базе данных. 
Один из приемов построения расширяемых систем состоит в создании независимости двух слоев: обработки запросов и интерфейса, предоставляемого пользователю. Можно специально кодировать каждый запрос данных, например именем функции и номером или как-нибудь иначе. Текст SQL-запроса скрыт от разработчиков интерфейсов; они имеют доступ только к возвращаемому запросом множеству - коду ошибки или выборке. Формат кода ошибки и выборки фиксируется. Это позволяет проектировщикам схемы базы данных изменять как ее, так и сам SQL-запрос, однако эти изменения не отражаются на процессах создания интерфейсов. Аналогичная независимость реализуется для слоя функций, обеспечивающих вызовы интерфейса, предоставляемого СУБД для выполнения запросов. Этот слой функций может использовать вызовы как native-интерфейса СУБД, так и стандартных интерфейсов, например ODBC.
Очень важен слой функций обработки ошибок. При выполнении запросов к базе данных всегда следует предусматривать обработку исключений, например нарушений ограничений целостности. Отдельно требуется предусмотреть обработку конфликтов транзакций и принудительный откат текущей транзакции вследствие разрешения конфликтов типа deadlock. Проектировщики должны хорошо понимать особенности многопользовательской работы, которые реализованы используемой в проекте СУБД. Проектирование потоков транзакций и снижение конфликтов между ними - одна из самых сложных задач проектирования.
Для больших проектов важно наличие функций мониторинга работы приложений. Они служат в том числе и для оценки корректности работы самих приложений, а также для сбора статистики отказов системы и прогнозирования вероятных отказов. Такие функции отслеживают моменты перегрузки системы и автоматически разрешают их, уведомляя администратора о принятом решении. Подобные модули могут быть реализованы в виде локальных агентов, каждый из которых работает на одном сервере, а сами они обмениваются информацией друг с другом и центральной программой управления.

Управление исходным кодом 
Для групповой разработки важны системы контроля исходного кода. Такие системы решают по крайней мере две задачи: хранение всех версий каждого экземпляра исходного кода (версии файлов) и разрешение конфликтов одновременного доступа разработчиков к одному экземпляру исходного кода (слияние исходных текстов, согласованность группы файлов проекта и т.п.)
Контролю подвергается не только собственно код модулей, но и код скриптов генерации схемы базы данных, а также собственно схема базы данных, которая может храниться в виде версий бинарных файлов, экспортированных во внутренний формат СУБД схем баз данных. Дело проектировщиков - предусмотреть наличие таких механизмов разработки, дело прикладных программистов - придерживаться установленных правил групповой разработки. Часто ведущие исполнители проектов не доверяют системам контроля исходного кода сливать правки в исходных текстах автоматически и частично или полностью контролируют этот процесс. Эта перестраховка во многих случаях себя оправдывает.
После того как основной код модуля будет создан и зарегистрирован в системе контроля исходных текстов, каждая правка в нем должна быть помечена датой и именем автора правки. Правки должны сопровождаться ясными комментариями, которые располагаются в начале файла исходного кода. Также в начале исходного кода (в комментариях) описывается: для чего данный файл исходного кода создан, основные его функции, к какой части информационной системы он относится, кто автор. Формат комментария к правке может быть таким
10.01.2000 Ivanov: authorization bug fixed (found by Petrov)
Это делается для того, чтобы через некоторое время можно было понять, кто и зачем внес данную правку. Также это помогает корректировать слияние исходного кода, если система контроля обнаружила несовместность правок и не может разрешить ее сама.
Функции, структуры, наиболее важные переменные должны сопровождаться комментариями. Избегайте непонятных названий вида K1, Function10.
Для крупных подсистем следует зафиксировать интерфейс обмена с другими подсистемами - формат данных, передаваемых подсистеме и получаемых из нее, а также формат вызовов функций и методов подсистемы. Это позволит добиться относительной независимости подсистем и снизить влияние изменений кода одной подсистемы на другую. Такой подход облегчает взаимодействие разработчиков разных модулей. Документировать придется только интерфейс обмена, а не весь код модуля целиком. Зачастую разработчику, вызывающему функцию модуля, требуется знать, что нужно передать и как обработать результат, а что происходит внутри - знать не обязательно. Единственное, что его интересует, - это правильная инициализация модуля, правильный прием результатов его работы и правильная выгрузка модуля. Взаимодействие компонентов не должно быть произвольным. Контролировать эти правила создания исходного кода в большинстве случаев приходится вручную.
Следует отметить, что группа разработчиков должна иметь свой выделенный сервер баз данных, и, возможно, не один, а также выделенные рабочие места. Часто эти моменты далеко не очевидны руководству, и оно воспринимает это как совершенно ненужную трату средств. Сервер, обеспечивающий контроль исходного кода, также должен быть выделенным.

Размещение логики обработки 
В отчетах аналитиков часто смешиваются три группы правил: правила для данных, процессов и интерфейса. На этапе проектирования эти правила предстоит выделить.
В правилах для данных формулируются условия, которым всегда должны удовлетворять данные. Такие правила безоговорочны; они могут быть неверными, но в этом случае они безоговорочно неверные. Правила данных определяются в схеме базы данных. Они могут контролироваться приложением только в том случае, когда мощности языка данных не хватает для их поддержки (например, поддержка сложных ограничений check, содержащих агрегатные функции, и т.п.).
Правила для процессов определяют, что должно и что не должно делать приложение, и выводятся из модели функций, переданной аналитиками.
В правилах для интерфейсов устанавливается, что должен видеть конечный пользователь. Такие правила не касаются обработки данных, они выводятся из спецификации пользовательского интерфейса (например, к ним относится внешний вид экранных форм отчетов и документов).
Ниже приведем несколько правил, переданных аналитиками, и классифицируем их. Дело в том, что при проектировании группы правил не должны перемешиваться. Итак:
Только руководитель может санкционировать выплату вознаграждения. 
Это правило только для процессов. В момент разрешения операции приложение должно проверить, есть ли у пользователя привилегии, разрешающие операцию, и нет ли привилегий, запрещающих операцию. Многие проектировщики пытаются реализовать такие правила, как правила данных. Но связь здесь зависит от времени, а не является постоянной (руководитель может быть смещен, подчиненный может стать руководителем, для временных групп работников это процесс постоянный).
Обновление записей о платежах запрещено. 
Это правило для данных. Оно не изменяется во времени. Такое правило можно реализовать с помощью триггера before update, он должен возвращать ошибку вызвавшему приложению. Откат транзакции внутри триггера в этом случае возможен только при отсутствии сложных транзакций, операции которых инициируют вызов данного триггера.
Все коды валют должны раскрываться; рядом с кодом указывается полное название валюты. 
Это правило для интерфейса. На первый взгляд оно разумно, но практика показывает, что в большинстве случаев пользователи оперируют кодами, а не полными названиями валют. В большинстве организаций есть система сокращений, ставших частью языка и понятных всем. Такие сокращения не требуют раскрытия.
Все торговые операции, выполненные в воскресенье, учитываются в бухгалтерской книге за следующий понедельник. 
Подобные правила часто описываются аналитиками. На самом деле здесь два правила в одном, и их надо разделить. Первое гласит о том, что в бухгалтерских книгах не должно быть проводок, сделанных в воскресенье. Это правило данных. Оно может быть реализовано ограничением check. Второе правило - для процессов. Оно объясняет, как откорректировать дату: чтобы дата бухгалтерской проводки была правильной для «воскресенья», требуется прибавить один день. Это позволяет избежать случая, когда в приложении появляется оператор insert с заведомо отвергаемыми данными. Обработку такой ситуации можно предоставить хранимой процедуре, если ее язык достаточно мощный и допустимы вызовы внешних функций (в данном случае проверка дня недели) или имеется встроенная функция обработки календаря. Если же решение в виде хранимой процедуры невозможно, то это преобразование должно выполнить само приложение (вызов библиотечной функции или соответствующая организация объектов - как больше нравится). Другое решение подобной задачи - добавление производного атрибута. Вместо одного атрибута, хранящего дату, получаем два: один хранит реальную дату, второй - откорректированную для «воскресенья»; последний является производным. Это допустимо, если подобная денормализация не влечет за собой много аномалий модификации.
Пособие не должно выплачиваться лицу, если его доход превышает 300 руб. на человека. 
Это правило для процессов. Здесь не говорится о том, какие данные образуют доход, в разные периоды времени источники дохода разные для одного и того же лица, состав семьи также меняется с течением времени.
Точно такие же группы правил могут быть применены и для проектной документации. Эти группы могут отражать естественное разделение разработчиков на тех, кто реализует работу с базой данных, системные модули и интерфейсы пользователя.
Полное описание интерфейсов на этапе проектирования возможно, если требования пользователя достаточно четко определены. На практике реализация интерфейса пользователя является наиболее часто изменяемой частью исходного кода. На этапе проектирования следует описать наиболее общие правила интерфейса, например горячие клавиши, используемые одинаково во всех программах.
Следует отметить, что много проблем в интерфейсах пользователей создают сами проектировщики, если они неправильно выбирают макет и не учитывают разницы поведения системы на макете и на реальных данных. Наиболее частая ошибка проектирования интерфейса - отображение данных в форме для редактирования и блокирование их средствами СУБД до тех пор, пока пользователь не нажмет кнопку OK. Еще одна распространенная ошибка проектирования интерфейса - обработка длительных процессов, когда пользователь должен ждать ответа на запрос. Большинство проектировщиков не предусматривают единого вызова функции- обработчика события ожидания ответа. На макете запрос может проходить мгновенно, а в случае реальных данных это может составлять несколько минут. Если обработка ожидания ответа не предусмотрена (хотя бы в виде элементарного сообщения «подождите, идет обработка данных»), то пользователь думает, что приложение «зависло».
С точки зрения логики расположения правил они должны быть реализованы так:
правила интерфейса реализуются во внешней системе, например в Delphi, генераторах экранных форм и отчетов, поставляемых в составе средств разработки СУБД; 
правила для процессов могут быть реализованы как процедуры, вызываемые из внешней системы; 
правила данных следует реализовать средствами СУБД с помощью ограничений целостности. 
Следует отметить, что место правил интерфейса и правил данных всегда задано точно. Место правил процессов не всегда определено точно. Часть из них может быть реализована как вызовы утилит, поставляемых с СУБД или созданных другими группами разработчиков; часть может храниться в схеме как процедуры или пакеты; другие могут быть реализованы как библиотечные функции собственно информационной системы. Но любая процедура, реализующая правило процесса, должна быть отделена от кода, реализующего правила интерфейса, и не зависеть от него.
Вопросы проверки корректности ввода информации часто решаются проектировщиками неоднозначно. Как правило, пользователь настаивает на более детальном анализе ошибки ввода данных. Если вводимые значения выбираются из справочника, то здесь проблем меньше. Если они вводятся вручную, то возникает проблема предотвращения попадания в систему некорректных данных, например элементарных опечаток. Выбор значений из справочника - это форма реализации ограничений на уровне интерфейса. Проектировщики часто выбирают - делать проверку на уровне интерфейса или на уровне ограничений базы данных. Лучше реализовать оба правила: и интерфейсное - поскольку пользователь требует немедленной обратной связи, и правило данных - как дополнительную проверку корректности.
При проектировании интерфейсов старайтесь придерживаться стандартов де-факто. Ими могут быть приложения, часто используемые пользователем, например вызов контекстной подсказки по F1 и т.п.
При работе нескольких пользователей с одними и теми же объектами данных проектировщикам приходится решать задачи совместного редактирования документов, например оформление заказа. Клиент не всегда точно определяет список товаров и их количество, а потому оформление заказа может требовать некоторого времени (и оно больше, чем чистое время заполнения экранной формы оператором). Проектировщики допускают распространенную ошибку решения интерфейса пользователя для таких задач: в экранной форме отображается ввод позиций заказа, которые выбираются из справочников; выбранные данные блокируются до тех пор, пока оператор не нажмет OK. Это приводит к возникновению феномена «конвоя». А именно - несколько операторов после нажатия OK начинают ждать разрешения конфликтов средствами СУБД, в то время как большое количество конфликтов спровоцировал именно интерфейс. В самом деле время редактирования формы намного превосходит время обмена данными приложения пользователя и СУБД, соединение с СУБД простаивает до 99% времени - то есть ждет запроса, тогда как блокировка данных остается. Чем дольше время блокировки, тем больше вероятность конфликта. Здесь у некоторых проектировщиков возникает идея обвинить СУБД во всех грехах: она же блокирует, а мы вроде и ни при чем. Предположим, что СУБД не блокирует редактируемые данные, и они вступают в силу только по нажатию кнопки OK. Это, конечно, хорошо, но в течение времени редактирования другой пользователь мог изменить те же данные и зафиксировать свои изменения. СУБД транзакцию второго пользователя уже не пропустит - это типично для стратегии оптимистических блокировок. Возникает вопрос: если и так плохо, и так нехорошо, что делать? Проблема - в неверном взаимодействии интерфейса и обработки данных. Транзакция в любой СУБД начинается или явно, или по факту первого запроса данных. При описанном решении интерфейса транзакция оказывается слишком длинной. Ведь когда идет формирование списка заказываемых товаров, выполняются запросы к данным и транзакция уже начата. Можно принудительно разорвать операцию формирования заказа и его подтверждения. Здесь используют стандартные методы определения зон риска: так, в случае заказа товара это вход в зону потенциальной нехватки (например, заказали 90% товара, имеющегося на складе, - это следует отметить как сигнал потенциального риска продажи товара два раза). По кнопке OK выполняется подтверждение ранее зарезервированного товара и в результате вероятность конфликта снижается.
Аналогично решается задача одновременного редактирования двумя пользователями одного документа. Изменения пользователя (которые он сделал в экранной форме) запоминаются в специальном буфере данных; то, что он первоначально получил для редактирования, также запоминается в буфере начальных данных. По нажатию кнопки OK выполняется попытка зафиксировать изменения пользователя. На уровне правил данных (разрешение конфликтов транзакций) выполняется проверка отсутствия зафиксированных другим пользователем изменений. Если данные были кем-то изменены во время редактирования, то пользователь получает предупреждение об этом. Ему может быть предложено просмотреть изменения, которые находятся на данный момент в базе данных, и в зависимости от этого сохранить свои изменения поверх или отказаться от них. Естественно, это не требует от пользователя повторного заполнения всей формы (что очень раздражает пользователей).

Трехуровневая архитектура 
Приложение разделяется на три части: 1) управление интерфейсом пользователя; 2) выполнение правил обработки данных; 3) выполнение функций сохранения и выборки данных.
Данная архитектура позволяет четко разделить правила процессов и правила данных. Правила процессов реализуются исключительно на втором уровне. Этот уровень может представлять собой выделенный сервер приложений, который имеет право доступа к базе данных, а приложение пользователя обращается к базе данных только опосредовано. Одно из преимуществ такой архитектуры - использование нескольких СУБД в качестве хранилища данных. Все три части комплекса имеют фиксированные интерфейсы обмена данными, следовательно, имеет место изолированность уровня интерфейса пользователя от уровня базы данных за счет наличия ПО промежуточного слоя.
Современные СУБД позволяют реализовывать ПО промежуточного слоя как посредством мониторов транзакций (CICS, Enchina, Tuxedo и др.), так и на самом сервере баз данных в виде хранимых процедур и пакетов (частично или полностью). В этом случае код, реализующий интерфейс пользователя, не содержит вызовов предложений SQL, они «спрятаны» в код пакета или хранимой процедуры (здесь можно говорить об инкапсуляции, что некоторые авторы и делают). В таких случаях для решения пользовательского интерфейса применяют рекомендуемые, а не обязательные проверки правил. Данные при этом блокируются (они вообще не связаны с хранилищем данных) до тех пор, пока пользователь не захочет зафиксировать свои изменения (кнопка OK), а собственно изменения передаются атомарной транзакцией. Это позволяет эффективно использовать мониторы транзакций. Подобные решения рекомендованы для OLTP.

Метрики генерации модулей 
Одна из задач проектирования кода - оценить, сколько времени на это нужно и какие средства будут при этом использоваться.
В большинстве проектов оценку времени разработки производят дважды:
на основе аналитической документации. Здесь привлекаются разработчики, но не на уровне: «За сколько сделаешь? - А за сколько надо?». Следует учесть не только средства разработки, но и аппаратное обеспечение. Это наиболее оптимистические оценки; хорошо, если они будут превышены только на 50%; 
после выполнения большей части проектирования схемы данных и модулей. Этот набор оценок предполагает более глубокую детализацию. 
Если вы ни разу таких оценок не делали и вам непонятно, с чего начать, то разделите модули по группам: генерируется автоматически, простой, средней сложности, сложный, очень сложный.
Метрика - это таблица плановой трудоемкости (столько-то дней и столько-то человек требуется). В метрике учитываются как минимум три составляющие: проектирование модуля, генерация его кода, тестирование модуля (в которое входит и тестирование связей модулей). В метрику лучше включить больше условий - это станет своеобразной страховкой от отставания от графика. Следует учитывать как минимум следующие факторы:
стабильность модели данных и степень ее изменения в течение разработки; 
стабильность модели функций и степень ее изменения в течение разработки; 
уровень квалификации персонала; 
пригодность выбранных средств разработки; 
использование автоматических генераторов кода (например, экранных форм и отчетов); 
соответствие среды требованиям средств разработки (станции разработчиков, серверы, сеть, операционные системы и т.п.). 
Следует с очень большой осторожностью относиться к модулям, которые отмечены как сложные и для которых выбрано относительно низкофункциональное средство. Учтите также зависимости модулей и возможности накопления отставания от графика.

Мегамодули 
Это весьма распространенная особенность интерактивных систем. Создаются сложнейшие экранные формы с десятками страниц, один DML-запрос инициирует пару десятков триггеров и т.д. Задачу уменьшения сложности модулей сложно решить, если используются средства ускоренной разработки приложений. Решите, что вам нужно в этом модуле, а что - нет. И вряд ли мегамодуль - это то, о чем мечтал пользователь. Он вряд ли обрадуется, если будет листать страницы формы и уже на пятой забудет, что было в начале.
Мегамодули появляются и при пакетной обработке - они строят пакетные задания и отправляют их на обработку. Тестировать такие модули очень сложно. Возможно, что более простым решением окажется построение управляющей структуры для построения пакета.
Мегамодули в отчетах выглядят жутковато. Это происходит, когда проектировщики пытаются в одном отчете соединить несколько похожих отчетов. Пользователю совершенно все равно, каким количеством модулей обслуживается его отчет: чем меньше лишней информации он будет содержать, тем лучше.
В оперативных приложениях главная причина появления мегамодуля состоит в том, что аналитики указывают множество ненужных ограничений данных - например требования наличия в базе информации о покупателе только в том случае, если от его имени выполнен хотя бы один заказ товара. При обработке заказа это требование порождает проверку: «новый это покупатель или уже зарегистрированный в системе, и если новый, то когда его регистрировать». Можно разрешить покупателям «существовать» независимо от заказов, а если вам хочется, чтобы покупатели непременно были жестко связаны с заказами, - введите супертип «потенциальный клиент», и если такой клиент делает хотя бы один заказ, то он становится покупателем. Таким образом, вызовы двух экранных форм станут уже независимыми от реализации транзакций в базе данных.

Макеты 
При проектировании всегда возникает вопрос, стоит ли тратить драгоценное время на создание макетов. Это элементы (большие или маленькие) реализации реальных задач; они служат для демонстрации потенциальных функциональных возможностей, для изучения мнения пользователей. Макет - это средства представления идей в визуальной форме, поскольку, как говорят, лучше один раз увидеть.
Сколько функций выбрать для макетирования и каких, зависит от количества времени на выполнение этих работ и количества людей, которых можно к этому привлечь. Макет - это своего рода витрина для пользователей. Это означает, что большинство функций реализуют правила интерфейса. Успешная демонстрация может обеспечить заключение контракта на разработку, но есть и другая сторона вопроса: проследите, чтобы пользователь не принял внешнюю оболочку за готовую программу и не надеялся получить готовую систему через пару недель.
Другое назначение макетов - проверить проектные решения. Для этого годятся выявленные на этапе анализа критические участки системы. Хорошими вариантами будут несколько сложных отчетов; часть OLTP, часть OLAP. Это позволит привлечь к процессу проектирования группы тестеров, для того чтобы они проверили производительность системы.

Описание 
Для того чтобы разработчики могли правильно сгенерировать модуль, его техническая спецификация должна быть четкой и достаточно подробной.
Описание экранных форм и отчетов должно содержать:
описание назначения формы (что делает); 
данные навигации (откуда вызвана, что может вызвать сама); 
формат вызова формы; 
список входных параметров и параметров по умолчанию; 
список выходных параметров и правила их обработки; 
описание обработки (события внутри модуля и их обработка); 
список ошибок, которые генерируются в процессе обработки формы и реакция на них; 
ограничения доступа к форме (каковы привилегии, разрешающие действия над формой и ее элементами, каковы привилегии, запрещающие эти действия). 
Описание пакетных процессов должно содержать:
описание функции, выполняемой пакетом; 
данные навигации (откуда вызван пакет, что может вызвать сам); 
формат вызова пакета; 
список входных параметров и параметров по умолчанию; 
список выходных параметров и правила их обработки; 
описание обработки (события внутри пакета и их обработка); 
список ошибок, которые генерируются в процессе обработки пакета и реакция на них; 
восстановление (обработка возникновения исключения в середине обработки пакета и реакция на него); 
вероятные блокировки (потенциальные конфликты и обработка ожидания); 
несовместимость с другими пакетными заданиями, отчетами и т.п. (эта информация для планировщика задач); 
регистрацию и аудит; 
ожидаемое состояние базы данных после выполнения пакета и проверку целостности данных; 
ограничения доступа (каковы привилегии, разрешающие вызов пакета, каковы привилегии, запрещающие этот вызов). 

Обработка ошибок 
Обработка ошибок - это одна из подсистем, которая часто портит жизнь проектировщикам. Пользователи требуют вразумительных сообщений об ошибках. Им не понравится, если при попытке удалить поставщика информационная система выдаст сообщение вида «SQL0532N a parent row cannot be deleted because the relationship CLIENT_ restricts deletion» вместо того, чтобы сообщить о невозможности удаления поставщика, если имеются факты поставки им товара на склад.
Рекомендуется сделать несколько уровней обработки ошибок. Первый уровень доступен в слое модулей, отвечающих непосредственно за вызовы SQL. Этот слой обрабатывает коды ошибок, передаваемые интерфейсом вызовов СУБД. Известно, что коды ошибок, детектирующие одно и то же нарушение ограничений данных, в разных СУБД разные. Поэтому, если ваше предложение имеет хотя бы вероятность работы с несколькими СУБД, вам придется интерпретировать коды возврата СУБД и построить матрицу соответствия кода возврата СУБД и кода ошибки, используемого в подсистеме обработки ошибок. Никакие модули, кроме интерпретатора кодов, не должны иметь доступа к кодам возврата СУБД. Вся обработка ошибок в информационной системе должна строиться на внутренних кодах возврата. Множество этих кодов может расширяться, но значения кодов изменять нельзя. Требуется проанализировать, в каком формате СУБД возвращает код. Это может быть:
код ошибки, код ошибки операционной системы; 
sqlca.sqlcode, sqlca.sqlstate; 
sqlca.sqlcode, sqlca.sqlstate, код ошибки операционной системы. 
Внутренняя ошибка может состоять из трех компонентов:
sqlcode - собственно код ошибки; 
sqlstate - уточняющий код состояния и классификации ошибки; 
oscode - сопровождающий код ошибки операционной системы. 
Первые два компонента обеспечивают поддержку стандарта, последний позволяет использовать эту же подсистему обработки ошибок для работы всех подсистем. Следует отметить, что некоторые СУБД возвращают код ошибки операционной системы в случае сбоев создания файлов, чтения страниц и т.п. Таким образом, подобная структура может обеспечить достаточную универсальность обработки ошибок. Тип ошибки - ошибка СУБД или ошибка определенного компонента информационной системы - будет контролироваться с помощью кода sqlstate. Как правило, sqlcode - это interger, sqlstate - это char(8) (длина выравнена на 4, что следует делать, например, для RS/6000, SUN SPARC, ALPHA, SGI), oscode - это integer. Например, код -532 интерпретируется в (-906, ’23001’, 0).
Второй слой обработки ошибок - это контекстная интерпретация внутреннего кода возврата. С каждым интерфейсным модулем может быть сопоставлен некоторый набор параметров интерпретации кода возврата. Например, для модуля редактирования списка поставщиков код (-906, ’23001’, 0) соответствует строке сообщения «нельзя удалить поставщика, поскольку есть связанные с ним поставки товара». По контексту этого исключения можно по требованию пользователя показать список поставок данного поставщика.
",1
25,Этапы разработки проекта2.docx,"Этапы разработки проекта: заключительные стадии проектирования, схема базы данных
Заключительные стадии проектирования 
Проектирование процесса тестирования 
Проектирование процесса тестирования, как правило, следует за процессом функционального проектирования и проектирования схемы базы данных. На этом этапе можно использовать сложные схемы тестирования, а можно ограничиться и простыми. Здесь мы приведем некоторые принципы, которых  нужно придерживаться  при проектировании любой информационной системы.
Когда генерация модуля завершена, выполняют автономный тест, который преследует две основные цели:
обнаружение отказов модуля (жестких сбоев); 
соответствие модуля спецификации (наличие всех необходимых функций, отсутствие лишних функций). 
После того как автономный тест прошел успешно, группа сгенерированных модулей проходит тесты связей, которые должны отследить взаимное влияние модулей.
Далее группа модулей тестируется на надежность работы, то есть проходят, во-первых, тесты имитации отказов системы, а во-вторых, тесты наработки на отказ. Первая группа тестов показывает, насколько хорошо система восстанавливается после сбоев программного обеспечения, отказов аппаратного обеспечения. Вторая группа тестов определяет степень устойчивости системы при штатной работе и позволяет оценить время безотказной работы системы. В комплект тестов устойчивости должны входить тесты, имитирующие пиковую нагрузку на систему.
Затем весь комплект модулей проходит системный тест - тест внутренней приемки продукта, показывающий уровень его качества. Сюда входят тесты функциональности и тесты надежности системы.
Последний тест информационной системы - приемо-сдаточные испытания. Такой тест предусматривает показ информационной системы заказчику и должен содержать группу тестов, моделирующих реальные бизнес-процессы, чтобы показать соответствие реализации требованиям заказчика.

Требования к безопасности, доступу, обслуживанию системы 
Каждая информационная система содержит определенные требования к защите от несанкционированного доступа, к регистрации событий системы, аудиту, резервному копированию, восстановлению информации, которые в начале проектирования должны быть формализованы аналитиками. Проектировщики строят стратегию безопасности системы. В частности, ими должны быть определены категории пользователей системы, которые имеют доступ к тем или иным данным посредством соответствующих компонентов. Кроме того, определяются объекты и субъекты защиты. Следует отметить, что стратегия безопасности не ограничивается только ПО - это должен быть целый комплекс мер и правил ведения бизнеса. Нужно четко определить, какой уровень защиты данных необходим для каждого из компонентов информационной системы, и выделить критичные данные, доступ к которым строго ограничен. Пользователи информационной системы регистрируются, поэтому проектируются модули, отвечающие за идентификацию и аутентификацию пользователя. В большинстве СУБД реализована дискреционная защита данных, то есть регламентирован доступ к объектам данных (например, к таблицам, представлениям). Если же требуется ограничение доступа собственно к данным (к отдельным записям в таблице, к отдельным полям записи в таблице и т.п.), то следует реализовать мандатную защиту. Проектировщики должны иметь четкое представление о том, какой уровень защиты той или иной единицы информации является необходимым, а какой достаточным.
Вопросы восстановления, хранения резервных копий базы данных, архивов базы данных относятся к мероприятиям поддержки бесперебойного функционирования информационной системы. Необходимо внимательно изучить возможности, предоставляемые СУБД, а затем проанализировать, как следует использовать возможности СУБД для обеспечения требуемого уровня бесперебойной работы системы.

Составление спецификаций 
Результаты проектирования отражаются в документе - функциональной спецификации. Этот документ пишется для заказчика, чтобы получить его санкцию на завершение проектирования и начало разработки, и обычно не содержит большого количества технических деталей. Второй документ - техническая спецификация, являющаяся основным документом для разработчиков моделей и групп тестирования, и здесь описаны детали проекта. Если использовались CASE-средства, то техническая спецификация обязательно содержит ряд отчетов из репозитария.

Полнота проектирования 
Перед началом разработки модулей нужно еще раз проверить полноту проектирования. Один из полезных инструментов - матрица использования таблиц схемы базы данных по модулям.

Переход к реализации 
Итак, начата реализация модулей. Означает ли это, что работа проектировщиков на этом завершена полностью? На практике это далеко не так. Довольно часто разработчик сталкивается с медленно работающими или не реализуемыми в данной схеме запросами. Подобные ситуации инициируют изменение модели данных, а значит, и информационной модели. Однако изменение информационной модели производится не только по этой причине. Хорошему проектировщику необходим практический опыт работы с аппаратным и программным обеспечением - вот одна из причин участия проектировщиков в составе групп разработчиков. Нередко ведущие сотрудники групп разработчиков одновременно являются проектировщиками.
Как можно использовать проектировщиков на этапе разработки? Приведем некоторые примеры:
Проектировщик, написавший спецификацию модуля, проводит семинар с разработчиками и демонстрирует необходимые прототипы (семинар предполагает диалог двух сторон). 
Когда модуль передан разработчику, проектировщик может участвовать в его пересмотре, а также выполнять контрольные функции по реализации проектных решений. 
Для крупных проектов характерно поэтапное выполнение работ, так что вполне вероятно, что после завершения реализации группы модулей и сдачи очередного этапа процесс проектирования будет продолжен для новой группы модулей. 
Проектировщики должны обеспечить быстрое реагирование на возможные изменения требований заказчика, поскольку своевременная обработка такой информации является их обязанностью. Кроме того, необходимо и участие системных аналитиков, так как именно они общаются с заказчиком проекта.

Схема базы данных
Схема базы данных содержит описание всех объектов базы данных: пользователей, их привилегий, таблиц, представлений, индексов, кластеров, ограничений, пакетов, хранимых процедур, триггеров и т.п. При этом создаются не только определения этих объектов, но и сами объекты, с которыми потом работают разработчики.

ER-модель и ее отображение на схему данных 
Результат этапа анализа - построение информационной модели. Казалось бы, дело это простое: сущности становятся таблицами, а атрибуты сущностей - столбцами таблиц; ключи становятся первичными ключами, для возможных ключей определяется ограничение unique, внешние ключи становятся декларациями ссылочной целостности. Аналитики, как правило, не вникают в особенности реализации той или иной СУБД, поэтому при проектировании схемы базы данных проектировщик сталкивается с конструкциями в информационной модели, которые не реализуемы или трудно реализуемы в выбранной СУБД.
Приведем несколько примеров ограничений реализации СУБД:
В информационной модели описаны три сущности - A, B, C. Сущности B и C содержат внешние ключи, ссылающиеся на сущность A. В СУБД поддерживается возможность определения внешнего ключа только для первичного ключа, а для возможного ключа определить декларативную ссылочную целостность нельзя. В этом случае отображение ER-модели на физическую модель данных невозможно без изменения информационной модели. 
В информационной модели описан внешний ключ с каскадным удалением и модификацией. В СУБД поддерживаются внешние ключи только для варианта действия no action (то есть каскадные изменения в явном виде не поддерживаются). Реализация ссылочной целостности посредством триггеров ограничена уровнем каскадирования триггеров (например, 32 вызовами триггера). В этом случае потребуется также изменение информационной модели. 
В информационной модели определен атрибут, представляющий собой строку длиной в 500 символов. По этому атрибуту часто осуществляется поиск в информационной системе; объем данных велик. В СУБД можно индексировать строки символов не длиннее чем 128 или 256 символов. Если осуществлять поиск без индекса, то время ответа информационной системы существенно превышает допустимое, вследствие чего придется изменить описание сущности. 
В информационной модели описана сущность A, которая содержит по крайней мере два атрибута BLOB (например, требуется отдельно хранить и звук и изображение). В СУБД невозможно создать таблицу с двумя атрибутами BLOB и в этом случае нужно изменить описание сущности. Из отношения A исключаются два атрибута BLOB, и добавляется один атрибут AK типа integer. Добавляются две дополнительные сущности -  и  . Каждая из них будет содержать один атрибут BLOB и один ключевой атрибут K типа integer, который станет внешним ключом у каждого из новых отношений и будет ссылаться на атрибут AK в отношении A (тип внешнего ключа - on delete cascade, on update cascade). 
Жизненный цикл сущности определен в информационной модели соответствующей диаграммой. В описании сущности отсутствует атрибут, который отражает изменение состояния сущности. В этой ситуации проектировщики добавляют атрибут status, для которого определяется ограничение допустимых значений (из списка допустимых состояний), а изменение состояния сущности описывается триггером, проверяющим допустимость сочетания нового и старого значения атрибута. 
Две диаграммы потока данных описывают различные бизнес-процессы, работающие над одними и теми же данными. Допустим, первая диаграмма описывает выписку товара со склада, а вторая -  сложный отчет, отражающий состояние склада. Один процесс интенсивно модифицирует данные, второй работает в режиме чтения данных, но требует согласованности данных в течение длительного времени. Каждый из процессов описывается транзакцией над данными. В СУБД уровни изолированности транзакций реализованы так, что читающие транзакции конфликтуют с модифицирующими транзакциями. Это приводит к остановке выписки товаров со склада на время выполнения отчета, что неприемлемо для заказчика. Здесь может потребоваться очень серьезное изменение информационной модели. 
Подобных примеров, когда не только ER-модель, но и другие продукты анализа не могут быть перенесены автоматически на модель данных, можно привести множество. Каждый такой случай инициирует изменение информационной модели. Решение проблемы определяется возможностями СУБД, выбранной для реализации проекта. Если проблем, не разрешаемых в рамках данной СУБД, накапливается очень много, то проектировщики могут поставить вопрос о смене СУБД. Такой вопрос поднимается именно на стадии проектирования, поскольку если уже разработчики столкнутся с подобными проблемами, то цена смены СУБД будет выше. Ясно, что одинаковых СУБД не бывает: то, что хорошо работает в одной, может плохо работать или вообще не работать в другой, несмотря на уверения производителей СУБД в поддержке стандартов SQL. Что касается хранимых процедур и триггеров, то здесь вообще трудно говорить о поддержке SQL92/PSM.
Вопросы производительности информационной системы также влияют на отображение ER-модели на модель данных. За счет мощного сервера баз данных можно добиться большей скорости реакции системы, но мощность аппаратного комплекса ограниченна. Производительность системы в целом зависит в том числе и от нормализации. Часто до 80% запросов к базе данных являются выборками данных, а соединение по тому или иному атрибуту относится к затратным операциям, в первую очередь соединение по нечисловым атрибутам. Увеличить производительность системы можно посредством введения избыточной информации - денормализации. Следует отметить, что решение об этом не принимается на основе одной ER-модели - требуется внимательно проанализировать потоки данных. Критичные процессы являются хорошими кандидатами для денормализации: по времени выполнения, по частоте выполнения, по большому объему обрабатываемых данных, по частоте изменения обрабатываемой информации, по явному приоритету. Часто к денормализации прибегают в целях ускорения выполнения отчетов. Для проверки эффективности той или иной денормализации привлекаются тестеры.

Типы данных 
Как правило, СУБД поддерживают небольшой набор базовых типов данных: числовые типы (целые, вещественные с плавающей и фиксированной точкой), строки (символов и байт), дата и время (или комбинированный тип datetime), BLOB (и его разновидности, например BLOB-поля для хранения только текста). В информационной модели каждому атрибуту соответствует домен. Поскольку не все реализации СУБД поддерживают домены, то в этом случае при определении модели данных ограничения домена описывают как ограничения столбца таблицы (если такое возможно); в частности используют check constraints, триггеры. Следует отметить, что при определении типов столбцов таблиц нужно учитывать, какие типы данных поддерживаются в словаре данных СУБД. Например, в Oracle ключевые слова integer, smallint, real поддерживаются транслятором SQL, но в словаре данных им соответствуют number(38), number(38), float(63), так как Oracle хранит данные в двоично-десятичном формате с плавающей точкой, а не в двоичном формате с плавающей точкой, и  38-восьмизначное число никак нельзя назвать словом smallint.
СУБД поддерживают два вида строковых типов: с фиксированной длиной (например, char), когда хранится ровно столько символов, сколько указано в описании атрибута, и с переменной длиной (например, varchar), когда хранится реальная длина значения атрибута, а концевые пробелы строки усекаются. Семантика сравнения строк в СУБД также различная, и если ваше мнение о сравнении строк расходится с тем, как это реализовано в СУБД, то придется смириться с этим как с особенностью СУБД. Например (описано поведение Oracle 7.x), если сравниваются значения A равное ‘ab’ и B равное ‘ab’ двух атрибутов типа varchar разной длины, то sql сообщит, что  . Чтобы избежать подобных «фокусов», нужно, в частности, следить за тем, чтобы приложение не вставляло незначащие концевые пробелы в значения атрибутов этих типов.

Индексы, кластеры 
В правильно спроектированной базе данных каждая таблица содержит первичный ключ, что означает наличие индекса. В большинстве СУБД используются индексы . Отметим, что если используется составной индекс, то поиск по всем атрибутам, входящим в индекс, начиная со второго, будет медленным. Допустим, определен индекс index1(id1, id2), в этом случае поиск значений, удовлетворяющих условию id2=1, будет медленным (не исключено, что оптимизатор вообще не будет использовать этот индекс для обработки данного условия и будет принято решение о полном сканировании данных), а поиск значений, удовлетворяющих условию id1=1 and id2=1, будет быстрым. Данные особенности следует учитывать при определении индексов в схеме базы данных, а именно:
индексировать нужно атрибуты, по которым наиболее часто осуществляется поиск или соединение. Наличие индекса замедляет операции модификации, но ускоряет поиск; 
наличие индекса обязательно, если для атрибута или набора атрибутов указано ограничение unique. Такие индексы СУБД создает автоматически, если в описании таблицы указаны ограничения unique; 
индекс может быть использован для выборки данных в заданном порядке. В этом случае не вызывается процесс сортировки ответа, а используется уже готовый индекс; 
атрибуты, входящие во внешний ключ, также следует индексировать, если СУБД не делает эту операцию автоматически при декларации внешнего ключа; 
в некоторых СУБД поддерживаются bitmap-индексы, которые очень эффективны при поиске на равенство, но для поиска на   этот тип индексов не годится; 
в некоторых СУБД поддерживаются хеш-индексы, например для кластеров. Такие индексы эффективно используются при поиске на равенство. 
Кластеризация - это попытка разместить рядом в одном физическом блоке данных те строки, доступ к которым осуществляется при помощи одинаковых значений ключа. Индексные кластеры, например, удобно использовать для хранения родительской и дочерних строк таблиц, связанных ссылочной целостностью. Кластеры удобно определять для тех наборов атрибутов, соединение по которым проводится наиболее часто, поскольку это увеличивает скорость поиска. Следует отметить, что в реализациях СУБД существуют жесткие ограничения на количество кластеров для таблицы, как правило, это один кластер. Особенности реализации кластеров в СУБД необходимо учитывать при проектировании критичных по времени выполнения модулей. Нужно обратить внимание, насколько сильно влияет наличие кластера на производительность DML-операций. Чаще всего это оказывает отрицательное влияние, которое в некоторых реализациях распространяется на DML-операции над любой таблицей базы данных, а не только над той, для которой определен кластер. Эти особенности СУБД также следует учитывать при проектировании.
Для того чтобы выбрать тот или иной тип индекса, требуется внимательно изучить руководство администратора СУБД. Оптимизатор SQL использует различные типы доступа к данным при обработке запросов, и индексирование существенно влияет на выбор оптимизатора.
Приведем некоторые способы доступа к данным на примере выборки select id, name from xtable where id=10:
Таблица не индексирована. В этом случае применяется полное сканирование, которое не является эффективным, если объем данных большой, в таблице много данных, не удовлетворяющих условию, размер кортежа существенно превосходит размер атрибута id. 
Атрибут id индексирован; тип индекса - . Тогда применяется индексное сканирование; полное сканирование может быть выбрано только в случае, если объем данных, удовлетворяющих данному условию, является большим (эта информация анализируется статистическим оптимизатором) и сравним с количеством записей в таблице. Индексное сканирование применяется лишь тогда, когда размер индексированных атрибутов меньше размера кортежа и все необходимые для обработки запроса данные могут быть получены из индекса; в остальных случаях может быть применено полное сканирование. 
Атрибут id входит в составной индекс, и является первым (лидирующим) атрибутом индекса, при этом тип индекса - . Аналогично предыдущему примеру,  применяется индексное сканирование. 
Атрибут id входит в составной индекс, он не первый атрибут индекса; тип индекса - . Индексное сканирование применяется лишь тогда, когда размер индексированных атрибутов меньше размера кортежа и все необходимые для обработки запроса данные могут быть получены из индекса; в остальных случаях применяется полное сканирование. 
Атрибут id индексирован; тип индекса - хеш. Здесь применяется индексное сканирование для поиска на =; если бы условие было id <=10, то применение хеш-индекса для такого поиска не эффективно. 
Атрибут id индексирован; тип индекса - bitmap. Здесь применяется индексное сканирование для поиска на =; если бы условие было id <=10, то применение bitmap-индекса для такого поиска не эффективно. 
Атрибут id является ключом хеш-кластера. В этом случае применяется алгоритм хеширования при поиске блока данных для чтения. При хорошем алгоритме и правильном размере кластера поиск может быть осуществлен за одно чтение; при ошибках в выборе алгоритма и блока кластера это может составить до нескольких тысяч операций чтения блоков. 
Атрибут id является ключом индексного кластера. Здесь применяется индексное сканирование, почти аналогично случаю с индексом . 
Таблица кластеризована, id не является ни кластерным ключом, ни лидирующим в составном индексе . В этой ситуации для кластера применяется полное сканирование. 
Мы привели только некоторые правила выполнения операции поиска в зависимости от наличия и типа индекса. В реализации используемой вами СУБД могут быть приняты иные принципы. Подробности использования типов сканирования при поиске данных даются в руководстве по настройке СУБД и в руководстве администратора СУБД.
А почему бы не проиндексировать все, если индексный поиск быстрее полного сканирования? Очевидно, что индекс занимает место на диске, вопрос в том - сколько. Например, индексируется атрибут integer - это 4 байта. Но в   кроме собственно значения ключа в индексе хранятся и внутренний идентификатор кортежа, и некоторая служебная информация, так что все вместе может составлять 4-8 байт. Чтобы точно посчитать эту величину для используемой вами СУБД, следует обратиться к руководству администратора: посмотрите размер идентификаторов ROWID (Oracle), RID (DB2) и т.д., а также размер страницы индекса (как правило, это 4 Кбайт).
При выборе стратегии индексации следует придерживаться двух простых принципов:
чем больше индексов, тем выше затраты на выполнение DML-операций. По грубым оценкам затрат: если принять за 1 работу по вставке строки в таблицу, то работа по вставке той же записи в один индекс равна 2 или 3 (для разных СУБД); 
в  любое значение может быть найдено за такое количество операций чтения, сколько уровней у дерева (дерево трех уровней для значений integer, например, содержит порядка 533 731 324 ключей, если страница дерева 4 Кбайт). Такие индексы отлично используются при поиске на =, <, >, <=, >=, between, и достаточно хорошо модифицируются. В bitmap-индексах содержатся готовые битовые векторы, отражающие вхождение или невхождение значения в ответ при поиске на равенство, но такие индексы плохо модифицируются и больше подходят для хранилищ данных, например для индексирования вхождения слов в текстовый документ. Хеш-индексы позволяют осуществлять поиск на равенство, хеш-функция используется для поиска блока кластеризованных данных, содержащего нужные значения. Если алгоритм хеш-функции хорош и размер кластера указан верно, то поиск может быть осуществлен за одно чтение. Эти индексы, как правило, используют для создания кластеров. 
Обратите внимание, хранит ли СУБД в индексах NULL. Если NULL в индексе не хранится, то вероятность использования полного сканирования для атрибутов без декларации not NULL резко повышается. Если NULL хранится в индексе (обычно его считают самым большим или самым маленьким при построении   и специальным значением при построении bitmap и хеш-индексов), то выясните, для каких операций поиска индексы будут использованы оптимизатором SQL. Эта информация, как правило, содержится в руководстве администратора. Можно проверить и экспериментально, создав тестовую таблицу с объемом данных примерно 20 тыс. записей (чтобы оптимизатор не выбирал полное сканирование по причине малого объема) и выполнив исследуемый запрос, а затем произвести explain плана запроса (если подобный сервис предоставляется СУБД).

Временные данные 
Временными данными, или временными рядами, называют данные, содержащие дату и время. Неправильная обработка таких данных в некоторых СУБД может служить одной из основных причин низкой функциональности и производительности информационной системы. Временные ряды не очень хорошо вписываются в двухмерную реляционную модель. SQL поддерживает соединения, не основанные на равенстве, но большинство разработчиков СУБД ограничиваются эквисоединением. Для временных данных часто приходится соединять таблицы на основе перекрытия одного диапазона дат другим. В SQL не существуют операции, которая позволяла бы задать такое соединение непосредственно.
Ряд атрибутов, например курс валюты или цена товара, изменяются во времени. Такие атрибуты действительны по дате, то есть актуальны только в течение определенного интервала времени, например дня для курса валюты.
Если СУБД позволяет обрабатывать многомерные данные, то обработка временных рядов может использовать эти механизмы и тогда время будет являться одним из измерений. Подобные многомерные процессоры применяются для обработки геофизических и географических данных. В таких системах используются индексы  ,   и их клоны.
Приведем пример обработки цены товара (код товара, начальная дата, конечная дата, цена):
create table prices   
(id integer, date_from date not null,   
date_to date, price decimal not null,   
constraint p_range check date_from < date_to);  
Отметим, что здесь в отношении не задан первичный ключ, а сама задача определения ключа в таких отношениях отличается сложностью. Известно, что момент изменения цены заранее не известен, этим и объясняется отсутствие ограничения not null для атрибута date_to:
select price from prices   
where id = :PRODUCT_CODE  
and date_from < :WHEN_DATE  
and date_to >=   
nvl(:WHEN_DATE, to_date(’01/12/4721’, ’DD/MM/YYYY’);  
Здесь :PRODUCT_CODE и :WHEN_DATE обозначают переменные включающего языка, дата ’01/12/4721’ является самой большой из поддерживаемых СУБД (эта дата  может быть и другой). Подобные операции лучше оформлять в виде хранимых процедур, функций или претранслированных запросов. В хранилищах данных часто обрабатываются архивные данные, для которых обработка временных рядов также актуальна.
Возникают также вопросы по поводу точности дат, например: они актуальны для курсов валют, биржевых сделок. Следует определить, достаточна ли точность даты до секунды или нет. Существует проблема и с тем, как зарегистрировать сделку, если цена акции постоянно меняется. Некоторые проектировщики в этом случае обрабатывают временной ряд, но есть и более простое решение -  отследить цену акции на момент прохождения биржевой транзакции и сохранить эту цену как часть информации, которую модифицировала транзакция. Поэтому сначала следует рассмотреть простые варианты решения задач, и если ни один из них не подходит, то использовать временные ряды.
А также как нужно показывать не известную на текущий момент дату, например момент, когда цена товара перестанет быть актуальной? Сделайте это значение равным NULL или самым большим значением (определите его как default-значение для атрибута). Следует отметить, что значения default в большинстве реализаций СУБД работают только при вставке новых записей. Можно, конечно, создать триггер, который срабатывает после выполнения операции insert или update и преобразует null в наибольшее из допустимых значений даты. Но в этом случае, когда пользователь будет работать с подобной информацией, то может забыть, откуда взялась та или иная дата. Если вы спроектировали схему базы данных и запросы таким образом, то все приложения, работающие с выборками данных, должны отвечать следующим требованиям:
принудительно конвертировать в null такие даты и не показывать их пользователю; 
использовать соответствующие представления, содержащие decode (или иное средство конвертации «больших» дат); 
вызывать хранимую процедуру, которая выполнит все нужные преобразования. 
Выше только что были перечислены возможные проектные решения. Отметим, что для эффективного поиска следует создать составной индекс с атрибутами (date_from, date_to), но не все СУБД будут использовать такой составной индекс, если для одного из атрибутов допустимы значения null. Поэтому довольно простая для аналитиков задача представления временных рядов может повлечь за собой множество неприятных моментов при проектировании.
Теперь рассмотрим проблему поиска первичного ключа для подобных отношений. Оказывается, что единственный разумный вариант предотвращения дубликатов таков: каждому единичному интервалу соответствует отдельная строка. Для биржевых операций этот интервал может быть равен, например, одной секунде, а в некоторых системах он еще меньше. У таких таблиц только одно преимущество -  результат из них можно выбирать при помощи эквисоединения, однако объемы обрабатываемых данных велики.
Использование временных рядов, как правило, является одной из наиболее актуальных тем в разговоре с аналитиками. Какое решение будет лучшим - зависит от используемой СУБД и от ее особенностей, а именно: оптимизатора запросов, особенностей использования индексов, мощности SQL, хранимых процедур и триггеров.

Хранение объектов данных 
Это одна из самых сложных задач проектирования схемы базы данных, для решения которой привлекаются администраторы баз данных. Универсальных решений, которые подошли бы для любой СУБД, не существует, так каждый производитель СУБД создает свой способ хранения и доступа к данным, считает его лучшим и очень им гордится. На проектирование схемы базы данных влияют следующие параметры, общие для большинства СУБД:
размер табличных пространств для хранения таблиц; 
размер табличных пространств для хранения индексов; 
размер табличных пространств для хранения BLOB; 
кластеры и их параметры; 
размер словаря данных, включая код всех хранимых процедур, функций, триггеров, пакетов, статического SQL (реализован только в DB2); 
управляющие файлы; 
файлы журнала; 
интенсивность потока запросов, модифицирующих данные и индексы; 
фалы временных табличных пространств (для хранения временных таблиц, которые строятся, например, при выполнении group by, а также других временных объектов); 
интенсивность потока запросов, инициирующих создание временных таблиц; 
потоки транзакций read-write, read-only, объем модифицируемых и считываемых ими данных, характеристики параллельной работы транзакций (какие и сколько их); 
количество приложений, работающих параллельно с базой данных; 
количество соединений с базой данных для каждого приложения; 
файлы параметров старта ядра СУБД; 
загрузочные модули ядра СУБД и утилиты СУБД; 
входные и выходные данные, генерируемые пользовательскими программами; 
скрипты управления СУБД. 
Постарайтесь описать эти параметры хотя бы в общем виде, обсудите все вопросы с администратором баз данных и внимательно выслушайте его рекомендации. Если же его мнение может расходится с вашим представлением о том, как должна работать СУБД, попытайтесь понять его аргументы и запомните, с какими особенностями СУБД это связано. Все данные следует отразить в журнале проектирования. Следует иметь в виду, что многие нюансы размещения объектов данных и конфигурации сервера баз данных не могут быть учтены на этапе проектирования, так как требует полномасштабного тестирования. Конечно, избежать некоторых ошибок проектирования можно, но приготовьтесь к тому, что схема базы данных будет меняться и на этапе реализации, причем  неоднократно.

Защита данных
Стратегия защиты определяется на этапе анализа, а на этапе проектирования предстоит реализовать эту стратегию, спроектировав соответствующие структуры в схеме базы данных и модули. Большинство СУБД имеют развитые средства дискреционной защиты, а ряд СУБД имеют встроенные подсистемы аудита, что освобождает от необходимости создания собственных средств защиты.
Обычно СУБД предоставляют набор пакетированных привилегий для управления данными, например: connect, которая разрешает соединение с базой данных; resource, которая дополнительно разрешает создание собственных объектов базы данных, dba, которая позволяет выполнять функции администратора конкретной базы данных, и др. Дискреционная защита предполагает разграничение доступа к объектам данных (таблиц, представлений, и т.п.), а не собственно к данным, которые хранятся в этих объектах. Дискреционная защита также обеспечивает создание пользовательских пакетированных привилегий - ролей или групп привилегий. В этом случае набор привилегий на те или иные объекты данных назначается группе или роли, а затем эта группа или роль назначается пользователю; таким образом пользователь получает привилегии на выполнение тех или иных операций над объектами данных косвенно - через группу или роль.
В некоторых реализациях допускается выполнение определенного набора операций от имени другого пользователя и с его привилегиями - в частности вызовы пакетов и хранимых процедур. Пользователь, вызывающий такой объект, не может ни изменить пакет или хранимую процедуру, ни получить доступ к ее коду, но операции над данными, которые выполняются в хранимой процедуре или пакете, будут выполнены от имени владельца хранимой процедуры или пакета. То же самое относится и к триггерам.
Некоторые проектировщики очень любят использовать описанный выше метод защиты данных - это похоже на инкапсуляцию. Иногда проектировщики строят на каскадирующих вызовах хранимых процедур весьма сложные протоколы доступа к данным, имитируя мандатную защиту. Такой подход имеет свои преимущества и недостатки. С одной стороны, любой доступ к данным скрыт хранимой процедурой или пакетом, но с другой - в этом случае словарь данных сильно перегружен. Однако далеко не все реализации СУБД хорошо работают с курсорами в хранимых процедурах и пакетах, поскольку это вызывает  чрезмерную загрузку процессора. Кроме того, в большинстве реализаций СУБД предложения SQL, выполняемые из хранимой процедуры или пакета, имеют более высокий приоритет, чем операции SQL, выполняемые из приложения пользователя. В связи с этим большое количество вызовов хранимых процедур может существенно замедлить выполнение запросов непосредственно из приложений пользователя. В любом случае, чтобы сделать защиту данных, «закрывая» любой запрос хранимой процедурой, требуется, чтобы СУБД имела достаточно развитый язык и позволяла, например, выполнять синтаксический разбор и чтобы внутри самой хранимой процедуры можно было строить как статические, так и динамические предложения SQL.
К сфере защиты данных относятся также сохранность данных и восстановление их после сбоя системы. Для обеспечения бесперебойной работы часто применяют архивирование (в том числе инкрементное) базы данных и журнала транзакций, а в случае отказа системы при следующем старте операции над данными восстанавливают по журналу транзакций (например, производят их откат до определенного момента времени). Применяют также методы горячего резервирования, когда работают два сервера: основной, обрабатывающий запросы пользователей, и резервный, который продолжает работу основного сервера в случае его отказа. Состояние хранилищ данных на основном и резервном серверах согласовано и поддерживается СУБД автоматически, что позволяет проектировщикам не разрабатывать собственные механизмы репликации данных.
Работа серверов в режиме горячего резервирования не избавляет от необходимости хранения резервных копий данных, это может быть и не очевидно для аналитиков и не предусмотрено ими. Некоторые бизнес-процессы по своей природе требуют от информационной системы работы в режиме 24x7, и любой простой стоит очень дорого. В этих случаях работают две или три параллельные системы, и при отказе одного из серверов резервные серверы немедленно принимают управление на себя. Эффективным, но дорогостоящим способом реализации таких задач являются предоставляемые СУБД технологии симметричной репликации. Еще один вариант - архивирование журналов транзакций на резервном узле на специальное устройство и немедленный докат по этому журналу резервного узла в случае отказа основного. Разные СУБД предлагают разные механизмы реализации подобной бесперебойной работы, и для принятия верного проектного решения необходимы консультации проектировщиков с администраторами баз данных.
В простых ситуациях, когда информационная система используется в основном для операций чтения данных, а сами данные меняются редко, резервное копирование может вообще не требоваться, если данные одной такой системы могут быть легко восстановлены из данных других работающих систем. Достаточно будет обеспечить наличие образа базы данных (архив всех файлов базы данных, а также управляющих файлов - это должен быть снимок базы данных на определенный момент времени; проще всего такой снимок получить, остановив СУБД и сделав резервную копию всех указанных файлов).
В большинстве информационных систем необходимо обеспечение безотказной работы системы в ситуации, представляющей собой нечто среднее между описанными выше двумя крайними случаями. Проектировщики должны пересмотреть результаты анализа, исходя из ответов на следующие вопросы:
каков график необходимой доступности системы для запросов пользователя (то есть когда система обязательно должна работать); 
допустимы ли вообще и когда допустимы периоды профилактического простоя системы; 
допустимы ли и когда допустимы периоды ограничения доступа к системе; 
какие данные после отказа системы нельзя получить из других источников (часто это ввод новых документов, например накладных, операции со счетами, заказы на телефонные переговоры, информация с автоматизированных датчиков и т.п.); 
если данные можно получить, то каков объем повторно вводимой информации; 
каково допустимое время восстановления системы после сбоя; 
имеется ли график пакетных суточных заданий; 
какие еще приложения, кроме информационной системы, работают на данном оборудовании; 
имеются ли резервные аппаратные средства на случай отказа основных; 
имеется ли запас мощности оборудования, на котором функционирует информационная система; 
какова скорость передачи данных при резервном копировании; 
имеются ли специальные отказоустойчивые носители для хранения резервных копий; 
имеется ли правило циклического использования резервных носителей; 
имеется ли специальное защищенное место для хранения резервных носителей. 
Ответы на эти вопросы позволят более реально оценить ситуацию и уточнить требования заказчика, формализованные аналитики. Бывает, что заказ работоспособности системы в режиме 24х7 вовсе не является обоснованным и система простаивает, например, 50% времени. Если же требование 24х7 действительно отражает особенности данного бизнеса, то эти вопросы помогут построить соответствующую стратегию защиты данных от сбоев. Качество построенной при проектировании стратегии защиты должно быть проверено тестерами, причем их работа по генерации и проведению тестов, имитирующих отказы оборудования, должна проводиться как на этапе проектирования, так и в течение всего этапа разработки - в целях раннего обнаружения дефектов стратегии защиты данных от сбоев.

Обмен данными с внешними системами 
Большинство аналитиков считают задачи обмена с внешними системами чисто физическими, решенными априори и, как следствие, не уделяют этим вопросам внимания при анализе. Поэтому зачастую проектировщики вынуждены нести на себе всю нагрузку по созданию таких систем обмена.
Импорт и экспорт данных во внешние системы могут обеспечиваться как утилитами, поставляемыми в составе СУБД, так и специальными средствами обмена данными проектируемой информационной системы. Прежде чем писать код собственно системы обмена данными, внимательно изучите сервис, который предоставляет СУБД, и используйте его полностью. Если обмен данными идет между двумя однородными базами данных (одного производителя и одной версии), то средства импорта и экспорта данных во внутреннем формате данной СУБД могут быть использованы без ограничений. Если же обмен данными осуществляется между СУБД разных производителей, то для импорта и экспорта собственно данных можно использовать текстовые файлы. Следует при этом обратить особое внимание на особенности представления null, пустых строк символов и BLOB, так как здесь потенциально присутствует расхождение интерпретации содержимого файлов загрузчиками данных.
Импорт и экспорт схем может оказаться более сложным делом. Производители СУБД часто заявляют о поддержке стандартов ANSI, но на практике большинство баз данных не удовлетворяют им полностью. Синтаксисы операций создания таблиц существенно различаются, а синтаксисы определения хранимых процедур и триггеров большинства СУБД вообще несовместимы. Информация о схеме базы данных может быть получена из системного каталога посредством анализа данных в системных представлениях, но и здесь нет полной поддержки стандарта. Когда информационной системе требуется обмен данными между СУБД разных производителей, то, как правило, проектировщики принимают решение о создании специализированного средства. Даже если оно не будет полнофункциональным и не может быть применено для решения задачи конвертации данных между любыми СУБД, то решить локальную задачу оно способно.
Интерфейсы обмена с внешними системами можно разбить на следующие категории:
одноразовый импорт данных, унаследованных, как правило, из старой системы; 
периодический обмен данными между узлами информационной системы (внутренний обмен); 
периодический обмен данных с другими информационными системами (внешний обмен). 
Если обмен данными должен осуществляться в режиме, близком к реальному времени, то это будет задача о распределенной базе данных, а не о простой передаче данных.
При анализе задач загрузки и выгрузки данных проектировщик должен рассмотреть:
каким подсистемам нужен интерфейс выгрузки данных и каков должен быть интерфейс загрузки данных из внешней системы; 
каковы периодичность обмена данными и объем передаваемых данных; 
какая требуется степень синхронизации двух систем; 
каковы возможные методы транспортировки данных; 
а также:
согласовать формат данных для обмена; 
определить зависимости загрузки и выгрузки, например порядок выполнения операций; 
определить мероприятия, которые необходимо выполнить при сбое во время загрузки и выгрузки данных; 
сформулировать правила определения ошибочных записей (при загрузке); 
определить правила регистрации операций передачи и приема данных; 
определить график передачи данных (в большинстве информационных систем эти операции выполняются в ночное время); 
составить график разработки и тестирования собственных утилит или скриптов обмена данными; 
составить график разовой загрузки данных, наследуемых из старой системы, и подготовить методику проверки корректности этой операции. 
Следует отметить, что при наследовании данных из старой системы проектировщикам не приходится надеяться на то, что кто-то создаст утилиту, позволяющую достать данные из старой системы, - обычно это становится задачей самих проектировщиков новой системы. Может случиться так, что вам придется работать в жестких условиях, когда не будет возможности выделить время для тестирования новой программы извлечения данных. В этом случае нужно разработать набор тестовых данных. Если в старой системе имеется какое-то средство извлечения данных - используйте его; часто это самый разумный выход.
При загрузке данных из старой системы проектировщики могут столкнуться с большим объемом неочищенных данных - с нарушениями целостности данных, возникшими из-за сбоев системы, «заплаток» разработчиков, иных неприятностей. Возможно, что на вас будет оказано давление с тем, чтобы допустить наличие неочищенных данных в новой системе. Если не принять мер по очистке данных, то, вероятно, большинство спроектированных ограничений целостности нужно будет ослабить, чтобы загрузить хоть какую-то часть данных. Цена такой уступки достаточно высока: данные вы приняли, но ослабленные ранее ограничения уже нельзя восстановить, так как они уже нарушены (это отслеживается СУБД автоматически). Отсюда следует вывод: поддаваться давлению нельзя, так как несколько дней, потраченных на очистку данных, стоят так мало по сравнению с наличием в информационной системе данных, не обладающих элементарной целостностью.
Что делать с данными, которые содержат ошибки или не согласованы? Самое простое решение -  пропускать такие данные, собирать их отдельно и анализировать. Здесь вас могут ждать некоторые проблемы: не все СУБД при загрузке данных их собственными утилитами позволяют в случае  возврата кода ошибки указать запись, на которой произошел сбой. Если это так, то данные следует загружать небольшими порциями, чтобы можно было легче найти запись, которая повлекла сбой. Можно разместить данные с нарушениями целостности в отдельных таблицах, а потом обработать их. Подобную операцию (которую аналитики, как правило, не предусматривают) лучше автоматизировать посредством отдельного компонента. Проектировщикам придется либо озадачить аналитиков исследованием правил корректности данных, либо выполнить эту работу самим, причем необходима помощь опытных пользователей старой информационной системы. Здесь крайне важно найти данные, которые являются надежными, то есть те, которые с большой вероятностью указаны правильно. От таких данных и надо отталкиваться при создании программ проверки корректности данных.
Далеко не все СУБД предоставляют средства, позволяющие выгрузить схему данных, хранимые процедуры и триггеры, но имеется достаточное количество ПО сторонних фирм, способного на это. Самым привлекательным будет ПО, осуществляющее выгрузку указанных объектов в виде скриптов, описывающих их создание. Если ПО позволяет сначала создать объекты данных без ограничений ссылочной целостности, а потом изменить их, добавив эти ограничения, то такой опцией рекомендуется пользоваться всегда. Дело в том, что большинство утилит выгрузки схемы опрашивают системный каталог и генерируют скрипт создания таблиц в том порядке, в котором имена таблиц встречаются в системном каталоге. Но вы не застрахованы от того, что имя таблицы-потомка будет считано раньше имени таблицы-предка. От исправления операций создания объектов данных вы также не застрахованы, так как у большинства СУБД разный синтаксис определения ограничений ссылочной целостности, серверных ограничений, индексов. Например, перечисленные ниже определения ссылочной целостности для таблицы tx:
create table t(id int primary key, name char(10);  
create table tx(i int, j int references t(id));  
create table tx(i int, j int references t(id) on delete no action on update no action);  
create table tx(i int, j int, foreign key j references t(id) on delete no action on update no action);  
create table tx(i int, j int, foreign key j references t on delete no action on update no action);  
create table tx(i int, j int, constraint t_ref_cascade foreign key j references t(id) on delete no action on update no action);  
все означают в точности одно и то же, но синтаксис у них разный. Для преобразования предложений SQL в требуемый формат могут быть созданы специальные утилиты. Поскольку в этом случае требуется разбор текста, то весьма нецелесообразно применение инструмента Perl. К сожалению, операция переноса хранимых процедур и триггеров не может быть в такой же степени автоматизирована вследствие существенных различий в языках их написания в разных СУБД. Некоторые СУБД совместимы по синтаксису хотя бы частично, но если этого нет, то большой доли ручной работы не избежать.
",1
21,Этапы разработки проекта3.docx,"Этапы разработки проекта: определение стратегии тестирования и проектирование
Определение стратегии тестирования
Как отмечалось ранее, на этапе анализа привлекаются группы тестирования, например для получения сравнительных характеристик предполагаемых к использованию аппаратных платформ, операционных систем, СУБД, иного окружения. Кроме того, на данном этапе определяется план работ по обеспечению надежности информационной системы и ее тестирования. Для любых проектов целесообразным является привлечение тестеров на ранних этапах разработки, в частности на этапе анализа и проектирования. Если проектное решение оказалось неудачным и это обнаружено слишком поздно - на этапе разработки или, что еще хуже, на этапе внедрения в эксплуатацию, - то исправление ошибки проектирования может обойтись очень дорого. Чем раньше группы тестирования выявляют ошибки в информационной системе, тем ниже стоимость сопровождения системы. Время на тестирование системы и на исправление обнаруженных ошибок следует предусматривать не только на этапе разработки, но и на этапе проектирования.
Для автоматизации тестирования следует использовать системы отслеживания ошибок (bug tracking). Это позволяет иметь единое хранилище ошибок, отслеживать их повторное появление, контролировать скорость и эффективность исправления ошибок, видеть наиболее нестабильные компоненты системы, а также поддерживать связь между группой разработчиков и группой тестирования (уведомления об изменениях по e-mail и т.п.). Чем больше проект, тем сильнее потребность в bug tracking.

Проектирование
На этапе проектирования формируется модель данных. Проектировщики в качестве исходной информации получают результаты анализа. Конечным продуктом этапа проектирования являются:
схема базы данных (на основании ER-модели, разработанной на этапе анализа); 
набор спецификаций модулей системы (они строятся на базе моделей функций). 
Если проект небольшой, то в качестве аналитиков, проектировщиков и разработчиков могут выступать одни и те же люди. Возникает вопрос: насколько вообще актуальна передача результатов самому себе? Думаем, что актуальна. Представьте себе, что вы передаете данные кому-либо, кто мало знает о системе. Зачастую это помогает, например, найти не описанные вообще, нечетко описанные, противоречиво описанные компоненты системы.
Все спецификации должны быть точными. План тестирования системы дорабатывается также на этом этапе разработки. Во многих проектах результаты этапа проектирования оформляются единым документом, который называют технической спецификацией. В нем также описывают принятый подход к решению каких-либо сложных технических вопросов.

Журнал проектирования
При проектировании возникает необходимость регистрировать все обсуждаемые варианты и окончательные решения. Не секрет, что проектировщики порой меняют первоначальные решения. Это может происходить потому, что со временем участники проекта забывают аргументы в пользу принятого решения. Подобную информацию можно хранить в репозитарии используемого CASE-средства, в текстовых файлах, просто на бумаге. Журнал проектирования является полезным материалом для новых членов групп проектировщиков, а также для разработчиков и тестировщиков.
Такой журнал может вестись как на этапе анализа, так и на этапе разработки и тестирования.

Планирование этапа проектирования
Тщательное планирование важно для любого проекта. Это входит в обязанности руководителя проекта и руководителя группы проектирования (консультации с аналитиками в этом случае будут обязательными). Это позволяет:
Разбить глобальную задачу на небольшие, независимые задачи. Такими задачами легче управлять, такие задачи легче реализовывать. 
Определить контрольные даты (этапы сдачи), которые позволят определить, насколько успешно продвигается проект, какие направления отстают, какие недогружены, какие работают успешно. Это позволяет обнаружить отставание от сроков сдачи и вовремя предотвратить авралы. 
Определить зависимости между задачами, а также последовательность завершения задач. 
Прогнозировать загрузку персонала, наем временных работников, привлечение других групп разработчиков, привлечение консультантов (если это необходимо). 
Получить четкое представление о том, когда можно начать этап реализации. 
Получить четкое представление о том, когда можно начать этап опытной эксплуатации. 

Перепланирование
Заказчики всегда хотят, чтобы план выполнения работ оставался неизменным. На практике этого редко удается достичь в полном объеме. Определенным компромиссом здесь может стать неизменность установленных сроков сдачи компонентов системы в эксплуатацию.
Задачи проектирования.

Ранние стадии
Рассмотрение результатов анализа
Это собственно процесс передачи информации от аналитиков проектировщикам. На практике это итерактивный процесс. У проектировщиков неизбежно будут возникать вопросы к аналитикам, и наоборот. Информация о системе будет постоянно уточняться. При разработке схемы базы данных может измениться информационная модель, полученная на этапе анализа, например потому, что имеющееся проектное решение нестабильно либо медленно работает при реализации его посредством выбранной СУБД или в силу иных причин. Проверить, охватывает ли анализ все бизнес-процессы системы (то есть осуществить проверку на полноту), проектировщики не в состоянии, но проверку информационной модели на непротиворечивость и корректность проектировщики провести могут. Это позволяет отследить ошибки в информационной модели и не повторить их в модели данных. Если результаты хранятся в репозитарии CASE-средства, то такая проверка на корректность может быть произведена автоматически.

Семинары
Ранние стадии проектирования сопряжены с нудной и утомительной работой. Проектировщики и аналитики должны достигнуть полного понимания требований заказчика. Семинары являются быстрым и эффективным способом обмена информацией. Хороший способ убедиться в том, правильно ли проектировщики понимают назначение той или иной подсистемы, - взять один или несколько сценариев бизнес-процессов и проиграть их. Это можно сделать в форме простой диаграммы потока данных, причем необходимо указать не только автоматизированные, но и ручные функции.

Критические участки
Критические участки системы изучаются при первом обследовании системы и уточняются на этапе анализа. Термин «критические» может означать жизненно важные как для нормального функционирования информационной системы с точки зрения бизнеса (например, время простоя автоматизированной линии изготовления материала X не должно превышать одной минуты), так и для успешной реализации и приемки проекта. Критические с точки зрения бизнеса участки информационной системы хорошо подходят для макетирования. На основе этих макетов (работы макетирования выполняют проектировщики и группы тестирования) тестеры дают оценку качества как информационной модели, так и модели данных. Также макетирование позволяет показать, какие требования и какими средствами могут быть выполнены, а какие требования - не могут.
Часто на этапе проектирования выявляются критические участки, которые не были очевидными на этапе анализа. Это влечет за собой необходимость уточнения информационной модели. Часто это связано с особенностями реализации тех или иных возможностей в выбранной СУБД. Некоторые функции, которые на этапе анализа выглядят простыми, могут стать очень сложными, когда дело дойдет до физической реализации. Например:
В выбранной СУБД отсутствует эффективный механизм сканирования деревьев, а при анализе выявлено большое количество справочников и выбраны интерфейсы представления в виде деревьев, кроме того это понравилось заказчику, а СУБД при большом справочнике работает слишком медленно. 
Другая распространенная неприятность - неполно реализованная ссылочная целостность. В СУБД не реализованы каскадные модификации, в информационной модели нормализованные отношения предполагают наличие каскадных удалений и обновлений. Реализация же таких механизмов посредством триггеров оказалась слишком медленной, и уровень каскадирования триггеров ниже, чем уровень каскадных операций, определенных в информационной модели. 
Такие моменты могут инициировать не только изменение информационной модели, но и смену СУБД.
Между критическими участками проекта и его рисками существует тесная связь. Критический участок разработки (например, срыв сроков первого этапа сдачи проекта заказчику) может стоить целого проекта. Причинами срыва могут быть как ошибки проектирования, так и нехватка персонала.

Оценка ограничений
Ограничениями, известными с момента обследования бизнес-процессов, являются смета затрат и сроки внедрения. Могут быть и другие ограничения, например допуск персонала к той или иной информации (группы аналитиков к информации о бизнес-процессах в фирме, ограничения доступа к секретной информации и т.п.).
Решения относительно выбора аппаратной платформы, как правило, необратимы, поскольку тесно связаны со сметой затрат и наличием обслуживающего персонала. Например, решения на платформе RS/6000 и Intel с точки зрения сметы затрат выглядят одинаково, но персонала, способного квалифицированно обслуживать RS/6000, нет, и руководство не согласно оплатить обучение сотрудников, хотя решение на основе RS/6000 обладает более высокой масштабируемостью. Это может послужить причиной выбора платформы Intel. Аналогичные причины могут влиять и на выбор операционной системы.
Если проект является расширением или модернизацией существующей информационной системы, то число унаследованных ограничений также может быть большим. На этапе проектирования осуществляется обязательная проверка требований к информационной системе в свете выявленных ограничений. Менять платформу, операционную систему или СУБД на этапе реализации сложно, а на этапе опытной эксплуатации практически невозможно (на это просто не хватит времени, если не произойдет чудо). Чем большее количество компонентов системы уже реализовано, тем сложнее произвести подобную замену. Большинство СУБД сейчас работают на нескольких аппаратных платформах и нескольких операционных системах, но если есть участки кода проекта, зависимые от операционной системы или аппаратной платформы, то их изменение может обойтись очень дорого. В данной статье мы не будем обсуждать вопросы переносимости кода, поскольку они выходят за рамки этого цикла.
Если какие-либо требования не могут быть удовлетворены в принципе, принимается решение о доведении этого факта до сведения спонсоров проекта (руководства фирмы). Обнаружение неработоспособности системы в процессе эксплуатации ничем хорошим обернуться не может, особенно если до руководства фирмы дойдет информация о том, что невыполнимость требований была известна заранее.

Определение целевой архитектуры
Под выбором архитектуры мы понимаем и выбор платформы (платформ), и выбор операционной системы (операционных систем). В  системе могут работать несколько компьютеров на разных аппаратных платформах и под управлением различных операционных систем. Если к автоматизации того или иного бизнеса до вас уже приложили руки, причем неоднократно, вы можете обнаружить настоящий «зверинец» платформ и операционных систем. Перенос ПО на ту или иную платформу - процесс не безболезненный, да и управление разнородной сетью может также стать делом проблемным. Если же обстоятельства таковы, что ПО на рабочих местах конечных пользователей должно работать под управлением нескольких операционных систем (ОС), то следует обязательно выделить зависимые от ОС участки кода и жестко описать интерфейсы обмена компонентов информационной системы, сделав их независимыми от ОС. При написании кода модулей, работающих под управлением нескольких ОС, следует ориентироваться на ту из них, которая обладает наиболее жесткими требованиями.
Кроме определения платформы следует выяснить следующее:
Будет ли это архитектура «файл-сервер» или «клиент-сервер». 
Будет ли это 3-уровневая архитектура со следующими слоями: сервер, ПО промежуточного слоя (сервер приложений), клиентское ПО. 
Будет ли база данных централизованной или распределенной. Если база данных будет распределенной, то какие механизмы поддержки согласованности и актуальности данных будут использоваться. 
Будет ли база данных однородной, то есть будут ли все серверы баз данных продуктами одного и того же производителя (например, все серверы только Oracle или все серверы только DB2 UDB). Если база данных небудет однородной, то какое ПО будет использовано для обмена данными между СУБД разных производителей (уже существующее или разработанное специально как часть проекта). 
Будут ли для достижения должной производительности использоваться параллельные серверы баз данных (например, Oracle Parallel Server, DB2 UDB и т.п.). 
Эти решения часто принимаются до начала этапа проектирования (на этапе анализа). На этапе проектирования полезно еще раз рассмотреть все причины выбора той или иной архитектуры, провести тесты производительности и надежности критических участков информационной системы. Это позволит избежать тяжело устраняемых ошибок проектирования. Довольно часто на этапе проектирования возникают непредвиденные технические проблемы, например аналитики не учитывают группу пользователей, имеющих доступ к информационной системе посредством текстовых терминалов. Это ошибка анализа, но выявляется она только на этапе проектирования. Такие проблемы должны решаться вместе с аналитиками, которые инициируют изменение информационной модели.
Если в среде используется сеть, то на этапе проектирования необходимо определить требуемые уровни сервиса сети и спроектировать ее топологию. Необходимо также провести тесты сети, чтобы увидеть, обеспечивает ли существующая сеть должную пропускную способность и имеется ли резерв пропускной способности сети. Если результат отрицательный, то следует четко описать необходимые изменения аппаратного обеспечения и топологии сети.

Выделение потенциальных узких мест в информационной системе
Если заказчик заявит, что производительность системы не имеет никакого значения, примите это замечание с юмором. Это означает лишь то, что время ответа системы на запрос не является (или не кажется заказчику в данный момент) критическим. Попробуйте спросить, приемлемо ли время ответа системы, равное одному часу или одному дню. Вряд ли ответ на этот вопрос будет положительным.
Производительность важна для любой информационной системы. Узким местом называют момент падения производительности системы. Конкретный ответ на вопрос, где узкие места данной системы, может дать лишь специальное направленное тестирование. Но это не означает, что оценка потенциальных узких мест невозможна. Одним из хороших методов является график нагрузки на систему в течение дня, недели, месяца и т.п. Можно построить диаграмму, на которой будет отражено время работы тех или иных бизнес-процессов, а также требуемое для данного бизнес-процесса время ответа системы. Такие диаграммы помогают выявить момент, когда нагрузка будет наиболее интенсивной. Количество пользователей, одновременно работающих с тем или иным компонентом, отражается на диаграмме посредством весового коэффициента (рис. 1).
В приведенном примере явно видны 3 пика активности системы, максимальный из которых приходится на 11 часов. Использован тип диаграммы с накоплением.
А в диаграмме, представленной на рис. 2, видна активность касс в течение рабочего дня и повышение активности загрузки данных в нерабочее время. В такие диаграммы следует также добавлять вес, отражающий сложность бизнес-процесса, например в данном примере самый высокий весовой коэффициент будут иметь отчеты. Оценка весов определяется особенностями каждого конкретного бизнеса - где-то она может быть высокой, где-то низкой.
Ответ на вопрос, насколько потенциальные узкие места являются реальными, может дать только тестирование. Здесь оправданно применение специальных средств моделирования сценариев приложений. Следует отметить, что оценка точности детектирования узкого места в системе очень зависит от объема обрабатываемых данных. Следует уделить внимание генерации тестовых данных и проверке узких мест уже на этих данных. Часто информационная система не сразу выходит на проектную мощность, как правило, она работает некоторое время в режиме первоначального накопления информации, которое может продолжаться и несколько дней, и несколько месяцев. Как правило, предполагаемый порог объема обрабатываемых данных известен на этапе анализа, но реальный объем физических данных можно точно оценить только на этапе проектирования. Если сгенерировать предполагаемый объем тестовых данных нельзя (не хватает мощности техники или есть иные причины), то тесты проводят на меньшем объеме данных и пытаются построить оценки поведения системы на реальном объеме данных.
Более точно узкие места системы оцениваются на этапе разработки. Здесь уже есть реализованные компоненты системы. Средства автоматизации тестирования (например, LoadRunner, WinRunner и др.) позволяют отследить операции, которые выполняет то или иное приложение (но данные средства могут отследить далеко не все возможные типы приложений и то, насколько они подходят для тестирования вашего проекта, - это решение такого же порядка, что и выбор средства разработки приложения), автоматически сгенерировать сценарий запуска имитаторов работы реальных приложений и построить оценки узких мест системы.

Продукты третьих фирм
На этапе проектирования оценивают возможность и эффективность использования продуктов третьих форм в разработке данной информационной системы. Например, существует задача выполнения некоторого набора работ (определенных пакетных заданий и т.п.) по заданному графику. Далеко не всегда целесообразно включать в проект создание утилиты контроля запуска приложений, поскольку есть масса утилит, выполняющих эти операции, в том числе и свободно распространяемых. Существует и другая причина, по которой с ПО третьих фирм следует хотя бы ознакомиться. Не факт, что в мировой практике решения задач, подобных вашей, не встречаются. Если реализации третьих фирм известны, то следует с ними ознакомиться хотя бы для того, чтобы не повторять неудачные решения и взять на заметку удачные. Вероятно, какой-либо из существующих продуктов может быть интегрирован в создаваемую вами информационную систему. Для этого, возможно, потребуется создать интерфейс обмена данными между ПО третьей фирмы и вашим. Следует оценить целесообразность как разработки собственного компонента, так и интеграции уже готового аналогичного компонента.

Использование CASE-средств
CASE-средства предоставляют много преимуществ. На одной чаше весов будет автоматизация работы, предоставляемая CASE, а на другой - ненавистная задача преобразования результатов анализа в формат этого CASE (если для формализации результатов анализа использовался другой CASE-инструмент или не использовался никакой). Некоторые CASE-средства позволяют непосредственно перейти к проектированию, а к анализу можно вернуться путем обратного проектирования. К сожалению, при использовании обратного проектирования в CASE-средстве создается весьма вредная иллюзия того, что данные анализа регистрируются, хотя на самом деле этого практически никогда не происходит, поскольку информация, содержащаяся в спроектированной структуре, отличается от результатов анализа. Некоторые полезные данные получить можно, но построить полную картину вряд ли удастся.

Инфраструктура
Для проектирования и реализации необходимы аппаратные ресурсы и специальное программное обеспечение. Кроме того, требуется механизм, позволяющий контролировать создаваемую документацию и код. Эти вопросы лучше решать на ранних стадиях проектирования, а не на стадии разработки. Мы поговорим об этом ниже, в разделе «Проектирование процессов и кода». При групповой разработке вам понадобятся средства контроля согласованности кода. Если разработка идет под разными платформами (аппаратная платформа и ОС), то хорошим решением может оказаться PVCS. Для платформ Windows 98, NT, 2000 может оказаться приемлемым решение, предлагаемое Microsoft - MS Source Save. Кроме того, многие средства разработки также предоставляют возможности контроля исходного кода.

Проектирование базы данных
Здесь мы изложим задачи, касающиеся проектирования реальной базы данных.

Построение модели данных
Работа проектировщиков базы данных в значительной степени зависит от качества информационной модели. Информационная модель не должна содержать никаких непонятных конструкций, которые нельзя реализовать в рамках выбранной СУБД. Следует отметить, что информационная модель создается для того, чтобы на ее основе можно было построить модель данных, то есть должна учитывать особенности реализации выбранной СУБД. Если те или иные особенности СУБД не позволяют отразить в модели данных то, что описывает информационная модель, значит, надо менять информационную модель, так как производитель СУБД вряд ли будет оперативно менять собственно СУБД ради вашего конкретного проекта (хотя и такие, правда единичные, случаи имели место).
Построение логической и физической моделей данных является основной частью проектирования базы данных. Полученная в процессе анализа информационная модель сначала преобразуется в логическую, а затем в физическую модель данных. После этого для разработчиков информационной системы создается пробная база данных. С ней начинают работать разработчики кода. В идеале к моменту начала разработки модель данных должна быть устойчива. Проектирование базы данных не может быть оторвано от проектирования модулей и приложений, поскольку бизнес-правила могут создавать объекты в базе данных, например серверные ограничения (constraints), а также хранимые процедуры и триггеры, - в этом случае часто говорят, что часть бизнес-логики переносится в базу данных. Проектирование модели данных для каждой СУБД содержит свои особенности, проектные решения, которые дают хороший результат для одной СУБД, но могут оказаться совершенно неприемлемыми для другой. Ниже перечислим задачи, которые являются общими для проектирования моделей данных:
выявление нереализуемых или необычных конструкций в ER-модели и в определениях сущностей; 
разрешение всех дуг, подтипов и супертипов; 
изучение возможных, первичных, внешних ключей, описание ссылочной целостности (в зависимости от реализации декларативно или с использованием триггеров); 
проектирование и реализация денормализации базы данных в целях повышения производительности; 
определение части бизнес-логики, которую следует реализовать в базе данных (пакеты, хранимые процедуры); 
реализация ограничений (ограничений и триггеров), отражающих все централизованно определенные бизнес-правила, генерация ограничений и триггеров; 
определение набора бизнес-правил, которые не могут быть заданы как ограничения в базе данных; 
определение необходимых индексов, кластеров (если таковые реализованы в СУБД), определение горизонтальной фрагментации таблиц (если это реализовано в СУБД); 
оценка размеров всех таблиц, индексов, кластеров; 
определение размеров табличных пространств и особенностей их размещения на носителях информации, определение спецификации носителей информации для промышленной системы (например, тип raid-массивов, их количество, какие табличные пространства на них размещаются), определение размеров необходимых системных табличных пространств (например, системного каталога, журнала транзакций, временного табличного пространства и т.п.); 
определение пользователей базы данных, их уровней доступа, разработка и внедрение правил безопасности доступа, аудита (если это необходимо), создание пакетированных привилегий (в зависимости от реализации СУБД это роли или группы), синонимов; 
разработка топологии базы данных в случае распределенной базы данных, определение механизмов доступа к удаленным данным. 
Подробнее на каждом из перечисленных пунктов мы остановимся в части «Схема базы данных».

Создание базы данных для разработчика
Чаще всего базу данных создает администратор баз данных - если он есть; в противном случае это приходится делать проектировщикам. Физическая база данных нужна разработчикам информационной системы для разработки кода, а проектировщикам для проверки их идей. Проектировщики и разработчики могут работать как с одной и той же схемой, так и с разными схемами. В процессе разработки проекта, как правило, создается несколько версий схемы базы данных. Следует обязательно вести журнал изменений схемы (вручную или в репозитарии case) и жестко контролировать версии схемы.

Проектирование процессов и кода
Параллельно с проектированием схемы базы данных требуется выполнить проектирование процессов, чтобы получить спецификации всех модулей. Если часть бизнес-логики хранится в базе данных (ограничения, триггеры, хранимые процедуры), то оба эти процесса проектирования тесно связаны. Главная цель проектирования заключается в отображении функций, полученных на этапе анализа, в модули информационной системы. Определения модулей раскрываются в технической спецификации программ. Возможно, что некоторые атомарные функции, полученные на этапе анализа, вообще не будут отображены в какие-либо модули, а будут преобразованы в ручные процедуры или принципы работы.

Выбор средств разработки
Не следует откладывать выбор средств разработки на самый последний момент. Если проектировщик не слишком хорошо представляет себе набор средств, которые будут использованы для разработки проекта, то следует для начала составить перечень возможных средств, затем провести консультации с техническими специалистами (хорошо знающими средства-кандидаты), оценить, с какими средствами персонал уже работал, а какие являются для них абсолютно новыми. Часто выбор средств разработки определяет именно фактор квалификации персонала.
Отображение функций на модули
На этапе анализа уже разработан перечень функций, которые будут реализованы. На этапе проектирования этот перечень еще раз анализируется и корректируется. Однозначное соответствие между функцией и модулем вряд ли возможно. Дело в том, что на этапе анализа функции организованы по бизнес-категориям, а на этапе проектирования их придется реорганизовывать для упрощения разработки. Проектировщики могут принять решение объединить несколько функций, обладающих общими свойствами, или выделить какое-то общее свойство (или их набор) в отдельный модуль, а также разбить сложную функцию на несколько модулей. Подробнее эти вопросы рассматриваются в разделе «Спецификации функций».

Интерфейсы программ
При проектировании модулей определяют разметку меню, вид окон, горячие клавиши и связанные с ними вызовы. Существуют два вида перемещения по программам:
с контекстом, когда целевая экранная форма частично или полностью заполняется автоматически данными, связанными с теми, что находятся в исходной экранной форме; 
без контекста, когда целевая экранная форма не заполняется вовсе или частично заполняется автоматически данными, не связанными с теми, что находятся в исходной экранной форме. 
Часто автоматически заполняемые данные экранной формы группируют (располагают рядом), а перемещение по заполняемым пользователем полям организуют так, как это делал бы сам пользователь, работая с реальным бумажным документом. Такие интерфейсы воспринимаются пользователем легче, и он намного быстрее осваивает новое ПО.

Интегрирование и наследование механизмов обмена данными
Информационная система редко разрабатывается с нуля. Чаще проектировщики сталкиваются с задачами наследования данных из старых систем, которые уже выполняют какие-либо задачи автоматизации бизнеса. Такие системы могут на начальном этапе быть интегрированы в новую систему и постепенно заменяться новыми, более современными модулями. Этот подход может навязываться руководством фирмы для того, чтобы ускорить ввод новой информационной системы. Следует рассмотреть все плюсы и минусы такой постепенной интеграции (минусов, как правило, оказывается больше). Одну операцию придется делать в любом случае: переносить ценные данные, хранящиеся в старой информационной системе, в новую, то есть проектировать механизмы конвертации данных. Возможно, что придется делать конвертацию данных не только из старой системы в новую, но и обратно (полную или частичную), поскольку возможен вариант развития событий, при котором старая и новая информационные системы будут работать параллельно - хотя бы в период опытной эксплуатации новой системы.
Кроме вопросов наследования собственно данных из старых информационных систем, возможно, вам придется также решать задачи взаимодействия вашего ПО с продуктами третьих фирм. В этом случае вам следует изучить интерфейсы обмена данными ПО других разработчиков и обеспечить должный уровень поддержки этих интерфейсов в разрабатываемой информационной системе.

Определение спецификаций модулей
Это основная часть функционального проектирования. Здесь решаются следующие задачи:
преобразование функциональных определений анализа в реализуемые модули; 
спецификации, которые выражают функциональные возможности каждого модуля в физических категориях; 
определение средств разработки для каждого модуля (или выделенных групп модулей), если используются несколько средств разработки в одном проекте; 
определение последовательности реализации модулей и зависимостей модулей. 
Спецификации модулей различают по степени детализации и содержанию даже в рамках одного проекта. Определяют, сколько времени требуется для того, чтобы сгенерировать тот или иной модуль, сколько необходимо на тестирование того или иного модуля, а также на тестирование совокупности сгенерированных модулей. Кроме того, следует разработать специальные метрики - шаблоны, которые позволяют оценить, сколько времени потребуется на создание исходного кода модуля. Для ускорения процесса разработки следует рассмотреть возможность использования генераторов исходного кода - это целесообразно, если вам предстоит разработать большое количество несложных модулей, а время разработки ограничено. Следует использовать шаблоны кода для устранения рутинных операций. Подробнее эти вопросы рассматриваются в разделе, посвященном спецификациям функций, - вы найдете его в одной из следующих статей данного цикла.
",1
40,Этапы разработки проекта4.docx,"Этапы разработки проекта: реализация, тестирование, эксплуатация и сопровождение
Реализация
Трудно давать советы по реализации кода модулей, так как каждый разработчик имеет какие-то привычки и свой стиль разработки кода. При реализации проекта важно координировать группу (группы) разработчиков. Все разработчики должны подчиняться жестким правилам контроля исходных тестов. Группа разработчиков, получив технический проект, начинает писать код модулей, и в этом случае основная задача состоит в том, чтобы уяснить спецификацию. Проектировщик указал, что необходимо сделать, а разработчик определяет способы выполнения.
На этапе разработки осуществляется тесное взаимодействие проектировщиков, разработчиков и групп тестеров. В случае интенсивной разработки тестер буквально «пристегивается» к разработчику, фактически являясь членом группы разработки.
Проектировщик на данном этапе выполняет функции «ходячего справочника», поскольку постоянно отвечает на вопросы разработчиков, касающиеся технической спецификации.
Чаще всего на этапе разработки меняются интерфейсы пользователя. Это обусловлено в том числе и тем, что модули периодически демонстрируются заказчику. Существенно могут меняться и запросы к данным.
Следует отметить, что для сборки всего проекта должно быть выделенное рабочее место. Именно эти модули передаются на тестирование. Взаимодействие тестера и разработчика без централизованной передачи частей проекта допустимо, но только в случае, если необходимо срочно проверить какую-то правку. Очень часто этап разработки и этап тестирования взаимосвязаны и идут параллельно. Синхронизирует действия тестеров и разработчиков система bug tracking.
При разработке должны быть организованы постоянно обновляемые хранилища готовых модулей проекта и библиотек, которые используются при сборке модулей. Желательно, чтобы процесс обновления хранилищ контролировал один человек. Одно из хранилищ должно быть предназначено для модулей, прошедших функциональное тестирование,  а другое - для модулей, прошедших тестирование связей. Первое из них - это черновики. Второе - то, из чего уже можно собирать дистрибутив системы и демонстрировать его заказчику для проведения контрольных испытаний или сдачи каких-либо этапов работ.
Документация создается в течение всего процесса разработки. Как только модуль прошел тестирование связей, его можно описывать в документации. В случае если модули изменяются часто, к описанию приступают только тогда, когда модуль становится более или менее стабильным.

Обработка результатов проектирования
На этапе разработки, как правило, еще раз проверяется атомарность функций, а также отсутствие их дублирования.
Желательно, чтобы на этапе проектирования уже была построена матрица «функции-сущности». Это фактически формализованное представление того, что фирма пытается сделать (функции) и какую информацию требуется обработать для достижения результата (сущности). Подобная матрица позволяет проверить следующие моменты:
имеет ли каждая сущность конструктор - функцию, создающую экземпляры сущности (create); 
есть ли ссылки на данную сущность, то есть используется ли где-либо данная сущность (references); 
имеют ли место изменения данной сущности (update); 
имеет ли каждая сущность деструктор - функцию, которая удаляет экземпляры сущности (delete). 
Часто роль деструктора выполняет комплект программ архивирования данных. Нередко в информационных системах информацию просто накапливают. Это допустимо лишь в том случае, если в течение всего периода накопления информации (а фактически в течение всей жизнедеятельности информационной системы) характеристики ее производительности удовлетворяют требованиям заказчика. На практике это чрезвычайно редкое стечение обстоятельств. Связано это в основном с ростом обрабатываемых объемов информации. Следует отметить, что надеяться в этом случае только на мощность СУБД или аппаратного обеспечения нельзя, так как подобные экстенсивные методы повышения производительности дают низкий расчетный прирост скорости. Фактически задача реагирования системы или отдельных ее частей на рост объема обрабатываемых данных является наиболее вероятной задачей тестирования. В таком случае группа тестирования создает модуль генерации (пусть даже абстрактных) данных, выбирается набор запросов, для которых скоростные характеристики критичны, далее производятся замеры и строится зависимость скорости выполнения от объема данных для каждого из запросов. Такое простое действие позволит избежать серьезных ошибок и в проектировании, и в реализации информационной системы.
Спецификация модулей должна быть выполнена еще на этапе проектирования, чему в реальных проектах зачастую просто не придают значения. И напрасно - ведь из-за непродуманной реализации модулей любые достоинства схемы базы данных могут быть утрачены. Так, пренебрегая спецификациями модулей, вы рискуете заложить в информационную систему:
неконтролируемый рост объемов данных; 
потоки запросов с изначально высокой вероятностью конфликта или потоки запросов, которые будут выполняться «вечно» (попытка выполнить поток, обнаружение конфликта и откат всех действий, новая попытка и т.д.) из-за конфликтующих с ними потоков; 
смешивание системных и интерфейсных модулей; 
дублирование модулей; 
ошибки в размещении бизнес-логики; 
отсутствие реализации или неполная реализация требуемых заказчиком функций системы. 
Это далеко не полный список проблем, которые будут обнаружены или на этапе комплексного тестирования, или при вводе системы в эксплуатацию, а может быть, даже в процессе эксплуатации системы (когда начнут реально использоваться модули).
Кроме того, отсутствие спецификаций модулей не позволит точно оценить сложность каждого модуля и, как следствие, определить последовательность создания модулей и правильно распределить нагрузку персонала. Обычная ситуация в подобном случае  -  «кто-то кого-то ждет», при этом процесс создания информационной системы стоит на месте.

Системные модули 
Часто приходится рассматривать большое количество обслуживающих или вспомогательных процессов, которые непосредственно не связаны со сформулированной бизнес-функцией. Как правило, это системные функции, имеющиеся в любой информационной системе, такие как:
диспетчер очередей или планировщик заданий; 
диспетчер печати; 
средства доступа к данным и создания нерегламентированных запросов (часто это генераторы отчетов); 
управление каталогами и иными ресурсами файловой системы; 
автоматическое резервное копирование; 
автоматическое восстановление после сбоя системы; 
средства регламентирования доступа пользователей к системе (состоящие из средства создания пользователей и средства назначения им привилегий); 
средство настройки среды для пользователя информационной системы; 
средство изменения пользователем своих настроек (в том числе и пароля); 
средство управления приложениями; 
среда администратора информационной системы. 
Часть этих функций должна выполнять операционная система, но если она будет работать в неоднородной среде, то нет гарантии, что пользователям придется по вкусу наличие различных интерфейсов в разных операционных системах. В идеале все приложения-клиенты должны работать в одной операционной системе, однако на практике разработчикам часто приходится сталкиваться с целым «зоопарком» различных рабочих станций у заказчика - итогом нескольких попыток автоматизировать бизнес. Цель разработчика - довести систему до максимально однородного состояния либо сделать похожими хотя бы рабочие места конечных пользователей.
Задача создания информационной системы в разнородной среде существенно повышает требования к разработчикам кода и к выбираемому средству разработки. Особенно это касается разработки системных модулей. Следует уделить внимание модулям, реализация кода которых зависит от операционной системы. Подобные модули должны быть выделены отдельно для каждой из операционных систем в группы, например Win98, WinNT и т.д. Модули каждой из групп должны иметь строгие интерфейсы обмена - данные, которые они передают и получают, строго определены, любое отклонение от спецификации наказуемо. Ни один из модулей вне этой группы не может использовать никаких других вызовов, кроме интерфейсов обмена. Таким образом модули, зависящие от операционнй системы, изолируются от других модулей.
Вообще говоря, практика изолирования системных модулей посредством строгой регламентации их интерфейсов обмена существенно минимизирует затраты по исправлению ошибок и поддержке системы. Кроме того, это облегчает и тестирование, а именно детектирование ошибок и их отладку. Другая сторона вопроса - требования к коду интерфейса обмена системных модулей резко повышаются. Это то, что отлаживается в первую очередь и должно работать очень четко.

Средства мониторинга информационной системы 
Если информационная система велика, то следует рассмотреть задачу ее администрирования с одной рабочей станции. Необходимо заботиться не только о конечном пользователе информационной системы, но и о персонале, который будет ее обслуживать. Особое внимание следует уделить мониторингу критических участков информационной системы, поскольку сбой зачастую проще предотвратить, чем исправлять его последствия. Мониторинг относится к тем задачам, о необходимости решения которых заказчик, как правило, не задумывается и которые обычно отсутствуют и в аналитическом исследовании, и даже при проектировании. Потребность в средствах мониторинга становится очевидной лишь на этапе ввода системы в эксплуатацию, причем потребность эта тем выше, чем сложнее система и чем больше в ней критических участков.
Разработчикам и проектироващикам следует проводить оценку сложности системы. Если принимается решение о написании комплексного средства администрирования и мониторинга, не предусмотренного техническим заданием, то в этом случае следует менять техническое задание, а не идти на поводу у заказчика. В сложной системе отслеживать критические процессы все равно придется. Внедрять подобные средства в уже готовую систему очень сложно, поскольку исходные данные мониторы часто получают от системных модулей достаточно низкого уровня. Без изменений схемы базы данных здесь тоже вряд ли можно будет обойтись, и нет никакой гарантии, что подобное изменение не ухудшит производительность системы.
Разработка мониторов - это довольно специфический класс задач: с одной стороны, они должны обрабатывать достаточный объем информации, с другой - не должны существенно влиять на работу других компонентов информационной системы. Это заставляет разработчиков с особой тщательностью подходить к проектированию мониторов и очень аккуратно писать код их модулей.

Интерфейсы 
Интерфейсы конечного пользователя - это то, что заказчик критикует в наибольшей степени, в силу того что именно эти части информационной системы он может более или менее квалифицированно оценить - обычно только их он и видит. Это означает, что интерфейсы являются наиболее часто изменяемым элементом информационной системы именно на этапе реализации.
Часто изменяемый компонент (компоненты) информационной системы следует изолировать от редко изменяемых компонентов,  чтобы одни изменения не влекли за собой другие. Один из приемов подобной изоляции - изоляция запросов  к данным от интерфейса следующим образом:
каждый из запросов кодируется идентификатором или «закрывается» определенной системной функцией; 
разработчик интерфейса не знает о запросе к данным ничего, кроме параметров атрибутов выборки - их типа и, возможно, количества строк в выборке; 
обработка ошибок в запросах данных представляет собой отдельный модуль; 
обработка ошибок в интерпретации результата запроса также представляет собой отдельный модуль. 
При обработке результатов запросов данных следует также особое внимание уделить вопросам соответствия типов включающего языка и СУБД, в том числе вопросам точности числовых типов, так как представление их у разных СУБД существенно различается. Кроме того, обратите внимание на запросы к данным, которые используют функции, зависящие от операционной системы, например функции работы с  байтами и словами значения атрибута (например, на Intel и SUN SPARC эти функции будут работать по-разному). Типы данных могут быть приведены или явно в запросе функциями приведения cast и встроенными в СУБД функциями, или в функции прикладной программы. Не для всех СУБД неявное преобразование типов дает один и тот же результат, поэтому если информационая система использует данные из нескольких баз данных под управлением разных СУБД, то неявных преобразований типов лучше избегать.
Следует также установить достаточно жесткие правила для внешнего вида интерфейсов пользователя. Должно создаваться впечатление единого стиля для всех компонентов информационной системы.

Версии базы данных 
Первую версию базы данных проекта в большинстве случаев создают достаточно быстро - это реализация полностью нормализованной структуры, которую получают на этапе анализа. Основным назначением этой базы данных является обеспечение макетирования, демонстрационных показов, некоторых экспериментов разработчиков и проектировщиков.
Скрипты создания базы данных и заполнения ее стартовыми данными - это тоже исходный код информационной системы, и на него распространяются правила контроля версий. Следует отметить, что поддерживать версии базы даных на уровне скриптов все же проще, чем на уровне средств выгрузки и загрузки данных, предоставляемых самой СУБД, так как в подавляющем большинстве случаев подобные средства не могут предоставить несколько простых, но необходимых функций:
проконтролировать, какие объекты данных и данные имеют место в объектах загрузки A и B, и загрузить в базу данных только «разницу» A и B (произвести обновление версии); 
проконтролировать, не конфликтуют ли изменения, имеющие место в объектах выгрузки C и D, по сравнению с объектом выгрузки A (произвести слияние версий). 
CASE-инструменты имеют средства контроля версий схемы базы данных, некоторые имеют настройки, позволяющие также контролировать и стартовые данные. Это дает возможность использовать указанные средства для обеспечения контроля версий базы данных.
Контроль версий исходного кода триггеров, хранимых процедур надежнее осуществлять путем использования той же системы контроля версий, что принята для хранения исходных текстов самого проекта.

Размещение логики обработки 
Одим из важных вопросов проектирования является способ размещения бизнес-логики обработки данных: размещать ее (и какую часть) либо на сервере в виде хранимых процедур, пакетов, триггеров, иных ограничений целостности непосредственно на сервере баз данных, либо в виде функций на клиенте (в составе ПО клиента). Местонахождение правил интерфейса и правил данных задано точно: первые всегда размещены на клиенте, вторые - на сервере. Правила бизнес-логики в современных СУБД могут быть размещены как на клиенте, так и на сервере. Рассмотрим один из примеров простейшего бизнес-правила:
Значение в поле экранной формы вводится пользователем, а не выбирается из списка, но набор допустимых значений строго ограничен (например, два или три различных значения). 
С одной стороны, пользователь требует немедленной реакции системы на ошибку ввода данных, с другой - недопустимы значения в поле базы данных, отличные от заданных (двух или трех). На самом деле в этой ситуации  должны быть реализованы два правила. Правило данных в этом случае будет организовано в виде ограничения check, а правило интерфейса, запрещающее вводить значения, отличные от заданных, будет в точности повторять правило даных, но будет реализовано на уровне интерфейса пользователя. Казалось бы, реализация формы со списком в этом случае является идеальным решением, но большинство операторов предпочитают именно набор в форме, особенно если длина вводимого значения невелика. Формы с большим количеством списков достаточно трудны для обработки конечными пользователями. В случае набора значений в форме следует также позаботиться о приведении регистров строк символов (там, где регистр не существенен) к верхнему или нижнему регистру, на уровне интерфейса прикладной программы.

Шаблоны 
Использование шаблонов и библиотек для построения «похожих» модулей - достаточно распространенная практика. Что использовать в этом случае - объекты и классы или библиотеки - решает конкретная группа разработчиков. Диктовать способ разработки в большинстве случаев бессмысленно, потому что разработчик пишет код так, как умеет или как привык. Эти моменты обычно контролирует руководитель проекта.
В любом проекте запрещается копирование кода, поскольку это ведет к возникновению различных версий одного и того же кода в разных фрагментах  прикладной программы и, как следствие, к сложно детектируемым и исправляемым ошибкам. Следует установить жесткое правило: используется вызов функции, а не его копия в коде; любое отклонение от данного правила наказуемо.

Тестирование 
Как было сказано выше, группы тестирования могут привлекаться уже на ранних стадиях разработки проекта. Собственно комплексное тестирование действительно следует выделять в отдельный этап разработки. В зависимости от сложности проекта тестирование и исправление ошибок могут занимать треть, половину и больше времени разработки всего проекта.
Чем сложнее проект, тем больше будет потребность в автоматизации системы хранения ошибок - bug tracking. Подобная система обеспечивает следующие функции:
хранение сообщения об ошибке (с обязательной информацией о том, к какому компоненту системы относится ошибка, кто ее нашел, как ее воспроизвести, кто отвечает за ее исправление и когда она должна быть исправлена); 
система уведомления о появлении новых ошибок, об изменении статуса известных в системе ошибок (как правило, это уведомления по электронной почте); 
отчеты об актуальных ошибках по компонентам системы, по интервалам времени, по группам разработчиков и разработчикам; 
информация об истории ошибки (в том числе отслеживание похожих ошибок, отслеживание повторного возникновения ошибки); 
правила доступа к ошибкам тех или иных категорий; 
интерфейс ограниченного доступа к системе bug tracking для конечного пользователя информационной системы, который используется как интерфейс обмена информацией между пользователем и службой технической поддержки системы. 
Подобные системы снимают множество организационных проблем, в частности вопросы автоматического уведомления об ошибках.
Собственно тесты систем можно разделить на несколько категорий:
автономные тесты модулей - используются уже на этапе разработки компонентов системы и позволяют отслеживать ошибки отдельных компонентов; 
тесты связей компонентов системы - используются и на этапе разработки, и на этапе тестирования и позволяют отслеживать правильность взаимодействия и обмена информацией компонентов системы; 
системный тест - является основным критерием приемки системы. Как правило, это группа тестов, включающая в себя и автономные тесты, и тесты связей и модели. Данный тест должен воспроизводить работу всех компонентов и функций системы, его основная цель - внутренняя приемка системы и оценка ее качества; 
приемо-сдаточный тест - используется при сдаче системы заказчику. Здесь разработчики часто занижают требования к системе по сравнению с системным тестом, и в общем-то понятно, почему это оправданно; 
тесты производительности и нагрузки - входят в системный тест, но достойны отдельного упоминания, так как именно эта группа тестов является основной для оценки надежности системы. 
В тесты каждой группы обязательно входят тесты моделирования отказов. Здесь проверяется реакция компонента, группы компонентов, системы в целом на отказы следующего типа:
отказ отдельного компонента информационной системы; 
отказ группы компонентов информационной системы; 
отказ основных модулей информационной системы; 
отказ операционной системы; 
«жесткий» сбой (отказ питания, жестких дисков). 
Эти тесты позволяют оценить качество подсистемы восстановления корректного состояния информационной системы и служат основным источником информации для разработки стратегий предотвращения негативных последствий сбоев при промышленной эксплуатации. Как правило, это тот класс тестов, которым разработчики пренебрегают, а затем борются с последствиями сбоев на промышленной системе.
Еще одним важным моментом программы тестирования информационных систем является наличие генераторов тестовых данных. Они используются для проведения как тестов функциональности системы, так и тестов надежности системы, а также тестов производительности системы. Задача оценки характеристик зависимости производительности информационной системы от роста объемов обрабатываемой информации не может быть решена без генераторов данных.

Эксплуатация и сопровождение 
Опытная эксплуатация перекрывает процесс тестирования. Как правило, система вводится в эксплуатацию не полностью, постепенно.
Ввод в эксплуатацию проходит по крайней мере три фазы:
первоначальная загрузка информации; 
накопление информации; 
выход на проектную мощность. 
Первоначальная загрузка информации инициирует довольно узкий круг ошибок - в основном это проблемы рассогласования данных при загрузке и собственные ошибки загрузчиков, то есть то, что не было отслежено на тестовых данных. Подобные ошибки должны быть исправлены как можно быстрее. Не поленитесь поставить отладочную версию системы (если, конечно, вам позволят развернуть весь комплекс сопровождающего отладку информационной системы ПО на месте). Если отладку «на живых» данных производить невозможно, то придется моделировать ситуацию, причем быстро. Здесь требуются очень квалифицированные тестеры.
В период накопления информации  проявится наибольшее количество ошибок, допущенных при создании информационной системы.   Как правило, это ошибки, связанные с многопользовательским доступом. Часто на этапе тестирования таким ошибкам не уделяется должного внимания - видимо, из-за сложности моделирования и дороговизны средств автоматизации процесса тестирования информационной системы в условиях многопользовательского доступа . Некоторые ошибки исправить будет довольно сложно, так как они являются ошибками проектирования. Ни один самый хороший проект от них не застрахован. Это значит, что на всякий случай надо резервировать время на локализацию и исправление таких ошибок.
Вторая категория исправлений связана с тем, что пользователя не устраивает интерфейс. Здесь не всегда нужно выполнять абсолютно все пожелания пользователя, иначе процесс ввода в эксплуатацию не кончится никогда.
В период накопления информации можно столкнуться со знаменитым «упала база». При самом плохом раскладе окажется, что СУБД не выдерживает потока информации. При хорошем - просто параметры конфигурации неверны. Первый случай опасен, так как повлиять на производителя СУБД довольно сложно, а заказчик очень не любит ссылок на службу технической поддержки СУБД. Решать проблему отказа СУБД придется не производителю, а вам - менять схему, снижать поток запросов, менять сами запросы; в общем - вариантов много. Хорошо, если время восстановления базы вписывается в запланированное.
Выход системы на проектную мощность при удачном стечении обстоятельств - это исправление ряда мелких ошибок, и изредка - ошибок серьезных.

Другие подходы к разработке приложений 
Как правило, конечные пользователи и руководство полагают, что процесс проектирования не дал никаких результатов, поскольку  отсутствуют готовые компоненты, которые можно было бы «пощупать». Зачастую заказчик настаивает на досрочном проведении этапа реализации проекта, для того чтобы как можно быстрее получить какой-то результат и продемонстрировать его. В таком случае существует большой соблазн выбрать ускоренную разработку приложений (УРП) или совместную разработку приложений (СРП). Подобные методы предусматривают разработку рабочего прототипа с последующей демонстрацией его пользователям. Пользователи отмечают, что им нравится, а что - нет. Проектировщик дорабатывает прототип с учетом сделанных замечаний, после чего снова демонстрирует то, что получилось. И так далее. Процесс повторяется до тех пор, пока пользователям не понравится то, что они видят, а прототип не станет рабочим приложением. Обычно устанавливается лимит времени и количество итераций, иначе пользователи будут совершенствовать прототип вечно. Теоретически это позволяет получить ту систему, которая требуется пользователям. На практике подобный подход к разработке приложений сопряжен с серьезными проблемами.
Все внимание сконцентрировано на экранных формах, а то, что касается правил обработки данных и системных функций, остается за кадром. Есть соблазн начать работу с отчетов, в то время как отчет является не стартовым, а производным продуктом информационной системы. 
Пользователи полагают, что если вариант прототипа согласован, то модуль готов. На самом деле это может быть всего лишь картинка с набором «заглушек» для вызовов системных функций и взаимодействия с другими модулями. 
Модули проектируются изолированно друг от друга (наверное, большинство из вас сталкивались с бухгалтерскими программами, где каждый АРМ является автономным и функции часто дублируются). Следствием этого являются противоречия модулей, дублирование функций и данных, что может быть выявлено только при тестировании комплекса модулей. 
Функциональные возможности наращиваются параллельно в нескольких направлениях, значит, структура базы данных должна контролироваться жестко. При УРП схема базы данных превращается в свалку, где таблицы «лепятся» наскоро, в результате чего имеет место набор противоречивых и дублирующихся данных. 
Документация при использовании метода УРП, как правило, отсутствует, а вернее, о необходимости документировать систему забывают, поскольку создается иллюзия, что пользователь и без того понимает, что происходит. Когда же приложение начинает работать не так, как предполагает пользователь, возникает масса проблем. 
Обработка исключительных ситуаций для каждого модуля производится своя. 
Целостная система, как правило, не получается, скорее всего, это будет некий набор автоматизированных рабочих мест, наскоро связанных между собой. 
Методы УРП и СРП можно использовать далеко не всегда, а лишь в том случае, если:
объем проекта и требования бизнеса четко определены, не изменяются, а сам проект невелик; 
проект не зависит от других средств автоматизации бизнеса, количество внешних интерфейсов, с которыми придется иметь дело, ограниченно; 
система ориентирована на экранные формы, обработка данных и системные функции составляют незначительную часть, удобство экранных форм входит в пятерку важнейших факторов успеха проекта; 
пользователи имеют высокую квалификацию и априори положительно оценивают идею создания нового ПО. 
Тем не менее методом УРП лучше разрабатывать небольшие и, желательно, автономные части проекта.
В настоящее время предпринята попытка представить еще один способ быстрого написания проекта - метод экстремального программирования.  Ниже будут рассмотрены принципы данного подхода.
Этап планирования (planning game). На основании оценок, сделанных программистами, заказчик определяет функциональные возможности и срок реализации версий системы. Программисты реализуют только те функции, которые необходимы для возможностей, выбранных на данной итерации.
В результате такого решения «за кадром» остается развитие системы, вследствие чего при разработке возникает необходимость строить «заглушки» и переписывать код. Непонятно, почему срок реализации определяет заказчик, ведь на самом деле это прямая обязанность группы проектировщиков. Заказчик, вообще говоря, может лишь выразить свои пожелания по поводу сроков («хочу, чтобы к такому-то числу»), но определить срок может только проектировщик («выполнимо не меньше чем за такое-то время»).
Частая смена версий (small releases). Систему запускают в эксплуатацию уже через несколько месяцев после начала реализации, не дожидаясь окончательного разрешения всех поставленных проблем. Выпуск новых версий может происходить с периодичностью от ежедневного до ежемесячного.
Все хорошо, кроме одного: протестировать за такой срок более или менее сложный компонент невозможно. Заказчик фактически выступает в роли бета-тестера. В этом случае он может видеть, что разработчики трудятся и даже ошибки исправляют. Однако возникают резонные вопросы: стоит ли посвящать заказчика в рабочий процесс и нужно ли ставить эксперименты на рабочей системе? В дополнение к сказанному необходимо отметить, что подобный принцип вряд ли может быть реализован для частей проекта, которые требуют работы в режиме 24x7.
Метафора (metaphor). Общий вид системы определяется при помощи метафоры или набора метафор, над которыми совместно работают заказчик и программисты.
С одной стороны, этот постулат кажется неплохим, а с другой - имеет ли смысл посвящать заказчика во внутренние дела группы разработчиков? То, что касается общего вида (интерфейсы, отчеты и т.п.), действительно может находиться в компетенции заказчика,  но когда речь идет об особенностях реализации тех или иных компонентов, заказчик вряд ли может быть полезен из-за отсутствия у него необходимых знаний.
Простой проект (simple design). В каждый момент времени разрабатываемая система выполняет все тесты и поддерживает все взаимосвязи, определяемые программистом, не имеет дубликатов кода и содержит минимально возможное количество классов и методов. Это правило кратко можно выразить так: «Каждую мысль формулируй один и только один раз».
Эта мысль тоже хороша, но она не вполне согласуется с принципом быстрого написания кода. Может быть, стоит все-таки сначала подумать, как делать тот или иной модуль, группу модулей, и лишь потом заняться написанием кода?
Тесты (tests). Программисты постоянно пишут тесты для модулей (unit tests). Собранные вместе, эти тесты должны работать корректно. Для этапов в итерации заказчики пишут функциональные тесты (functional tests),  которые также должны работать правильно. Однако на практике это не всегда достижимо. Чтобы принять правильное решение, необходимо понять, во сколько обойдется сдача системы с заранее известным дефектом, и сравнить это с ценой задержки на исправление дефекта.
При написании тестов самими программистами (особенно в условиях сверхурочных работ) эти тесты не полнофункциональны, и уж тем более не учитывают особенностей многопользовательской работы. На более продвинутые тесты у разработчиков обычно не хватает времени. Можно, конечно, построить систему разработки так, что всем будут заниматься одни и те же люди, но все-таки не стоит превращать проект в аналог телепередачи «Сам себе режиссер». К сказанному необходимо добавить, что тестирование системы вовсе не исчерпывается тестами компонентов (units); не менее важны тесты взаимодействия между ними, это же относится и к тестам надежности работы. И тем не менее метод экстремального программирования не предусматривает создания тестов данного класса. Это объясняется тем, что сами такие тесты могут представлять достаточно сложный код (особенно это касается тестов-имитаторов реальной работы системы). В данной технологии также никак не учитывается еще один важный класс тестов - тесты поведения системы при росте объемов обрабатываемой информации. При высокой скорости изменения версий выполнить такой тест технологически невозможно, поскольку его проведение требует стабильного и неизменного кода проекта, например, в течение недели. Подобные сроки, вообще говоря, не гарантируются из-за частой смены версий. В таком случае придется или приостанавливать разработку компонентов, или на время проведения теста создавать параллельную версию проекта, которая будет сохраняться неизменной, тогда как вторая при этом будет изменяться. Потом нужно будет выполнять процесс слияния кода. Но в этом случае тест придется создавать снова, так как методы экстремального программирования просто не предусматривают разработку средств, позволяющих прогнозировать поведение системы при тех или иных изменениях.
Переработка системы (refactoring). Архитектура системы постоянно эволюционирует. Текущий проект трансформируется, при этом гарантируется правильное выполнение всех тестов.
Вот тут-то и начинается самое интересное. Экстремальное программирование исходит из того, что переделать всегда можно, причем без особых затрат. Однако практика свидетельствует об обратном.
Программирование в паре (pair programming). Весь код проекта пишут два человека, которые используют одну настольную систему.
Возникает вопрос: кто-нибудь видел двух  совершенно одинаковых программистов, каждый из которых к тому же в конце рабочего дня успевал бы писать документацию для напарника?  Можно ли найти таких программистов-близнецов, согласных во всем?
А главное, зачем нужна такая пара программистов? Причина, в общем-то, простая: не все выдерживают навязываемый при экстремальном программировании высокий темп работ, неизбежен отток персонала. Подобная пара может дать некую страховку - если уволится один, то, может быть, второй доведет дело до конца. Правда, оставшийся попадет в еще более жесткие временные рамки - ведь объем работ останется прежним же, а дублера уже не будет, по крайней мере какое-то время. Далее следует естественный процесс передачи информации новому дублеру, что опять-таки требует времени. И так без конца.
Непрерывная интеграция (continuous integration). Новый код интегрируется в существующую систему не позднее, чем через несколько часов. После этого система вновь собирается в единое целое и прогоняются все тесты. Если хотя бы один из них не выполняется корректно, внесенные изменения отменяются.
Этот постулат предоставляется по меньшей мере спорным, поскольку непонятно, кто будет исправлять ошибки, причем не только локальные, но и наведенные неправильным кодом. Ведь проведение комплексных тестов не предполагается на данном этапе, кроме того, изменения остаются даже в том случае, когда ошибка детектирована. В то же самое время метод экстремального программирования не предусматривает наличия системы отслеживания ошибок.
Коллективное владение (collective ownership). Каждый программист имеет возможность в любое время усовершенствовать любую часть кода в системе, если сочтет это необходимым.
Вам это анархию не напоминает? Как в этом случае искать автора изменений? Встречал ли кто-либо при разработке большого проекта такого «на все руки доку»  и сколько подобный «умелец»  сумел бы продержаться на своем рабочем месте? Правильно, не слишком долго.
Заказчик с постоянным участием (on-site customer). Заказчик, который в период работы над системой находится в команде разработчиков.
Это, конечно, хорошо, но непонятна цель: то ли посвятить заказчика в суть дела, то ли сделать его соавтором? Вряд ли только у заказчика найдется столь высококвалифицированный специалист.
40-часовая неделя (40-hour weeks). Объем сверхурочных работ не может превышать по длительности одну рабочую неделю. Даже отдельные случаи сверхурочных работ, повторяющиеся слишком часто, являются сигналом серьезных проблем, которые требуют безотлагательного решения.
Как показывает практика применения экстремального программирования (несмотря на целый ряд положительных примеров, приводимых сторонниками данного метода), сверхурочные при таком подходе - это правило, а не исключение, и борьба с проблемами в данном случае - явление постоянное. Усиливается она в период замены текущей сырой версии продукта очередной, опять же сырой, версией. Заказчик, посвященный в процесс, испытывает все прелести проявления ошибок работы системы на себе. Как вы думаете, надолго ли хватит у заказчика терпения при таком положении дел? Ему ведь надо, чтобы система работала...
Открытое рабочее пространство (open workspace). Команда разработчиков располагается в большом помещении, окруженном комнатами меньшей площади. В центре рабочего пространства устанавливаются компьютеры, на которых работают пары программистов.
Причем все это, судя по предыдущим принципам, должно располагаться на территории заказчика, раз он весьма активно привлекается к процессу разработки. Возникает вопрос: реально ли столь удачное стечение обстоятельств?
Не более чем правила (just rules). Члены коллектива, работающего по технологии экстремального программирования, обязуются выполнять изложенные правила. Однако это не более чем правила и команда может в любой момент поменять их, если ее члены достигли принципиального соглашения по поводу внесенных изменений.
Может быть, в конце концов и будет выработано одно полезное правило: «сначала подумай, потом сделай». В этом случае мы будем иметь схему, весьма похожую на «водопад». Почему-то сторонники экстремального программирования убеждены, что при использовании «водопада» и его клонов цикл разработки обязательно должен быть длинным. Непонятно, чем обусловлена такая уверенность. Ведь не запрещено дробить проект на этапы. Почему-то считается, что планирование обязательно будет одноразовым и неизменным, хотя на самом деле это не соответствует истине, в том числе и в случае «водопада».
В итоге мы получаем метод, потенциально обладающий высокой адаптируемостью к сильно изменяющимся требованиям к проекту, но в то же время не свободный от ряда серьезных недостатков. Последнее обстоятельство не позволяет рекомендовать данный метод к применению для проектов, требующих высокой или как минимум достаточной надежности работы.
",1
30,Этапы разработки проекта5.docx,"Этапы разработки проекта: стратегия и анализ
Введение
Проектирование информационных систем всегда начинается с определения цели проекта. Основная задача любого успешного проекта заключается в том, чтобы на момент запуска системы и в течение всего времени ее эксплуатации можно было обеспечить:
требуемую функциональность системы и степень адаптации к изменяющимся условиям ее функционирования; 
требуемую пропускную способность системы; 
требуемое время реакции системы на запрос; 
безотказную работу системы в требуемом режиме, иными словами - готовность и доступность системы для обработки запросов пользователей; 
простоту эксплуатации и поддержки системы; 
необходимую безопасность. 
Производительность является главным фактором, определяющим эффективность системы. Хорошее проектное решение служит основой высокопроизводительной системы.
Проектирование информационных систем охватывает три основные области:
проектирование объектов данных, которые будут реализованы в базе данных; 
проектирование программ, экранных форм, отчетов, которые будут обеспечивать выполнение запросов к данным; 
учет конкретной среды или технологии, а именно: топологии сети, конфигурации аппаратных средств, используемой архитектуры (файл-сервер или клиент-сервер), параллельной обработки, распределенной обработки данных и т.п. 
В реальных условиях проектирование - это поиск способа, который удовлетворяет требованиям функциональности системы средствами имеющихся технологий с учетом заданных ограничений.
К любому проекту предъявляется ряд абсолютных требований, например максимальное время разработки проекта, максимальные денежные вложения в проект и т.д. Одна из сложностей проектирования состоит в том, что оно не является такой структурированной задачей, как анализ требований к проекту или реализация того или иного проектного решения.
Считается, что сложную систему невозможно описать в принципе. Это, в частности, касается систем управления предприятием. Одним из основных аргументов является изменение условий функционирования системы, например директивное изменение тех или иных потоков информации новым руководством. Еще один аргумент - объемы технического задания, которые для крупного проекта могут составлять сотни страниц, в то время как технический проект может содержать ошибки. Возникает вопрос: а может, лучше вообще не проводить обследования и не делать никакого технического проекта, а писать систему «с чистого листа» в надежде на то, что произойдет некое чудесное совпадение желания заказчика с тем, что написали программисты, а также на то, что все это будет стабильно работать?
Если разобраться, то так ли уж непредсказуемо развитие системы и действительно ли получить информацию о ней невозможно? Вероятно, представление о системе в целом и о предполагаемых (руководством) путях ее развития можно получить посредством семинаров. После этого разбить сложную систему на более простые компоненты, упростить связи между компонентами, предусмотреть независимость компонентов и описать интерфейсы между ними (чтобы изменение одного компонента автоматически не влекло за собой существенного изменения другого компонента), а также возможности расширения системы и «заглушки» для нереализуемых в той или иной версии системы функций. Исходя из подобных элементарных соображений описание того, что предполагается реализовать в информационной системе, уже не кажется столь нереальным. Можно придерживаться классических подходов к разработке информационных систем, один из которых - схема «водопада» (рис. 1) - описан ниже. Кратко будут рассмотрены и некоторые другие подходы к разработке информационных систем, где использование элементов, описанных в схеме «водопада», также допустимо. Какого подхода из описываемых ниже придерживаться (и есть ли смысл придумывать собственный подход) - в какой-то мере дело вкуса и обстоятельств.
Жизненный цикл программного обеспечения представляет собой модель его создания и использования. Модель отражает его различные состояния, начиная с момента возникновения необходимости в данном ПО и заканчивая моментом его полного выхода из употребления у всех пользователей. Известны следующие модели жизненного цикла:
Каскадная модель. Переход на следующий этап означает полное завершение работ на предыдущем этапе. 
Поэтапная модель с промежуточным контролем. Разработка ПО ведется итерациями с циклами обратной связи между этапами. Межэтапные корректировки позволяют уменьшить трудоемкость процесса разработки по сравнению с каскадной моделью; время жизни каждого из этапов растягивается на весь период разработки. 
Спиральная модель. Особое внимание уделяется начальным этапам разработки - выработке стратегии, анализу и проектированию, где реализуемость тех или иных технических решений проверяется и обосновывается посредством создания прототипов (макетирования). Каждый виток спирали предполагает создание некой версии продукта или какого-либо его компонента, при этом уточняются характеристики и цели проекта, определяется его качество и планируются работы следующего витка спирали. 
Ниже мы рассмотрим некоторые схемы разработки проекта.

«Водопад» - схема разработки проекта
Очень часто проектирование описывают как отдельный этап разработки проекта между анализом и разработкой. Однако в действительности четкого деления этапов разработки проекта нет - проектирование, как правило, не имеет явно выраженного начала и окончания и часто продолжается на этапах тестирования и реализации. Говоря об этапе тестирования, также следует отметить, что и этап анализа, и этап проектирования содержат элементы работы тестеров, например для получения экспериментального обоснования выбора того или иного решения, а также для оценки критериев качества получаемой системы. На этапе эксплуатации уместен разговор и о сопровождении системы.
Ниже мы рассмотрим каждый из этапов, подробнее остановившись на этапе проектирования.

Стратегия
Определение стратегии предполагает обследование системы. Основная задача обследования - оценка реального объема проекта, его целей и задач, а также получение определений сущностей и функций на высоком уровне.
На этом этапе привлекаются высококвалифицированные бизнес-аналитики, которые имеют постоянный доступ к руководству фирмы; этап предполагает тесное взаимодействие с основными пользователями системы и бизнес-экспертами. Основная задача взаимодействия - получить как можно более полную информацию о системе (полное и однозначное понимание требований заказчика) и передать данную информацию в формализованном виде системным аналитикам для последующего проведения этапа анализа. Как правило, информация о системе может быть получена в результате бесед или семинаров с руководством, экспертами и пользователями. Таким образом определяются суть данного бизнеса, перспективы его развития и требования к системе.
По завершении основной стадии обследования системы технические специалисты формируют вероятные технические подходы и приблизительно рассчитывают затраты на аппаратное обеспечение, закупаемое программное обеспечение и разработку нового программного обеспечения (что, собственно, и предполагается проектом).
Результатом этапа определения стратегии является документ, где четко сформулировано, что получит заказчик, если согласится финансировать проект; когда он получит готовый продукт (график выполнения работ); сколько это будет стоить (для крупных проектов должен быть составлен график финансирования на разных этапах работ). В документе должны быть отражены не только затраты, но и выгода, например время окупаемости проекта, ожидаемый экономический эффект (если его удается оценить).
В документе обязательно должны быть описаны:
ограничения, риски, критические факторы, влияющие на успешность проекта, например время реакции системы на запрос является заданным ограничением, а не желательным фактором; 
совокупность условий, при которых предполагается эксплуатировать будущую систему: архитектура системы, аппаратные и программные ресурсы, предоставляемые системе, внешние условия ее функционирования, состав людей и работ, которые обеспечивают бесперебойное функционирование системы; 
сроки завершения отдельных этапов, форма сдачи работ, ресурсы, привлекаемые в процессе разработки проекта, меры по защите информации; 
описание выполняемых системой функций; 
будущие требования к системе в случае ее развития, например возможность работы пользователя с системой с помощью Интернета и т.п.; 
сущности, необходимые для выполнения функций системы; 
интерфейсы и распределение функций между человеком и системой; 
требования к программным и информационным компонентам ПО, требования к СУБД (если проект предполагается реализовывать для нескольких СУБД, то требования к каждой из них, или общие требования к абстрактной СУБД и список рекомендуемых для данного проекта СУБД, которые удовлетворяют заданным условиям); 
что не будет реализовано в рамках проекта. 
Выполненная на данном этапе работа позволяет ответить на вопрос, стоит ли продолжать данный проект и какие требования заказчика могут быть удовлетворены при тех или иных условиях. Может оказаться, что проект продолжать не имеет смысла, например из-за того, что те или иные требования не могут быть удовлетворены по каким-то объективным причинам. Если принимается решение о продолжении проекта, то для проведения следующего этапа анализа уже имеются представление об объеме проекта и смета затрат.
Следует отметить, что и на этапе выбора стратегии, и на этапе анализа, и при проектировании независимо от метода, применяемого при разработке проекта, всегда следует классифицировать планируемые функции системы по степени важности. Один из возможных форматов представления такой классификации - MoSCoW - предложен в Clegg, Dai and Richard Barker, Case Method Fast-track: A RAD Approach, Adison-Wesley, 1994.
Эта аббревиатура расшифровывается так: Must have - необходимые функции; Should have - желательные функции; Could have - возможные функции; Won’t have - отсутствующие функции.
Функции первой категории обеспечивают критичные для успешной работы системы возможности.
Реализация функций второй и третьей категорий ограничивается временными и финансовыми рамками: разрабатываем то, что необходимо, а также максимально возможное в порядке приоритета число функций второй и третьей категорий.
Последняя категория функций особенно важна, поскольку необходимо четко представлять границы проекта и набор функций, которые будут отсутствовать в системе.

Анализ
Этап анализа предполагает подробное исследование бизнес-процессов (функций, определенных на этапе выбора стратегии) и информации, необходимой для их выполнения (сущностей, их атрибутов и связей (отношений)). На этом этапе создается информационная модель, а на следующем за ним этапе проектирования - модель данных.
Вся информация о системе, собранная на этапе определения стратегии, формализуется и уточняется на этапе анализа. Особое внимание следует уделить полноте переданной информации, анализу информации на предмет отсутствия противоречий, а также поиску неиспользуемой вообще или дублирующейся информации. Как правило, заказчик не сразу формирует требования к системе в целом, а формулирует требования к отдельным ее компонентам. Уделите внимание согласованности этих компонентов.
Аналитики собирают и фиксируют информацию в двух взаимосвязанных формах:
функции - информация о событиях и процессах, которые происходят в бизнесе; 
сущности - информация о вещах, имеющих значение для организации и о которых что-то известно. 
Двумя классическими результатами анализа являются:
иерархия функций, которая разбивает процесс обработки на составные части (что делается и из чего это состоит); 
модель «сущность-связь» (Entry Relationship model, ER-модель), которая описывает сущности, их атрибуты и связи (отношения) между ними. 
Эти результаты являются необходимыми, но не достаточными. К достаточным результатам следует отнести диаграммы потоков данных и диаграммы жизненных циклов сущностей. Довольно часто ошибки анализа возникают при попытке показать жизненный цикл сущности на диаграмме ER.
Ниже мы рассмотрим три наиболее часто применяемые методологии структурного анализа:
диаграммы «сущность-связь» (Entity-Relationship Diagrams, ERD), которые служат для формализации информации о сущностях и их отношениях; 
диаграммы потоков данных (Data Flow Diagrams, DFD), которые служат для формализации представления функций системы; 
диаграммы переходов состояний (State Transition Diagrams, STD), которые отражают поведение системы, зависящее от времени; диаграммы жизненных циклов сущностей относятся именно к этому классу диаграмм. 

ER-диаграммы
ER-диаграммы (рис. 2) используются для разработки данных и представляют собой стандартный способ определения данных и отношений между ними. Таким образом, осуществляется детализация хранилищ данных. ER-диаграмма содержит информацию о сущностях системы и способах их взаимодействия, включает идентификацию объектов, важных для предметной области (сущностей), свойств этих объектов (атрибутов) и их отношений с другими объектами (связей). Во многих случаях информационная модель очень сложна и содержит множество объектов.
Сущность изображается в виде прямоугольника, вверху которого располагается имя сущности (например, TITLES). В прямоугольнике могут быть перечислены атрибуты сущности; атрибуты ER-диаграмм, набранные полужирным шрифтом1, являются ключевыми (так Title Identity - ключевой атрибут сущности TITLES, остальные атрибуты ключевыми не являются).
Отношение изображается линией между двумя сущностями (синие линии на рисунке).
Одиночная линия справа (рис. 3) означает «один», «птичья лапка» слева - «многие», а отношение читается вдоль линии, например «один ко многим». Вертикальная черта означает «обязательно», кружок - «не обязательно», например для каждого издания в TITLE обязательно должен быть указан издатель в PUBLISHERS, а один издатель в PUBLISHERS может выпускать несколько наименований изданий в TITLES. Следует отметить, что связи всегда комментируются (надпись на линии, изображающей связь).

Рис. 3. Элемент ER-диаграммы
Приведем также пример (рис. 4) изображения рефлексивного отношения «сотрудник», где один сотрудник может руководить несколькими подчиненными и так далее вниз по иерархии должностей.
Следует обратить внимание на то, что такое отношение всегда является необязательным, в противном случае это будет бесконечная иерархия.
Атрибуты сущностей могут быть ключевыми - они выделяются полужирным шрифтом; обязательными - перед ними ставится знак «*», то есть их значение всегда известно, необязательными (optional) - перед ними ставится О, то есть значения этого атрибута в какие-то моменты могут отсутствовать или быть неопределенными.

Дуги
Если сущность имеет набор взаимоисключающих отношений с другими сущностями, то говорят, что такие отношения находятся в дуге. Например, банковский счет может быть оформлен или для юридического лица, или для физического лица. Фрагмент ER-диаграммы для такого типа отношений приведен на рис. 5.
В этом случае атрибут ВЛАДЕЛЕЦ сущности СЧЕТ имеет особое значение для данной сущности - сущность делится на типы по категориям: «для физического лица» и «для юридического лица». Полученные в результате сущности называют подтипами, а исходная сущность становится супертипом. Чтобы понять, нужен супертип или нет, надо установить, сколько одинаковых свойств имеют различные подтипы. Следует отметить, что злоупотребление подтипами и супертипами является довольно распространенной ошибкой. Изображают их так, как показано на рис. 6.

Нормализация
Чтобы не допустить аномалий при обработке данных, используют нормализацию. Принципы нормализации для объектов информационной модели в точности такие же, как и для моделей данных.
Допустимые типы связей. При ближайшем рассмотрении связи типа «один к одному» (рис. 7) почти всегда оказывается, что A и B представляют собой в действительности разные подмножества одного и того же предмета или разные точки зрения на него, просто имеющие отличные имена и по-разному описанные связи и атрибуты.
Связи «многие к одному» представлены на рис. 8.
I - достаточно сильная конструкция, предполагающая, что вхождение сущности B не может быть создано без одновременного создания по меньшей мере одного связанного с ним вхождения сущности A.
II - это наиболее часто встречающаяся форма связи. Она предполагает, что каждое и любое вхождение сущности A может существовать только в контексте одного (и только одного) вхождения сущности B. В свою очередь, вхождения B могут существовать как в связи с вхождениями A, так и без нее.
III - применяется редко. Как A, так и B могут существовать без связи между ними.
Связи «многие ко многим» представлены на рис. 9.
I - такая конструкция часто имеет место в начале этапа анализа и означает связь - либо понятую не до конца и требующую дополнительного разрешения, либо отражающую простое коллективное отношение - двунаправленный список.
II - применяется редко. Такие связи всегда подлежат дальнейшей детализации.
Рассмотрим теперь рекурсивные связи (рис. 10).
I - редко, но имеет место. Отражает связи альтернативного типа.
II - достаточно часто применяется для описания иерархий с любым числом уровней.
III - имеет место на ранних этапах. Часто отражает структуру «перечня материалов» (взаимная вложенность компонентов). Пример: каждый КОМПОНЕНТ может состоять из одного и более (других) КОМПОНЕНТОВ и каждый КОМПОНЕНТ может использоваться в одном и более (других) КОМПОНЕНТОВ.
Недопустимые типы связей. К недопустимым типам связей относятся следующие: обязательная связь «многие ко многим» (рис. 11) и ряд рекурсивных связей (рис. 12).
Обязательная связь «многие ко многим» в принципе невозможна. Такая связь означала бы, что ни одно из вхождений A не может существовать без B, и наоборот. На деле каждая подобная конструкция всегда оказывается ошибочной.

Диаграммы потоков данных 
Логическая DFD (рис. 13) показывает внешние по отношению к системе источники и стоки (адресаты) данных, идентифицирует логические функции (процессы) и группы элементов данных, связывающие одну функцию с другой (потоки), а также идентифицирует хранилища (накопители) данных, к которым осуществляется доступ. Структуры потоков данных и определения их компонентов хранятся и анализируются в словаре данных. Каждая логическая функция (процесс) может быть детализирована с помощью DFD нижнего уровня; когда дальнейшая детализация перестает быть полезной, переходят к выражению логики функции при помощи спецификации процесса (мини-спецификации). Содержимое каждого хранилища также сохраняют в словаре данных, модель данных хранилища раскрывается с помощью ER-диаграмм.
В частности, в DFD не показываются процессы, которые управляют собственно потоком данных и не приводятся различия между допустимыми и недопустимыми путями. DFD содержат множество полезной информации, а кроме того:
позволяют представить систему с точки зрения данных; 
иллюстрируют внешние механизмы подачи данных, которые потребуют наличия специальных интерфейсов; 
позволяют представить как автоматизированные, так и ручные процессы системы; 
выполняют ориентированное на данные секционирование всей системы. 
Потоки данных используются для моделирования передачи информации (или даже физических компонентов) из одной части системы в другую. Потоки на диаграммах изображаются именованными стрелками, стрелки указывают направление движения информации. Иногда информация может двигаться в одном направлении, обрабатываться и возвращаться в ее источник. Такая ситуация может моделироваться либо двумя различными потоками, либо одним двунаправленным.
Процесс преобразует входной поток данных в выходной в соответствии с действием, задаваемым именем процесса. Каждый процесс должен иметь уникальный номер для ссылок на него внутри диаграммы. Этот номер может использоваться совместно с номером диаграммы для получения уникального индекса процесса во всей модели.
Хранилище данных (data storage) позволяет на ряде участков определять данные, которые будут сохраняться в памяти между процессами. Фактически хранилище представляет «срезы» потоков данных во времени. Информацию, которую оно содержит, можно использовать в любое время после ее определения, при этом данные могут выбираться в произвольном порядке. Имя хранилища должно идентифицировать его содержимое. В случае когда поток данных входит (выходит) в (из) хранилище и его структура соответствует структуре хранилища, он должен иметь то же самое имя, которое нет необходимости отражать на диаграмме.
Внешняя сущность (терминатор) представляет сущность вне контекста системы, являющуюся источником или приемником системных данных. Ее имя должно содержать существительное, например «Клиент». Предполагается, что объекты, представленные такими узлами, не должны участвовать ни в какой обработке.

Диаграммы изменения состояний STD
Жизненный цикл сущности относится к классу STD-диаграмм (рис. 14). Эта диаграмма отражает изменение состояния объекта с течением времени. Например, рассмотрим состояние товара на складе: товар может быть заказан у поставщика, поступить на склад, храниться на складе, проходить контроль качества, может быть продан, забракован, возвращен поставщику. Стрелки на диаграмме показывают допустимые изменения состояний.
Существует несколько различных вариантов изображения подобных диаграмм, на рисунке приведен лишь один из них.

Некоторые принципы проверки качества и полноты информационной модели 
(источник - Richard Barker, Case Method: Entity Relationship Modelling, Addison-Wesley, 1990)
Если вы хотите создать качественную модель, то придется прибегать к помощи аналитиков, хорошо владеющих CASE-технологией. Однако это не означает, что построением и контролем информационной модели должны заниматься только аналитики. Помощь коллег также может оказаться весьма полезной. Привлекайте их к проверке поставленной цели и к детальному изучению построенной модели как с точки зрения логики, так и с точки зрения учета аспектов предметной области. Большинство людей легче находят недостатки в чужой работе.
Регулярно представляйте вашу информационную модель или ее отдельные фрагменты, относительно которых у вас возникают сомнения, на одобрение пользователей. Особое внимание уделяйте исключениям из правил и ограничениям.

Качество сущностей
Основной гарантией качества сущности является ответ на вопрос, действительно ли объект является сущностью, то есть важным объектом или явлением, информация о котором должна храниться в базе данных.
Список проверочных вопросов для сущности:
Отражает ли имя сущности суть данного объекта? 
Нет ли пересечения с другими сущностями? 
Имеются ли хотя бы два атрибута? 
Всего атрибутов не более восьми? 
Есть ли синонимы/омонимы данной сущности? 
Сущность определена полностью? 
Есть ли уникальный идентификатор? 
Имеется ли хотя бы одна связь? 
Существует ли хотя бы одна функция по созданию, поиску, корректировке, удалению, архивированию и использованию значения сущности? 
Ведется ли история изменений? 
Имеет ли место соответствие принципам нормализации данных? 
Нет ли такой же сущности в другой прикладной системе, возможно, под другим именем? 
Не имеет ли сущность слишком общий смысл? 
Достаточен ли уровень обобщения, воплощенный в ней? 
Список проверочных вопросов для подтипа:
Отсутствуют ли пересечения с другими подтипами? 
Имеет ли подтип какие-нибудь атрибуты и/или связи? 
Имеют ли они все свои собственные уникальные идентификаторы или наследуют один на всех от супертипа? 
Имеется ли исчерпывающий набор подтипов? 
Не является ли подтип примером вхождения сущности? 
Знаете ли вы какие-нибудь атрибуты, связи и условия, отличающие данный подтип от других? 

Качество атрибутов
Следует выяснить, а действительно ли это атрибуты, то есть описывают ли они тем или иным образом данную сущность.
Список проверочных вопросов для атрибута:
Является ли наименование атрибута существительным единственного числа, отражающим суть обозначаемого атрибутом свойства? 
Не включает ли в себя наименование атрибута имя сущности (этого быть не должно)? 
Имеет ли атрибут только одно значение в каждый момент времени? 
Отсутствуют ли повторяющиеся значения (или группы)? 
Описаны ли формат, длина, допустимые значения, алгоритм получения и т.п.? 
Не может ли этот атрибут быть пропущенной сущностью, которая пригодилась бы для другой прикладной системы (уже существующей или предполагаемой)? 
Не может ли он быть пропущенной связью? 
Нет ли где-нибудь ссылки на атрибут как на «особенность проекта», которая при переходе на прикладной уровень должна исчезнуть? 
Есть ли необходимость в истории изменений? 
Зависит ли его значение только от данной сущности? 
Если значение атрибута является обязательным, всегда ли оно известно? 
Есть ли необходимость в создании домена для этого и ему подобных атрибутов? 
Зависит ли его значение только от какой-то части уникального идентификатора? 
Зависит ли его значение от значений некоторых атрибутов, не включенных в уникальный идентификатор? 

Качество связи
Нужно выяснить, отражают ли связи действительно важные отношения, наблюдаемые между сущностями.
Список проверочных вопросов для связи:
Имеется ли ее описание для каждой участвующей стороны, точно ли оно отражает содержание связи и вписывается ли в принятый синтаксис? 
Участвуют ли в ней только две стороны? 
Не является ли связь переносимой?
Заданы ли степень связи и обязательность для каждой стороны? 
Допустима ли конструкция связи? 
Не относится ли конструкция связи к редко используемым?
Не является ли она избыточной? 
Не изменяется ли она с течением времени? 
Если связь обязательная, всегда ли она отражает отношение к сущности, представляющей противоположную сторону? 
Для исключающей связи:
Все ли концы связей, покрываемые исключающей дугой, имеют один и тот же тип обязательности? 
Все ли из них относятся к одной и той же сущности? 
Обычно дуги пересекают разветвляющиеся концы - что вы можете сказать о данном случае? 
Связь может покрываться только одной дугой. Так ли это? 
Все ли концы связей, покрываемые дугой, входят в уникальный идентификатор? 

Функции системы
Часто аналитикам приходится описывать достаточно сложные бизнес-процессы. В этом случае прибегают к функциональной декомпозиции, которая показывает разбиение одного процесса на ряд более мелких функций до тех пор, пока каждую из них уже нельзя будет разбить без ущерба для смысла. Конечный продукт декомпозиции представляет собой иерархию функций, на самом нижнем уровне которой находятся атомарные с точки зрения смысловой нагрузки функции. Приведем простой пример (рис. 15) такой декомпозиции. Рассмотрим простейшую задачу выписки счета клиенту при отпуске товара со склада при условии, что набор товаров, которые хочет приобрести клиент, уже известен (не будем рассматривать в данном примере задачу выбора товаров).
Очевидно, что операция выбора и расчета скидок может быть также разбита на более мелкие операции, например на расчет скидок за приверженность (клиент покупает товары в течение долгого времени) и на расчет скидок за количество покупаемого товара. Атомарные функции описываются подробно, например с помощью DFD и STD. Очевидно, что такое описание функций не исключает и дополнительное словесное описание (например, комментарии).
Следует отметить, что на этапе анализа следует уделить внимание функциям анализа и обработки возможных ошибок и отклонений от предполагаемого эталона работы системы. Следует выделить наиболее критичные для работы системы процессы и обеспечить для них особенно строгий анализ ошибок. Обработка ошибок СУБД (коды возврата), как правило, представляет собой обособленный набор функций или одну-единственную функцию.

Уточнение стратегии
На этапе анализа происходит уточнение выбранных для конечной реализации аппаратных и программных средств. Для этого могут привлекаться группы тестирования, технические специалисты. При проектировании информационной системы важно учесть и дальнейшее развитие системы, например рост объемов обрабатываемых данных, увеличение интенсивности потока запросов, изменение требований надежности информационной системы.
На этапе анализа определяются наборы моделей задач для получения сравнительных характеристик тех или иных СУБД, которые рассматривались на этапе определения стратегии для реализации информационной системы. На этапе определения стратегии может быть осуществлен выбор одной СУБД. Данных о системе на этапе анализа уже намного больше, и они более подробны. Полученные данные, а также характеристики, переданные группами тестирования, могут показать, что выбор СУБД на этапе определения стратегии был неверным и что выбранная СУБД не может удовлетворять тем или иным требованиям информационной системы. Такие же данные могут быть получены относительно выбора аппаратной платформы и операционной системы. Получение подобных результатов инициирует изменение данных, полученных на этапе определения стратегии, например пересчитывается смета затрат на проект.
Выбор средств разработки также уточняется на этапе анализа. В силу того что этап анализа дает более полное представление об информационной системе, чем оно было на этапе определения стратегии, план работ может быть скорректирован. Если выбранное на предыдущем этапе средство разработки не позволяет выполнить ту или иную часть работ в заданный срок, то принимается решение об изменении сроков (как правило, это увеличение срока разработки) или о смене средства разработки. Осуществляя выбор тех или иных средств, следует учитывать наличие высококвалифицированного персонала, который владеет выбранными средствами разработки, а также наличие администраторов выбранной СУБД. Эти рекомендации также будут уточнять данные этапа выбора стратегии (совокупность условий, при которых предполагается эксплуатировать будущую систему).
Уточняются также ограничения, риски, критические факторы. Если какие-либо требования не могут быть удовлетворены в информационной системе, реализованной с использованием СУБД и программных средств, выбранных на этапе определения стратегии, то это также инициирует уточнение и изменение получаемых данных (в конечном итоге сметы затрат и планов работ, а возможно, и изменение требований заказчика к системе, например их ослабление). Более подробно описываются те возможности, которые не будут реализованы в системе.
",1
22,Язык манипуляции данными.docx,"2.1.3. Язык манипуляции данными (ЯМД)
Язык манипуляции данными (ЯМД) обеспечивает эффективные команды манипуляции сетевой системой базы данных. ЯМД позволяет пользователям выполнять над базой данных операции в целях получения информации, создания отчетов, а также обновления и изменения содержимого записей. 
Основные команды ЯМД можно классифицировать следующим образом: команды передвижения, команды извлечения, команды обновления записей, команды обновления наборов. 
Табл.2. Основные типы команд ЯМД. 
Заключение 
Процесс преобразования функциональной модели в реляционную включает создание реляционной таблицы для каждого объектного множества модели. Атрибуты объектного множества становятся атрибутами реляционной таблицы. Если в функциональной модели существует ключевой атрибут, то он может использоваться в качестве ключа реляционной таблицы. В противном случае ключевой атрибут таблицы может быть создан аналитиком. Однако, лучше всего, если такой атрибут естественным образом возникает из моделируемого приложения. Отношения один-к-одному и один-ко-многим преобразуются в реляционную модель путем превращения их в атрибуты соответствующей таблицы. Отношения многие-ко-многим соответствуют многозначным атрибутам и преобразуются в четвертую нормальную форму путем создания ключа из двух столбцов, соответствующих ключам двух объектных множеств, участвующих в отношении. Конкретизирующие множества преобразуются путем создания отдельных реляционных таблиц, ключи которых совпадают с ключами обобщающих объектных множеств. Рекурсивные отношения также можно смоделировать, создав новое смысловое имя атрибута, обозначающее отношение. 

2.2. Архитектуры реализации корпоративных информационных систем.
При построении корпоративных информационных сетей, как правило, используются две базовые архитектуры: Клиент-сервер и Интернет/Интранет. В чем же преимущества и недостатки использования каждой из данных архитектур и когда их применение оправдано? Найти ответы на эти вопросы мы постараемся в данном разделе. 
Одной из самых распространенных на сегодня архитектур построения корпоративных информационных систем является архитектура КЛИЕНТ-СЕРВЕР. 
В реализованной по данной архитектуре информационной сети клиенту предоставлен широкий спектр приложений и инструментов разработки, которые ориентированы на максимальное использование вычислительных возможностей клиентских рабочих мест, используя ресурсы сервера в основном для хранения и обмена документами, а также для выхода во внешнюю среду. Для тех программных систем, которые имеют разделение на клиентскую и серверную части, применение данной архитектуры позволяет лучше защитить серверную часть приложений, при этом, предоставляя возможность приложениям либо непосредственно адресоваться к другим серверным приложениям, либо маршрутизировать запросы к ним. Средством (инструментарием) для реализации клиентских модулей для ОС Windows в данном случае является, как правило, Delpfi. 
Однако при этом частые обращения клиента к серверу снижают производительность работы сети, кроме этого приходится решать вопросы безопасной работы в сети, так как приложения и данные распределены между различными клиентами. Распределенный характер построения системы обуславливает сложность ее настройки и сопровождения. Чем сложнее структура сети, построенной по архитектуре КЛИЕНТ-СЕРВЕР, тем выше вероятность отказа любого из ее компонентов. 
В последнее время все большее развитие получает архитектура Интернет/Интранет. В основе реализации корпоративных информационных систем на базе данной архитектуры лежит принцип ""открытой архитектуры"", что во многом определяет независимость реализации корпоративной системы от конкретного производителя. Все программное обеспечение таких систем реализуется в виде аплетов или сервлетов (программ написанных на языке JAVA) или в виде cgi модулей (программ написанных как правило на Perl или С). 
Основными экономическими преимуществами данной архитектуры являются: 
относительно низкие затраты на внедрение и эксплуатацию; 
высокая способность к интеграции существующих гетерогенных информационных ресурсов корпораций; 
повышение уровня эффективности использования оборудования (сохранение инвестиций). 
прикладные программные средства доступны с любого рабочего места, имеющего соответствующие права доступа; 
минимальный состав программно-технических средств на клиентском рабочем месте (теоретически необходима лишь программа просмотра - броузер и общесистемное ПО); 
минимальные затраты на настройку и сопровождение клиентских рабочих мест, что позволяет реализовывать системы с тысячами пользователей (причем многие из которых могут работать за удаленными терминалами). 
В общем случае АИС, реализованная с использованием данной архитектуры включает Web-узлы с интерактивным информационным наполнением, реализованных при помощи технологий Java, JavaBeans и JavaScript, взаимодействующих с предметной базой данных, с одной стороны, и с клиентским местом с другой. База данных, в свою очередь, является источником информации для интерактивных приложений реального времени. 
По запросу клиента WEB узел осуществляет следующие операции (рис.7): 
Отправляет ASCII коды HTML страниц (или VRML документов), включающие при необходимости элементы javaScript; 
Отсылает двоичный код запрошенного ресурса (изображения, адио-, видеофайла, архива и т.п.); 
Отсылает байт коды JAVA апплетов. 
Принимает конкретную информацию от пользователя (результат заполнения активной формы, или статистическую информацию запрошенную CGI скриптом); 
Осуществляет заполнение базы данных; 
Принимает сообщения от пользователя и регламентирует доступ к ресурсам Web узла на основе анализа принятой информации (проверка паролей и т.п.); 
Принимает информацию от пользователя и в зависимости от нее динамически формирует HTML страницы, либо VRML документы, обращаясь, при необходимости, к базам данных и существующим на WEB узле HTML страницам и VRML документам.
После того, как клиент получил ответ WEB сервера, он осуществляет следующие операции: 
визуализирует HTML страницу либо VRML документ в окне броузера; 
интерпретирует команды JavaScript, модифицирует образ HTML страницы и т.п.; 
интерпретируя байт коды JAVA апплетов, позволяет загружать и выполнять активные приложения; 
ведет диалог с пользователем, заполняющим формы, и создает новые запросы к WEB серверу; 
с помощью утилит воспроизводит коды аудио и видео файлов, поддерживает мультимедийные средства; 
обеспечивает моделирование виртуальной реальности просматривая VRML документы.
Перечисленные задачи WEB клиента обеспечиваются возможностями броузера и специализированным программным обеспечением (утилитами), размещенными на рабочей станции клиента. Следует отметить и тот факт, что жестких стандартов на построение WEB клиента пока нет и его компонентный состав может различаться. 
На сегодняшний день известны и широко применяются три основных технологии создания интерактивного взаимодействия с пользователем в Web. Первый путь заключается в использовании Стандартного Интерфейса Шлюза (Commom Gateway Interface) - CGI. Второй - включение JavaScript - сценариев в тело Web-страниц. И наконец самый мощный, предоставляющий практически неограниченные возможности способ - применение технологии Java (ипользование Java-аплетов). 
CGI - это механизм для выбора, обработки и форматирования информации. Возможность взаимодействия, обеспечиваемая CGI, предоставляется во многих формах, но в основном это динамический доступ к информации, содержащейся в базах данных. Например, многие узлы применяют CGI для того, чтобы пользователи могли запрашивать базы данных и получать ответы в виде динамически сформированных Web-страниц (рис.17). 
Имеются в виду узлы, предоставляющие доступ к базам данных, средствам поиска, и даже информационные системы, предающие сообщения в ответ на ввод пользователя. Все эти узлы используют CGI, чтобы принять ввод пользователя и передать его с сервера Web базе данных. База данных обрабатывает запрос и возвращает ответ серверу, который в свою очередь пересылает его опять броузеру для отображения. Без СGI база данных этого не смогла бы. Данный интерфейс можно считать посредником между броузером, сервером и любой информацией которая должна передаваться между ними. 
В отличии от HTML, CGI не является языком описания документов. Собственно, это и не язык вообще; это стандарт. Он просто определяет, как серверы Web передают информацию, используя приложения, исполняемые на сервере. Это способ расширения возможностей сервера Web без преобразования при этом его самого. Подобно тому как броузер Web обращается к вспомогательным приложениям для обработки информации, которую он не понимает, CGI предоставляет серверу Web возможность преложить работу на другие приложения, такие как базы данных и средства поиска. 
При написании программы шлюза (которая может конвертировать ввод из одной системы в другую) CGI позволяет использовать почти любой язык программирования. Способность использовать при написании программы шлюза любой язык, даже язык сценариев, чрезвычайно важна. Самыми популярными языками являются shell, Perl, C и С++. Сценарием традиционно называют программу, которая выполняется с помощью интерпретатора, выполняющего каждую строку программы по мере ее считывания. 
Последовательность действий при взаимодействии клиента с программой запущенной на Web-сервере можно сформулировать как следующая последовательность шагов. 
Броузер принимает введенную пользователем информацию, как правило с помощью форы. 
Броузер помещает введенную пользователем информацию в URL, указывающий имя и местоположение сценария CGI, который требуется ввести в действие. 
Броузер подключается к серверу Web и запрашивает URL. Сервер определяет, что URL должен ввести в действие сценарий CGI, и запускает указанный сценарий. 
Сценарий CGI выполняется, обрабатывая все передаваемые ему данные. 
Сценарий CGI динамически формирует Web-страницу и возвращает результат серверу. 
Сервер возвращает результат клиенту. 
Броузер отображает результат пользователю 
Это является упрощенной схемой взаимодействия между броузером, сервером и сценарием CGI. Наибольшую популярность CGI - сценарии нашли при использовании в качестве обработчиков форм, средства доступа к базам данных, средства осуществления локального и глобального поиска, шлюзовых протоколов. 
Наибольшей мощью в реализации клиентского программного обеспечения обладают аплеты - программы написанные на языке JAVA. В узком смысле слова Java - это объектно-ориентированный язык, напоминающий C++, но более простой для освоения и использования. В более широком смысле Java - это целая технология программирования, изначально рассчитанная на интеграцию с Web-сервисом, то есть на использование в сетевой среде. Поскольку Web-навигаторы существуют практически для всех аппаратно-программных платформ, Java-среда должна быть как можно более мобильной, в идеале полностью независимой от платформы. 
С целью решения перечисленных проблем были приняты, помимо интеграции с Web-навигатором, два других важнейших постулата. 
Была специфицирована виртуальная Java-машина (JVM), на которой должны выполняться (интерпретироваться) Java-программы. Определены архитектура, представление элементов данных и система команд Java-машины. Исходные Java-тексты транслируются в коды этой машины. Тем самым, при появлении новой аппаратно-программной платформы в портировании будет нуждаться только Java-машина; все программы, написанные на Java, пойдут без изменений. 
Определено, что при редактировании внешних связей Java-программы и при работе Web-навигатора прозрачным для пользователя образом может осуществляться поиск необходимых объектов не только на локальной машине, но и на других компьютерах, доступных по сети (в частности, на WWW-сервере). Найденные объекты загружаются, а их методы выполняются затем на машине пользователя. 
Несомненно, между двумя сформулированными положениями существует тесная связь. В компилируемой среде трудно абстрагироваться от аппаратных особенностей компьютера, как трудно (хотя и можно) реализовать прозрачную динамическую загрузку по сети. С другой стороны, прием объектов извне требует повышенной осторожности при работе с ними, а, значит, и со всеми Java-программами. Принимать необходимые меры безопасности проще всего в интерпретируемой, а не компилируемой среде. Вообще, мобильность, динамизм и безопасность - спутники интерпретатора, а не компилятора. 
Принятые решения делают Java-среду идеальным средством разработки интерактивных клиентских компонентов (апплетов) Web-систем. Особо отметим прозрачную для пользователя динамическую загрузку объектов по сети. Из этого вытекает такое важнейшее достоинство, как нулевая стоимость администрирования клиентских систем, написанных на Java. Достаточно обновить версию объекта на сервере, после чего клиент автоматически получит именно ее, а не старый вариант. Без этого реальная работа с развитой сетевой инфраструктурой практически невозможна. 
Стандартный реляционный доступ к данным очень важен для программ на Java, потому что Java-апплеты по природе своей не являются монолитными, самодостаточными программами. Будучи модульными, апплеты должны получать информацию из хранилищ данных, обрабатывать ее и записывать обратно для последующей обработки другими апплетами. Монолитные программы могут себе позволить иметь собственные схемы обработки данных, но Java-апплеты, пересекающие границы операционных систем и компьютерных сетей, нуждаются в опубликовании открытых схем доступа к данным. 
Интерфейс JDBC (Java Database Connectivity - связанность баз данных Java) является первой попыткой реализации доступа к данным из программ Java, не зависящего от платформы и базы данных. В версии JDK 1.1 JDBC является составной частью основного Java API. 
JDBC - это набор реляционных объектов и методов взаимодействия с источниками данных. Программа на языке Java открывает связь с таблицей, создает объект оператор, передает через него операторы SQL системе управления базой данных получает результаты и служебную информацию о них. В типичном случае файлы .class JDBC и апплет/приложение на языке Java находятся на компьютере клиенте. Хотя они могут быть загружены из сети, для минимизации задержек во время выполнения лучше иметь классы JDBC у клиента. Система управления базой данных (CУБД) и источник данных обычно расположены на удаленном сервере. 
На рисунке 19 показаны различные варианты реализаций связи JDBC с базой данных. Апплет/приложение взаимодействует с JDBC в системе клиента, драйвер отвечает за обмен информацией с базой данных через сеть. 
Классы JDBC находятся в пакете java.sql.*. Все программы Java используют объекты и методы из этого пакета для чтения и записи в источник данных. Программе, использующей JDBC, требуется драйвер к источнику данных, с которым она будет взаимодействовать. Этот драйвер может быть написан на другом (не Java) языке программирования, или он может являться программой на языке Java, которая общается с сервером, используя RPC (Remote Procedure Call) - удаленный вызов процедур или HTTP. Обе схемы приведены на рис.19. Драйвер JDBC может быть библиотекой на другом (не Java), как программа сопряжения ODBC - JDBC, или классом Java, который общается через сеть с сервером базы данных, используя RPC или HTTP. 
Допускается, что приложение будет иметь дело с несколькими источниками данных, возможно, с неоднородными. По этой причине у JDBC есть диспетчер драйверов, чьи обязанность заключаются в управлении драйверами и предоставлении программе списка загруженных драйверов. 
Хотя словосочетание ""База данных"" входит в расшифровку аббревиатуры JDBC, форма, содержание и расположение данных не интересуют программу Java, использующую JDBC, поскольку существует драйвер к этим данным. 

Сопряжение JDBC - ODBC 
В качестве составной части JDBC поставляется драйвер для доступа из JDBC к источникам данных ODBC (Open Database Connectivity), и называется ""программа сопряжения JDBC - ODBC"". Эта программа сопряжения реализована в виде JdbcOdbc.class и является библиотекой для доступа к драйверу ODBC. 
Поскольку JDBC конструктивно близок к ODBC, программа сопряжения является несложной надстройкой над JDBC. На внутреннем уровне этот драйвер отображает методы Java в вызовы ODBC и тем самым взаимодействует с любым ODBC - драйвером. Достоинство такой программы сопряжения состоит в том, что JDBC имеет доступ к любым базам данных, поскольку ODBC - драйверы распространены очень широко. 
В соответствии с правилами Internet JDBC идентифицирует базу данных при помощи URL, который имеет форму: 
jdbc:<субпротокол>:<имя, связанное с СУБД или Протоколом> 
У баз данных в Internet/intranet ""имя"" может содержать сетевой URL 
//<имя хоста>:<порт>/.. 
<субпротокол> может быть любым именем, которое понимает база данных. Имя субпротокола ""odbc"" зарезервированно для источников данных формата ODBC. Типичный JDBC URL для базы данных ODBC выглядит следующим образом: 
jdbc:odbc:<DNS - имя ODBC>;User=<имя пользователя>; PW=<пароль> 

Внутреннее устройство JDBC - приложения 
Чтобы обработать информацию из базы данных, информационно-обучающая система на языке Java выполняет ряд шагов. На рис.20 показаны основные объекты JDBC, методы и последовательность выполнения, Во-первых, программа вызывает метод getConnection (), чтобы получить объект Connection.Затем она создает объект Statement и подготавливает оператор SQL. 
Оператор SQL может быть выполнен немедленно (объект Statement), а может быть откомпилирован (объект PreparedStatement) или представлен в виде вызова процедуры (объект CallableStatement). Когда выполняется метод executeQuery(), возвращается объект ResultSet. Операторы SQL, такие как updatе или delete не возвращают ResultSet. Для таких операторов используется метод executeUpdate(). Он возвращает целое, указывающее количество рядов, затронутых оператором SQL. 
ResultSet содержит ряды данных и анализируетcя методом next(). Если приложение обрабатывает транзакции, можно пользоваться методами rollback() и commit() для отмены или подтверждения изменений, внесенных оператором 
SQL. 

Примеры запроса и модификации базы данных с использованием JDBC 
Данный пример иллюстрирует как при помощи SQL - опрератора SELECT составляется список всех студентов из базы данных. Ниже приводятся шаги, которые необходимы для выполнения этого задания при помощи API JDBC. Каждый шаг имеет форму текста на языке Java с комментариями. 
// описать методы и переменные
public void ListStudents () throws SQLException
{
int i,  noOfColumns;
String stNo, stFName, stLName;
// инициализировать и загрузить драйвер JDBC-ODBC
Class.forName (""jdbc.odbc.JdbcOdbcDriver"");
// создать объект Connection
Connection ex1Con = DriverManager.getConnection (
""jdbc:odbc:StudentDB;uid=""admin"";pw=""sa"""");
// создать простой объект Statement
Statement ex1Stmt = ex1Con.createStatement ();
// Создать строку SQL, передать ее СУБД и
// выполнить SQL-оператор
ResultSet ex1rs = ex1Stmt.executeQuery (
""SELECT StudentNumber, FirstName, LastName FROM Students"");
// Обработать каждый ряд и вывести результат на консоль
System.out.println (""Student Number  First Name  Last Name"");
while (ex1rs.next())
{
stNo = ex1rs.getString (1);
stFName = ex1rs.getString (2);
stLName = ex1rs.getString (3);
System.out.println (stNo, stFName, stLName);
}
}
В следующем примере поле firstName таблицы Students изменяется. Доступ осуществляется через поле StudentNumber. 
// описать методы, переменные и параметры 
public void UpdateStudentName (String stFName, String stLName, String stNo) 
throws SQLException
{
int retValue;
//инициализировать и загрузить драйвер JDBC-ODBC
Class.forName (""jdbc.odbc.JdbcOdbcDriver"");
// создать объект Connection
Connection ex1Con = DriverManager.getConnection (
""jdbc:odbc:StudentDB;uid=""admin"";pw=""sa"""");
// создать простой объект Statement
Statement ex1Stmt = ex1Con.createStatement ();
// Создать строку SQL, передать ее СУБД и
// выполнить SQL-оператор
String SQLBuffer = ""UPDATE Students SET FirstName ="" +
stFName + "", lastName ="" + stLName +
""WHERE StudentNumber = "" + stNo;
retValue = ex1Stmt.executeUpdate (SQLBuffer);
System.out.println (""Модифицированно "" + retValue +
"" строк в базе данных."")
}
Рис.21. Интерфейс для регистрации пользователя в АИС. 
Таким образом, взаимодействие с базами данных из Java также отличается простотой и гибкостью, связанной с эффективной реализацией JDBC API. В сочетании со своей природной платформо-независимостью, Java предоставляет уникальный инструмент для создания интерактивных распределенных информационно-обучающих систем на база Internet/Intranet - технологий. 
Основными сложностями при реализации корпоративных систем на базе данной архитектуры являются: 
отсутствие многих популярных приложений и средств разработки реализованных в виде JAVA аплетов; 
относительное высокое время компиляции аплетов на клиентских местах (временно); 
вопросы безопасной работы в сети. 

2.2.1. Сравнительные исследования типовых серверных платформ.
Выбирая платформу для АИС, нужно учитывать множество аспектов. На решение влияют соображения, связанные с надежностью (кластеризация и балансировка нагрузки), среды разработки, работы над содержанием узла и защиты информации. Результаты тестирования различных платформ широко представлены в периодической печати, представим здесь лишь некоторые обобщения материалов тестирования []. 
При проведении испытаний оценивались Solaris 2.6, Windows NT Server 4 и Red Hat Linux 6.02 (ядро 2.2.11) при эксплуатации четырех web-серверов, занимающих ведущие позиции в мире: Microsoft Internet Information Server 4 (IIS), Netscape Enterprise Server 3.61, Web Server 2.1 корпорации Sun и Stronghold Web Server 2.4.1 (популярный вариант Web-сервера Apache с функциями защиты от несанкционированного доступа) (на тестах использовались триал версии указанного программного обеспечения). Все платформы были испытаны с помощью новой версии эталонного теста WebBench отделения Ziff-Davis Benchmark Operation. 

2.2.1.2. Особенности функционирования АИС на платформе Sun.
Solaris - это современная операционная система UNIX клона. Примечательно, что она, опережая свое время, позволяет работать с 64-разрядными прикладными программами и имеет собственные расширения, которые помогают ей выдерживать высокие пользовательские нагрузки Web-узлов с интенсивным обменом информацией. В Solaris также предусмотрены замечательные возможности применения серверных прикладных программ и средств разработки сторонних производителей. 
Ключевой момент для понимания различий между платформами Linux, Microsoft и Sun - способ, которым серверные программы каждой из них обрабатывают большое число подключений. Обычно это делается в многопотоковом режиме. Многопотоковый режим возникает, когда прикладная программа (также называемая процессом) содержит множество небольших блоков исполняемого кода, работающих независимо друг от друга и, возможно, одновременно на разных процессорах. Эти потоки могут совместно пользоваться ресурсами и представляют собой способ организации программы, позволяющий одновременно выполнять несколько задач. 
Модель потоков Solaris весьма сложна. Она состоит из потоков на уровне ядра (kthreads) - реальных объектов, передаваемых отдельному процессору; потоков на пользовательском уровне и промежуточной структуры, называемой облегченным (lightweight) процессом. Это позволяет тонко управлять структурой прикладной программы и реализации в ней прикладной многозадачности. 

Stronghhold на платформе Solaris 
Создатели Web-сервера Stronghold (и Apache, основы Stronghold) считают, что многопотоковые программы обычно менее надежны, чем ""монолитные"". Такое различие стратегий объясняет значительные расхождения показателей производительности, поскольку и Sun Web Server 2.1, и Netscape Enterprise используют второй процессор, установленный в испытательных системах. Поэтому Stronghold, в зависимости от прикладного ПО, не столь эффективно использует оборудование Sun, содержащее до 64 процессоров. 

Netscape на платформе Solaris 
Netscape Enterprise Server 3.61 - Web-сервер, избранный для реализации большинства крупных узлов на основе Solaris, в том числе и корпорации Sun. Инструментальные средства фирмы Netscape, а также предлагаемые независимыми производителями, способствуют разработке сложных прикладных программ для Web с помощью сценариев на языках JavaScript, CORBA, Java. 
Еще одна важнейшая система, стоящая за добротными программами для Web на серверах Netscape, - сервер прикладных программ Netscape Application Server (NAS). Сервер NAS - среда программирования для объектов на языках C++ и Java - обеспечивает масштабируемость и устойчивость к сбоям прикладных программ. В NAS имеются инструменты для создания многоуровневых программ, объединяющих HTML и запросы к базам данных на серверах NAS. 

Sun Web Server 
Sun Web Server (SWS) обеспечивает разработку программ, конечно же, на языке Java. На SWS можно использовать сервлеты и разнообразные возможности, такие как CORBA. Сервлеты (servlet) - это Java-программы, запускаемые на сервере и, подобно CGI, передающие сверстанные HTML-страницы браузеру. Для сервлет существует собственный API к функциям рабочей среды сервера. В SWS также предусмотрена возможность использования серверных Java-страниц (Java Server Pages) - способа обращения к серверным функциям Java со страниц Web и из CGI-программ. 
При соответствующем использовании Web-серверов на платформе Solaris, эта операционная система на многопроцессорных станциях превосходит по производительности Windows NT. Такого результата достигла Sun Microsystems благодаря использованию Solaris Network Cache and Accelerator (SNCA) - мощного механизма кэширования для Web-сервера. SWS победил в испытаниях при обслуживании статических страниц. При выполнении динамических CGI-испытаний Netscape на платформе Solaris превзошел и SWS, и IIS для Windows NT. 

2.2.1.3. Особенности функционирования АИС на платформе Microsoft.
Microsoft Windows NT Server 
Windows NT 4 Server и Internet Information Server (IIS) являются исключительно коммерческой web-платформой, разработанной компанией Microsoft. Данная ОС имеет удобный интуитивно понятный интерфейс взаимодействия с пользователем, что делает её довольно привлекательной для использования. Windows NT 4 Server оснащена службой балансировки нагрузки (Windows NT Load Balancing Services), которая позволяет создавать группу серверов и распределять нагрузку между ними. Пользователи при этом видят только один IP-адрес и полагают, что существует только один сервер. Однако служба Load Balancing Services - это неполноценная кластерная система, поэтому она не способна обеспечить такое высокое быстродействие, как настоящий кластер. Windows NT не может работать с мощными аппаратными и программными средствами кластеров, в том числе с собственной службой Microsoft Cluster Service, продуктами серии Infinity компании IBM и продуктами NonStop производства Compaq. У Microsoft есть продукты всех этапов разработки для Web, однако обычно их заменяют изделиями других фирм. Пакет Allaire ColdFusion 4.0, как среда разработки для Web, - отличный пример этого. 

Netscape Enterprise на платформе Windows NT 
Netscape Enterprise в среде Windows NT представляет собой Web-сервер, ориентированный на большие нагрузки. Для него имеется множество моделей программирования. Например, помимо общепринятых моделей разработки HTML и CGI в продукте Netscape предусмотрены возможности работы с JavaScript на стороне сервера. Почти все функции сервера Netscape для Solaris работают и на платформе Windows NT. 
При тестировании на производительность IIS показал неплохие результаты. Скорость при работе IIS достигнута за счет хорошо организованной обработкой файлового ввода-вывода. Дополняет обработку сообщений в Windows NT возможность асинхронного ввода-вывода, позволяющая обрабатывать запрос одновременно с выполнением операций ввода-вывода в файл или ЛВС. Подобная функция имеется в Solaris, но до сих пор не полностью реализована в Linux. По результатам теста IIS проигрывает SWW при обработке статических страниц, а Netscape Enterprise на платформе NT оказался менее производительным во всех режимах, чем на платформе Solaris. 

2.2.1.4. Особенности функционирования АИС на основе Linux.
Все больше растет популярность Linux и её респектабельность как платформы разработки для Web и корпоративных сред. Linux характеризуется рядом преимуществ, таких как широкое сообщество разработчиков открытого кода, поддержка многих моделей комплектующих, и, главная особенность состоит в том, что Linux полностью бесплатная ОС. Linux является разновидностью Unix и изначально создавалась для работы в сетях. В каждой новой версии Linux появляются некоторые усовершенствования, направленные на повышение масштабируемости и производительности серверных прикладных программ. 

Apache и Stronghold 
Для тестов в среде Linux был использован Stronghold Web Server 2.4.1 компании C2Net. Stronghold - это сервер с возможностями применения технологии SSL, в основе которого лежит Web-сервер Apache. Сервер Stronghold обладает всеми преимуществами Apache, в том числе мощными средствами обеспечения работы с виртуальными базовыми машинами (способность одного web-сервера обслуживать несколько машин одновременно). 
Платформа Stronghold, подобно Linux, имеет заслуженную репутацию надежной и стабильной системы. Но Stronghold - и, следовательно, Apache - не оптимизированы для многопроцессорных сред. Поэтому Web-узлы, основанные на серверах Apache, лучше масштабировать путем добавления серверов, а не процессоров. 
Напротив, IIS и Netscape Enterprise имеют многопотоковую архитектуру, которая масштабируется на несколько процессоров одного сервера. При испытаниях на многопроцессорных станциях они, как правило, обгоняли Stronghold. 
Apache позволяет тонко настраивать ряд параметров (такие как число процессов, доступных клиентам). Для Apache, как и для других серверов, есть механизм работы сервлетам (Apache Jserv). Механизм работы с сервлетами встраивается в Apache в виде модуля и работает с любой совместимой с JDK 1.1 виртуальной Java-машиной. По производительности дуэт Apache-Linux оказался оптимальным для однопроцессорных систем. По обработке статических страниц он немного уступал SWW и IIS, а по стабильности работы превосходил серверы на платформеWindows NT. 
Linux - это функциональность UNIX + пользовательско-ориентированный интерфейс Windows-систем. Большая часть поддерживаемого Linux оборудования - это то, что пользователи реально у себя имеют. Как в результате оказалось - большая часть популярной периферии для 80386/80486 поддерживается (действительно, Linux поддерживает оборудование, которое в ряде случаев не поддерживают некоторые коммерческие UNIX). Хотя некоторые достаточно экзотические устройства пока не поддерживаются. 
Важным вопросом при создании АИС является обеспечение жизнестойкости и надежности работы информационных серверов. В качестве иллюстрации эффективности платформы приведем расчет параметров для сервера с 25000 посетителей в день []. Подсчет загрузки: 24ч*60мин*60 сек=86400 секунд в сутках, если каждый посетитель берет с сервера по 10 документов (*.html + графика) то при равномерном распределении загрузки получается 3 обращения к серверу в секунду. Реальное распределение трафика носит характер кривой Гаусса либо синусоиды (в зависимости от содержания сервера), в максимумах которых загрузка достигает 10-20 обр/с. Для нормальной работы такому серверу необходимо около 400 Mb RAM, при хорошей настройке - не менее 200. 
При правильной конфигурации сервера не рекомендуется использовать swap. все должно помещаться в оперативной памяти (имеется ввиду, что у сервера swap-область быть должна, но она обязана быть пустой). Для предотвращения перегрузок рекомендуется пользоваться несколькими правилами, снижающими загрузку сервера. Придерживаясь этих правил можно съэкономить около 30% ресурсов сервера. 
Для статической информации всегда ставить last-modified в атрибут выдачу CGI-скриптов - документ без временного штампа не сохраняется в локальном кэше, и постоянно перезаписывается при просмотре. 
CGI программы хранить в любом каталоге кроме /CGI-BIN/, т.к. proxy-серверы не кэшируют файлы, находящиеся в этих каталогах, и каждый раз вынуждены обращаться к вам на сервер. 
Устанавливать поле last-modified у русского apache с автоматическим определением кодировки, чтобы на proxy-серверах не оставались файлы в некорректной кодировке. 
Не применять авторедирект по чарсету в русском apache. 
Не использовать фреймы, т.к. вместо одного файла появляется минимум 3. 
Не использовать анимированные *.gif, т.к. некоторые NN обращаются к серверу перед каждым циклом. 
404 код не делать cgi-скриптом, 404 код не делать ""красивым"" - с графическими изображениями и указаниями на прочие разделы, т.к. сошедший с ума робот собирает невероятное количество 404 ошибок, зацикливаясь в них на веки. 
Создать на сервере файл robot.txt, т.к. это самый запрашиваемый документ на сервере, и иначе порождает массу 404 (см. п. 7). А также разумные роботы слушаются запретов в этом файле, что уменьшает нагрузку на сервер. 
Не ставить баннеры наверху страницы, т.к. баннер сверху отнимает 1-2 реквеста из 4-х и в итоге грузится вперед тормозя ваши сайтовые картинки. 
При вызове баннера не обращаться каждый раз к CGI, а подставлять вместо случайного числа любое число, что можно сделать, например, получив дату на JavaScript. 
Вызывать баннеры программами на Си, т.к. Perl работает медленнее. 
На одной машине должен размещаться только информационный сервер, не одновременно с почтой и др. сервисами. 
На сегодня архитектура Internet/Intranet, в том числе и на платформе LINUX, уже используется при построении корпоративных ИС для решения задач автоматизации управления банками, управления проектированием, управления ТП, АСУ ТП, электронной коммерции, оперативной информации по курсу валют и акций и т.п. ",1
